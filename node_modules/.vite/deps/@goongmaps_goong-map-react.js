import {
  _extends,
  _objectWithoutPropertiesLoose
} from "./chunk-Y67KMEH3.js";
import {
  require_prop_types
} from "./chunk-4CB2EIFM.js";
import "./chunk-74CSGSWR.js";
import {
  _defineProperty,
  _toPropertyKey,
  _typeof
} from "./chunk-YEYV6HFT.js";
import {
  require_react
} from "./chunk-4D5CYJYK.js";
import {
  __commonJS,
  __toESM
} from "./chunk-CEQRFMJQ.js";

// node_modules/@goongmaps/goong-js/dist/goong-js.js
var require_goong_js = __commonJS({
  "node_modules/@goongmaps/goong-js/dist/goong-js.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.goongjs = factory());
    })(exports, function() {
      "use strict";
      var shared, worker, goongjs;
      function define2(_, chunk) {
        if (!shared) {
          shared = chunk;
        } else if (!worker) {
          worker = chunk;
        } else {
          var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);";
          var sharedChunk = {};
          shared(sharedChunk);
          goongjs = chunk(sharedChunk);
          goongjs.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
        }
      }
      define2(["exports"], function(t) {
        "use strict";
        function e(t2, e2) {
          return t2(e2 = { exports: {} }, e2.exports), e2.exports;
        }
        var r = n;
        function n(t2, e2, r2, n2) {
          this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = n2, this.p2x = r2, this.p2y = n2;
        }
        n.prototype.sampleCurveX = function(t2) {
          return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
        }, n.prototype.sampleCurveY = function(t2) {
          return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
        }, n.prototype.sampleCurveDerivativeX = function(t2) {
          return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
        }, n.prototype.solveCurveX = function(t2, e2) {
          var r2, n2, i2, a2, o2;
          for (void 0 === e2 && (e2 = 1e-6), i2 = t2, o2 = 0; o2 < 8; o2++) {
            if (a2 = this.sampleCurveX(i2) - t2, Math.abs(a2) < e2)
              return i2;
            var s2 = this.sampleCurveDerivativeX(i2);
            if (Math.abs(s2) < 1e-6)
              break;
            i2 -= a2 / s2;
          }
          if ((i2 = t2) < (r2 = 0))
            return r2;
          if (i2 > (n2 = 1))
            return n2;
          for (; r2 < n2; ) {
            if (a2 = this.sampleCurveX(i2), Math.abs(a2 - t2) < e2)
              return i2;
            t2 > a2 ? r2 = i2 : n2 = i2, i2 = 0.5 * (n2 - r2) + r2;
          }
          return i2;
        }, n.prototype.solve = function(t2, e2) {
          return this.sampleCurveY(this.solveCurveX(t2, e2));
        };
        var i = a;
        function a(t2, e2) {
          this.x = t2, this.y = e2;
        }
        function o(t2, e2, n2, i2) {
          var a2 = new r(t2, e2, n2, i2);
          return function(t3) {
            return a2.solve(t3);
          };
        }
        a.prototype = { clone: function() {
          return new a(this.x, this.y);
        }, add: function(t2) {
          return this.clone()._add(t2);
        }, sub: function(t2) {
          return this.clone()._sub(t2);
        }, multByPoint: function(t2) {
          return this.clone()._multByPoint(t2);
        }, divByPoint: function(t2) {
          return this.clone()._divByPoint(t2);
        }, mult: function(t2) {
          return this.clone()._mult(t2);
        }, div: function(t2) {
          return this.clone()._div(t2);
        }, rotate: function(t2) {
          return this.clone()._rotate(t2);
        }, rotateAround: function(t2, e2) {
          return this.clone()._rotateAround(t2, e2);
        }, matMult: function(t2) {
          return this.clone()._matMult(t2);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t2) {
          return this.x === t2.x && this.y === t2.y;
        }, dist: function(t2) {
          return Math.sqrt(this.distSqr(t2));
        }, distSqr: function(t2) {
          var e2 = t2.x - this.x, r2 = t2.y - this.y;
          return e2 * e2 + r2 * r2;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t2) {
          return Math.atan2(this.y - t2.y, this.x - t2.x);
        }, angleWith: function(t2) {
          return this.angleWithSep(t2.x, t2.y);
        }, angleWithSep: function(t2, e2) {
          return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
        }, _matMult: function(t2) {
          var e2 = t2[0] * this.x + t2[1] * this.y, r2 = t2[2] * this.x + t2[3] * this.y;
          return this.x = e2, this.y = r2, this;
        }, _add: function(t2) {
          return this.x += t2.x, this.y += t2.y, this;
        }, _sub: function(t2) {
          return this.x -= t2.x, this.y -= t2.y, this;
        }, _mult: function(t2) {
          return this.x *= t2, this.y *= t2, this;
        }, _div: function(t2) {
          return this.x /= t2, this.y /= t2, this;
        }, _multByPoint: function(t2) {
          return this.x *= t2.x, this.y *= t2.y, this;
        }, _divByPoint: function(t2) {
          return this.x /= t2.x, this.y /= t2.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t2 = this.y;
          return this.y = this.x, this.x = -t2, this;
        }, _rotate: function(t2) {
          var e2 = Math.cos(t2), r2 = Math.sin(t2), n2 = e2 * this.x - r2 * this.y, i2 = r2 * this.x + e2 * this.y;
          return this.x = n2, this.y = i2, this;
        }, _rotateAround: function(t2, e2) {
          var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), a2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
          return this.x = i2, this.y = a2, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, a.convert = function(t2) {
          return t2 instanceof a ? t2 : Array.isArray(t2) ? new a(t2[0], t2[1]) : t2;
        };
        var s = o(0.25, 0.1, 0.25, 1);
        function u(t2, e2, r2) {
          return Math.min(r2, Math.max(e2, t2));
        }
        function l(t2, e2, r2) {
          var n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
          return i2 === e2 ? r2 : i2;
        }
        function p(t2) {
          for (var e2 = [], r2 = arguments.length - 1; r2-- > 0; )
            e2[r2] = arguments[r2 + 1];
          for (var n2 = 0, i2 = e2; n2 < i2.length; n2 += 1) {
            var a2 = i2[n2];
            for (var o2 in a2)
              t2[o2] = a2[o2];
          }
          return t2;
        }
        var c = 1;
        function h() {
          return c++;
        }
        function f() {
          return function t2(e2) {
            return e2 ? (e2 ^ 16 * Math.random() >> e2 / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t2);
          }();
        }
        function y(t2) {
          return !!t2 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t2);
        }
        function d(t2, e2) {
          t2.forEach(function(t3) {
            e2[t3] && (e2[t3] = e2[t3].bind(e2));
          });
        }
        function m(t2, e2) {
          return -1 !== t2.indexOf(e2, t2.length - e2.length);
        }
        function v(t2, e2, r2) {
          var n2 = {};
          for (var i2 in t2)
            n2[i2] = e2.call(r2 || this, t2[i2], i2, t2);
          return n2;
        }
        function g(t2, e2, r2) {
          var n2 = {};
          for (var i2 in t2)
            e2.call(r2 || this, t2[i2], i2, t2) && (n2[i2] = t2[i2]);
          return n2;
        }
        function x(t2) {
          return Array.isArray(t2) ? t2.map(x) : "object" == typeof t2 && t2 ? v(t2, x) : t2;
        }
        var b = {};
        function _(t2) {
          b[t2] || ("undefined" != typeof console && console.warn(t2), b[t2] = true);
        }
        function w(t2, e2, r2) {
          return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
        }
        function A(t2) {
          for (var e2 = 0, r2 = 0, n2 = t2.length, i2 = n2 - 1, a2 = void 0, o2 = void 0; r2 < n2; i2 = r2++)
            a2 = t2[r2], e2 += ((o2 = t2[i2]).x - a2.x) * (a2.y + o2.y);
          return e2;
        }
        function S() {
          return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        function k(t2) {
          var e2 = {};
          if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, function(t3, r3, n2, i2) {
            var a2 = n2 || i2;
            return e2[r3] = !a2 || a2.toLowerCase(), "";
          }), e2["max-age"]) {
            var r2 = parseInt(e2["max-age"], 10);
            isNaN(r2) ? delete e2["max-age"] : e2["max-age"] = r2;
          }
          return e2;
        }
        var I = null;
        function z(t2) {
          if (null == I) {
            var e2 = t2.navigator ? t2.navigator.userAgent : null;
            I = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
          }
          return I;
        }
        function C(t2) {
          try {
            var e2 = self[t2];
            return e2.setItem("_mapbox_test_", 1), e2.removeItem("_mapbox_test_"), true;
          } catch (t3) {
            return false;
          }
        }
        var B, P, T, E, M = self.performance && self.performance.now ? self.performance.now.bind(self.performance) : Date.now.bind(Date), V = self.requestAnimationFrame || self.mozRequestAnimationFrame || self.webkitRequestAnimationFrame || self.msRequestAnimationFrame, F = self.cancelAnimationFrame || self.mozCancelAnimationFrame || self.webkitCancelAnimationFrame || self.msCancelAnimationFrame, L = { now: M, frame: function(t2) {
          var e2 = V(t2);
          return { cancel: function() {
            return F(e2);
          } };
        }, getImageData: function(t2, e2) {
          void 0 === e2 && (e2 = 0);
          var r2 = self.document.createElement("canvas"), n2 = r2.getContext("2d");
          if (!n2)
            throw new Error("failed to create canvas 2d context");
          return r2.width = t2.width, r2.height = t2.height, n2.drawImage(t2, 0, 0, t2.width, t2.height), n2.getImageData(-e2, -e2, t2.width + 2 * e2, t2.height + 2 * e2);
        }, resolveURL: function(t2) {
          return B || (B = self.document.createElement("a")), B.href = t2, B.href;
        }, hardwareConcurrency: self.navigator.hardwareConcurrency || 4, get devicePixelRatio() {
          return self.devicePixelRatio;
        }, get prefersReducedMotion() {
          return !!self.matchMedia && (null == P && (P = self.matchMedia("(prefers-reduced-motion: reduce)")), P.matches);
        } }, O = { API_URL: "https://tiles.goong.io", get EVENTS_URL() {
          return "https://rsapi.goong.io";
        }, FEEDBACK_URL: "https://goong.io", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, D = { supported: false, testSupport: function(t2) {
          if (R || !E)
            return;
          U ? j(t2) : T = t2;
        } }, R = false, U = false;
        function j(t2) {
          var e2 = t2.createTexture();
          t2.bindTexture(t2.TEXTURE_2D, e2);
          try {
            if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, E), t2.isContextLost())
              return;
            D.supported = true;
          } catch (t3) {
          }
          t2.deleteTexture(e2), R = true;
        }
        self.document && ((E = self.document.createElement("img")).onload = function() {
          T && j(T), T = null, U = true;
        }, E.onerror = function() {
          R = true, T = null;
        }, E.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        var q = "01";
        var N = function(t2, e2) {
          this._transformRequestFn = t2, this._customAccessToken = e2, this._createSkuToken();
        };
        function K(t2) {
          return 0 === t2.indexOf("https://tiles.goong.io");
        }
        N.prototype._createSkuToken = function() {
          var t2 = function() {
            for (var t3 = "", e2 = 0; e2 < 10; e2++)
              t3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
            return { token: ["1", q, t3].join(""), tokenExpiresAt: Date.now() + 432e5 };
          }();
          this._skuToken = t2.token, this._skuTokenExpiresAt = t2.tokenExpiresAt;
        }, N.prototype._isSkuTokenExpired = function() {
          return Date.now() > this._skuTokenExpiresAt;
        }, N.prototype.transformRequest = function(t2, e2) {
          return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
        }, N.prototype.normalizeStyleURL = function(t2, e2) {
          if (!K(t2))
            return t2;
          var r2 = J(t2);
          return this._makeAPIURL(r2, this._customAccessToken || e2);
        }, N.prototype.normalizeGlyphsURL = function(t2, e2) {
          if (!K(t2))
            return t2;
          var r2 = J(t2);
          return this._makeAPIURL(r2, this._customAccessToken || e2);
        }, N.prototype.normalizeSourceURL = function(t2, e2) {
          if (!K(t2))
            return t2;
          var r2 = J(t2);
          return this._makeAPIURL(r2, this._customAccessToken || e2);
        }, N.prototype.normalizeSpriteURL = function(t2, e2, r2, n2) {
          var i2 = J(t2);
          return K(t2) ? (i2.path = "" + i2.path + e2 + r2, this._makeAPIURL(i2, this._customAccessToken || n2)) : (i2.path += "" + e2 + r2, H(i2));
        }, N.prototype.normalizeTileURL = function(t2, e2, r2) {
          if (this._isSkuTokenExpired() && this._createSkuToken(), !e2 || !K(e2))
            return t2;
          var n2 = J(t2), i2 = L.devicePixelRatio >= 2 || 512 === r2 ? "@2x" : "", a2 = D.supported ? ".webp" : "$1";
          return n2.path = n2.path.replace(/(\.(png|jpg)\d*)(?=$)/, "" + i2 + a2), n2.path = n2.path.replace(/^.+\/v4\//, "/"), O.REQUIRE_ACCESS_TOKEN && (O.ACCESS_TOKEN || this._customAccessToken) && this._skuToken && n2.params.push("sku=" + this._skuToken), this._makeAPIURL(n2, this._customAccessToken);
        }, N.prototype.canonicalizeTileURL = function(t2) {
          var e2 = J(t2);
          if (!e2.path.match(/(^\/v4\/)/) || !e2.path.match(/\.[\w]+$/))
            return t2;
          var r2 = "mapbox://tiles/";
          r2 += e2.path.replace("/v4/", "");
          var n2 = e2.params.filter(function(t3) {
            return !t3.match(/^api_key=/);
          });
          return n2.length && (r2 += "?" + n2.join("&")), r2;
        }, N.prototype.canonicalizeTileset = function(t2, e2) {
          if (!K(e2))
            return t2.tiles || [];
          for (var r2 = [], n2 = 0, i2 = t2.tiles; n2 < i2.length; n2 += 1) {
            var a2 = i2[n2], o2 = this.canonicalizeTileURL(a2);
            r2.push(o2);
          }
          return r2;
        }, N.prototype._makeAPIURL = function(t2, e2) {
          var r2 = J(O.API_URL);
          if (t2.protocol = r2.protocol, t2.authority = r2.authority, "/" !== r2.path && (t2.path = "" + r2.path + t2.path), !O.REQUIRE_ACCESS_TOKEN)
            return H(t2);
          if (!(e2 = e2 || O.ACCESS_TOKEN))
            throw new Error("An API access token is required to use Goong JS. See https://docs.goong.io");
          return t2.params = t2.params.filter(function(t3) {
            return -1 === t3.indexOf("api_key");
          }), t2.params.push("api_key=" + e2), H(t2);
        };
        var X = /^((https?:)?\/\/)?([^\/]+\.)?goong\.io(\/|\?|$)/i;
        function Z(t2) {
          return X.test(t2);
        }
        var G = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function J(t2) {
          var e2 = t2.match(G);
          if (!e2)
            throw new Error("Unable to parse URL object");
          return { protocol: e2[1], authority: e2[2], path: e2[3] || "/", params: e2[4] ? e2[4].split("&") : [] };
        }
        function H(t2) {
          var e2 = t2.params.length ? "?" + t2.params.join("&") : "";
          return t2.protocol + "://" + t2.authority + t2.path + e2;
        }
        function Y(t2) {
          if (!t2)
            return null;
          var e2, r2 = t2.split(".");
          if (!r2 || 3 !== r2.length)
            return null;
          try {
            return JSON.parse((e2 = r2[1], decodeURIComponent(self.atob(e2).split("").map(function(t3) {
              return "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2);
            }).join(""))));
          } catch (t3) {
            return null;
          }
        }
        var $ = function(t2) {
          this.type = t2, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
        };
        $.prototype.getStorageKey = function(t2) {
          var e2, r2 = Y(O.ACCESS_TOKEN), n2 = "";
          return r2 && r2.u ? (e2 = r2.u, n2 = self.btoa(encodeURIComponent(e2).replace(/%([0-9A-F]{2})/g, function(t3, e3) {
            return String.fromCharCode(Number("0x" + e3));
          }))) : n2 = O.ACCESS_TOKEN || "", t2 ? "goong.eventData." + t2 + ":" + n2 : "goong.eventData:" + n2;
        }, $.prototype.fetchEventData = function() {
          var t2 = C("localStorage"), e2 = this.getStorageKey(), r2 = this.getStorageKey("uuid");
          if (t2)
            try {
              var n2 = self.localStorage.getItem(e2);
              n2 && (this.eventData = JSON.parse(n2));
              var i2 = self.localStorage.getItem(r2);
              i2 && (this.anonId = i2);
            } catch (t3) {
              _("Unable to read from LocalStorage");
            }
        }, $.prototype.saveEventData = function() {
          var t2 = C("localStorage"), e2 = this.getStorageKey(), r2 = this.getStorageKey("uuid");
          if (t2)
            try {
              self.localStorage.setItem(r2, this.anonId), Object.keys(this.eventData).length >= 1 && self.localStorage.setItem(e2, JSON.stringify(this.eventData));
            } catch (t3) {
              _("Unable to write to LocalStorage");
            }
        }, $.prototype.processRequests = function(t2) {
        }, $.prototype.postEvent = function(t2, e2, r2, n2) {
        }, $.prototype.queueRequest = function(t2, e2) {
          this.queue.push(t2), this.processRequests(e2);
        };
        var W, Q, tt = function(t2) {
          function e2() {
            t2.call(this, "map.load"), this.success = {}, this.skuToken = "";
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.postMapLoadEvent = function(t3, e3, r2, n2) {
            this.skuToken = r2, (O.EVENTS_URL && n2 || O.ACCESS_TOKEN && Array.isArray(t3) && t3.some(function(t4) {
              return K(t4) || Z(t4);
            })) && this.queueRequest({ id: e3, timestamp: Date.now() }, n2);
          }, e2.prototype.processRequests = function(t3) {
            var e3 = this;
            if (!this.pendingRequest && 0 !== this.queue.length) {
              var r2 = this.queue.shift(), n2 = r2.id, i2 = r2.timestamp;
              n2 && this.success[n2] || (this.anonId || this.fetchEventData(), y(this.anonId) || (this.anonId = f()), this.postEvent(i2, { skuToken: this.skuToken }, function(t4) {
                t4 || n2 && (e3.success[n2] = true);
              }, t3));
            }
          }, e2;
        }($), et = new (function(t2) {
          function e2(e3) {
            t2.call(this, "appUserTurnstile"), this._customAccessToken = e3;
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.postTurnstileEvent = function(t3, e3) {
            O.EVENTS_URL && O.ACCESS_TOKEN && Array.isArray(t3) && t3.some(function(t4) {
              return K(t4) || Z(t4);
            }) && this.queueRequest(Date.now(), e3);
          }, e2.prototype.processRequests = function(t3) {
            var e3 = this;
            if (!this.pendingRequest && 0 !== this.queue.length) {
              this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
              var r2 = Y(O.ACCESS_TOKEN), n2 = r2 ? r2.u : O.ACCESS_TOKEN, i2 = n2 !== this.eventData.tokenU;
              y(this.anonId) || (this.anonId = f(), i2 = true);
              var a2 = this.queue.shift();
              if (this.eventData.lastSuccess) {
                var o2 = new Date(this.eventData.lastSuccess), s2 = new Date(a2), u2 = (a2 - this.eventData.lastSuccess) / 864e5;
                i2 = i2 || u2 >= 1 || u2 < -1 || o2.getDate() !== s2.getDate();
              } else
                i2 = true;
              if (!i2)
                return this.processRequests();
              this.postEvent(a2, { "enabled.telemetry": false }, function(t4) {
                t4 || (e3.eventData.lastSuccess = a2, e3.eventData.tokenU = n2);
              }, t3);
            }
          }, e2;
        }($))(), rt = et.postTurnstileEvent.bind(et), nt = new tt(), it = nt.postMapLoadEvent.bind(nt), at = 500, ot = 50;
        function st() {
          self.caches && !W && (W = self.caches.open("mapbox-tiles"));
        }
        function ut(t2, e2, r2) {
          if (st(), W) {
            var n2 = { status: e2.status, statusText: e2.statusText, headers: new self.Headers() };
            e2.headers.forEach(function(t3, e3) {
              return n2.headers.set(e3, t3);
            });
            var i2 = k(e2.headers.get("Cache-Control") || "");
            if (!i2["no-store"])
              i2["max-age"] && n2.headers.set("Expires", new Date(r2 + 1e3 * i2["max-age"]).toUTCString()), new Date(n2.headers.get("Expires")).getTime() - r2 < 42e4 || function(t3, e3) {
                if (void 0 === Q)
                  try {
                    new Response(new ReadableStream()), Q = true;
                  } catch (t4) {
                    Q = false;
                  }
                Q ? e3(t3.body) : t3.blob().then(e3);
              }(e2, function(e3) {
                var r3 = new self.Response(e3, n2);
                st(), W && W.then(function(e4) {
                  return e4.put(lt(t2.url), r3);
                }).catch(function(t3) {
                  return _(t3.message);
                });
              });
          }
        }
        function lt(t2) {
          var e2 = t2.indexOf("?");
          return e2 < 0 ? t2 : t2.slice(0, e2);
        }
        function pt(t2, e2) {
          if (st(), !W)
            return e2(null);
          var r2 = lt(t2.url);
          W.then(function(t3) {
            t3.match(r2).then(function(n2) {
              var i2 = function(t4) {
                if (!t4)
                  return false;
                var e3 = new Date(t4.headers.get("Expires") || 0), r3 = k(t4.headers.get("Cache-Control") || "");
                return e3 > Date.now() && !r3["no-cache"];
              }(n2);
              t3.delete(r2), i2 && t3.put(r2, n2.clone()), e2(null, n2, i2);
            }).catch(e2);
          }).catch(e2);
        }
        var ct, ht = 1 / 0;
        function ft() {
          return null == ct && (ct = self.OffscreenCanvas && new self.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof self.createImageBitmap), ct;
        }
        var yt = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
        "function" == typeof Object.freeze && Object.freeze(yt);
        var dt = function(t2) {
          function e2(e3, r2, n2) {
            401 === r2 && Z(n2) && (e3 += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), t2.call(this, e3), this.status = r2, this.url = n2, this.name = this.constructor.name, this.message = e3;
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.toString = function() {
            return this.name + ": " + this.message + " (" + this.status + "): " + this.url;
          }, e2;
        }(Error), mt = S() ? function() {
          return self.worker && self.worker.referrer;
        } : function() {
          return ("blob:" === self.location.protocol ? self.parent : self).location.href;
        };
        function vt(t2, e2) {
          var r2, n2 = new self.AbortController(), i2 = new self.Request(t2.url, { method: t2.method || "GET", body: t2.body, credentials: t2.credentials, headers: t2.headers, referrer: mt(), signal: n2.signal }), a2 = false, o2 = false, s2 = (r2 = i2.url).indexOf("sku=") > 0 && Z(r2);
          "json" === t2.type && i2.headers.set("Accept", "application/json");
          var u2 = function(r3, n3, a3) {
            if (!o2) {
              if (r3 && "SecurityError" !== r3.message && _(r3), n3 && a3)
                return l2(n3);
              var u3 = Date.now();
              self.fetch(i2).then(function(r4) {
                if (r4.ok) {
                  var n4 = s2 ? r4.clone() : null;
                  return l2(r4, n4, u3);
                }
                return e2(new dt(r4.statusText, r4.status, t2.url));
              }).catch(function(t3) {
                20 !== t3.code && e2(new Error(t3.message));
              });
            }
          }, l2 = function(r3, n3, s3) {
            ("arrayBuffer" === t2.type ? r3.arrayBuffer() : "json" === t2.type ? r3.json() : r3.text()).then(function(t3) {
              o2 || (n3 && s3 && ut(i2, n3, s3), a2 = true, e2(null, t3, r3.headers.get("Cache-Control"), r3.headers.get("Expires")));
            }).catch(function(t3) {
              o2 || e2(new Error(t3.message));
            });
          };
          return s2 ? pt(i2, u2) : u2(null, null), { cancel: function() {
            o2 = true, a2 || n2.abort();
          } };
        }
        var gt = function(t2, e2) {
          if (r2 = t2.url, !(/^file:/.test(r2) || /^file:/.test(mt()) && !/^\w+:/.test(r2))) {
            if (self.fetch && self.Request && self.AbortController && self.Request.prototype.hasOwnProperty("signal"))
              return vt(t2, e2);
            if (S() && self.worker && self.worker.actor) {
              return self.worker.actor.send("getResource", t2, e2, void 0, true);
            }
          }
          var r2;
          return function(t3, e3) {
            var r3 = new self.XMLHttpRequest();
            for (var n2 in r3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (r3.responseType = "arraybuffer"), t3.headers)
              r3.setRequestHeader(n2, t3.headers[n2]);
            return "json" === t3.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t3.credentials, r3.onerror = function() {
              e3(new Error(r3.statusText));
            }, r3.onload = function() {
              if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
                var n3 = r3.response;
                if ("json" === t3.type)
                  try {
                    n3 = JSON.parse(r3.response);
                  } catch (t4) {
                    return e3(t4);
                  }
                e3(null, n3, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
              } else
                e3(new dt(r3.statusText, r3.status, t3.url));
            }, r3.send(t3.body), { cancel: function() {
              return r3.abort();
            } };
          }(t2, e2);
        }, xt = function(t2, e2) {
          return gt(p(t2, { type: "arrayBuffer" }), e2);
        };
        var bt, _t;
        bt = [], _t = 0;
        var wt = function(t2, e2) {
          if (D.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), _t >= O.MAX_PARALLEL_IMAGE_REQUESTS) {
            var r2 = { requestParameters: t2, callback: e2, cancelled: false, cancel: function() {
              this.cancelled = true;
            } };
            return bt.push(r2), r2;
          }
          _t++;
          var n2 = false, i2 = function() {
            if (!n2)
              for (n2 = true, _t--; bt.length && _t < O.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                var t3 = bt.shift(), e3 = t3.requestParameters, r3 = t3.callback;
                t3.cancelled || (t3.cancel = wt(e3, r3).cancel);
              }
          }, a2 = xt(t2, function(t3, r3, n3, a3) {
            i2(), t3 ? e2(t3) : r3 && (ft() ? function(t4, e3) {
              var r4 = new self.Blob([new Uint8Array(t4)], { type: "image/png" });
              self.createImageBitmap(r4).then(function(t5) {
                e3(null, t5);
              }).catch(function() {
                e3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              });
            }(r3, e2) : function(t4, e3, r4, n4) {
              var i3 = new self.Image(), a4 = self.URL;
              i3.onload = function() {
                e3(null, i3), a4.revokeObjectURL(i3.src);
              }, i3.onerror = function() {
                return e3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              };
              var o2 = new self.Blob([new Uint8Array(t4)], { type: "image/png" });
              i3.cacheControl = r4, i3.expires = n4, i3.src = t4.byteLength ? a4.createObjectURL(o2) : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
            }(r3, e2, n3, a3));
          });
          return { cancel: function() {
            a2.cancel(), i2();
          } };
        };
        function At(t2, e2, r2) {
          r2[t2] && -1 !== r2[t2].indexOf(e2) || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
        }
        function St(t2, e2, r2) {
          if (r2 && r2[t2]) {
            var n2 = r2[t2].indexOf(e2);
            -1 !== n2 && r2[t2].splice(n2, 1);
          }
        }
        var kt = function(t2, e2) {
          void 0 === e2 && (e2 = {}), p(this, e2), this.type = t2;
        }, It = function(t2) {
          function e2(e3, r2) {
            void 0 === r2 && (r2 = {}), t2.call(this, "error", p({ error: e3 }, r2));
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2;
        }(kt), zt = function() {
        };
        zt.prototype.on = function(t2, e2) {
          return this._listeners = this._listeners || {}, At(t2, e2, this._listeners), this;
        }, zt.prototype.off = function(t2, e2) {
          return St(t2, e2, this._listeners), St(t2, e2, this._oneTimeListeners), this;
        }, zt.prototype.once = function(t2, e2) {
          return this._oneTimeListeners = this._oneTimeListeners || {}, At(t2, e2, this._oneTimeListeners), this;
        }, zt.prototype.fire = function(t2, e2) {
          "string" == typeof t2 && (t2 = new kt(t2, e2 || {}));
          var r2 = t2.type;
          if (this.listens(r2)) {
            t2.target = this;
            for (var n2 = 0, i2 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : []; n2 < i2.length; n2 += 1) {
              i2[n2].call(this, t2);
            }
            for (var a2 = 0, o2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : []; a2 < o2.length; a2 += 1) {
              var s2 = o2[a2];
              St(r2, s2, this._oneTimeListeners), s2.call(this, t2);
            }
            var u2 = this._eventedParent;
            u2 && (p(t2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), u2.fire(t2));
          } else
            t2 instanceof It && console.error(t2.error);
          return this;
        }, zt.prototype.listens = function(t2) {
          return this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2);
        }, zt.prototype.setEventedParent = function(t2, e2) {
          return this._eventedParent = t2, this._eventedParentData = e2, this;
        };
        var Ct = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sources: { required: true, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, promoteId: { type: "promoteId" }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Roboto Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, expression_name: { type: "enum", values: { let: { group: "Variable binding" }, var: { group: "Variable binding" }, literal: { group: "Types" }, array: { group: "Types" }, at: { group: "Lookup" }, in: { group: "Lookup" }, case: { group: "Decision" }, match: { group: "Decision" }, coalesce: { group: "Decision" }, step: { group: "Ramps, scales, curves" }, interpolate: { group: "Ramps, scales, curves" }, "interpolate-hcl": { group: "Ramps, scales, curves" }, "interpolate-lab": { group: "Ramps, scales, curves" }, ln2: { group: "Math" }, pi: { group: "Math" }, e: { group: "Math" }, typeof: { group: "Types" }, string: { group: "Types" }, number: { group: "Types" }, boolean: { group: "Types" }, object: { group: "Types" }, collator: { group: "Types" }, format: { group: "Types" }, image: { group: "Types" }, "number-format": { group: "Types" }, "to-string": { group: "Types" }, "to-number": { group: "Types" }, "to-boolean": { group: "Types" }, "to-rgba": { group: "Color" }, "to-color": { group: "Types" }, rgb: { group: "Color" }, rgba: { group: "Color" }, get: { group: "Lookup" }, has: { group: "Lookup" }, length: { group: "Lookup" }, properties: { group: "Feature data" }, "feature-state": { group: "Feature data" }, "geometry-type": { group: "Feature data" }, id: { group: "Feature data" }, zoom: { group: "Zoom" }, "heatmap-density": { group: "Heatmap" }, "line-progress": { group: "Feature data" }, accumulated: { group: "Feature data" }, "+": { group: "Math" }, "*": { group: "Math" }, "-": { group: "Math" }, "/": { group: "Math" }, "%": { group: "Math" }, "^": { group: "Math" }, sqrt: { group: "Math" }, log10: { group: "Math" }, ln: { group: "Math" }, log2: { group: "Math" }, sin: { group: "Math" }, cos: { group: "Math" }, tan: { group: "Math" }, asin: { group: "Math" }, acos: { group: "Math" }, atan: { group: "Math" }, min: { group: "Math" }, max: { group: "Math" }, round: { group: "Math" }, abs: { group: "Math" }, ceil: { group: "Math" }, floor: { group: "Math" }, "==": { group: "Decision" }, "!=": { group: "Decision" }, ">": { group: "Decision" }, "<": { group: "Decision" }, ">=": { group: "Decision" }, "<=": { group: "Decision" }, all: { group: "Decision" }, any: { group: "Decision" }, "!": { group: "Decision" }, "is-supported-script": { group: "String" }, upcase: { group: "String" }, downcase: { group: "String" }, concat: { group: "String" }, "resolved-locale": { group: "String" } } }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } } }, Bt = function(t2, e2, r2, n2) {
          this.message = (t2 ? t2 + ": " : "") + r2, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
        };
        function Pt(t2) {
          var e2 = t2.key, r2 = t2.value;
          return r2 ? [new Bt(e2, r2, "constants have been deprecated as of v8")] : [];
        }
        function Tt(t2) {
          for (var e2 = [], r2 = arguments.length - 1; r2-- > 0; )
            e2[r2] = arguments[r2 + 1];
          for (var n2 = 0, i2 = e2; n2 < i2.length; n2 += 1) {
            var a2 = i2[n2];
            for (var o2 in a2)
              t2[o2] = a2[o2];
          }
          return t2;
        }
        function Et(t2) {
          return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
        }
        function Mt(t2) {
          if (Array.isArray(t2))
            return t2.map(Mt);
          if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
            var e2 = {};
            for (var r2 in t2)
              e2[r2] = Mt(t2[r2]);
            return e2;
          }
          return Et(t2);
        }
        var Vt = function(t2) {
          function e2(e3, r2) {
            t2.call(this, r2), this.message = r2, this.key = e3;
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2;
        }(Error), Ft = function(t2, e2) {
          void 0 === e2 && (e2 = []), this.parent = t2, this.bindings = {};
          for (var r2 = 0, n2 = e2; r2 < n2.length; r2 += 1) {
            var i2 = n2[r2], a2 = i2[0], o2 = i2[1];
            this.bindings[a2] = o2;
          }
        };
        Ft.prototype.concat = function(t2) {
          return new Ft(this, t2);
        }, Ft.prototype.get = function(t2) {
          if (this.bindings[t2])
            return this.bindings[t2];
          if (this.parent)
            return this.parent.get(t2);
          throw new Error(t2 + " not found in scope.");
        }, Ft.prototype.has = function(t2) {
          return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
        };
        var Lt = { kind: "null" }, Ot = { kind: "number" }, Dt = { kind: "string" }, Rt = { kind: "boolean" }, Ut = { kind: "color" }, jt = { kind: "object" }, qt = { kind: "value" }, Nt = { kind: "collator" }, Kt = { kind: "formatted" }, Xt = { kind: "resolvedImage" };
        function Zt(t2, e2) {
          return { kind: "array", itemType: t2, N: e2 };
        }
        function Gt(t2) {
          if ("array" === t2.kind) {
            var e2 = Gt(t2.itemType);
            return "number" == typeof t2.N ? "array<" + e2 + ", " + t2.N + ">" : "value" === t2.itemType.kind ? "array" : "array<" + e2 + ">";
          }
          return t2.kind;
        }
        var Jt = [Lt, Ot, Dt, Rt, Ut, Kt, jt, Zt(qt), Xt];
        function Ht(t2, e2) {
          if ("error" === e2.kind)
            return null;
          if ("array" === t2.kind) {
            if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !Ht(t2.itemType, e2.itemType)) && ("number" != typeof t2.N || t2.N === e2.N))
              return null;
          } else {
            if (t2.kind === e2.kind)
              return null;
            if ("value" === t2.kind)
              for (var r2 = 0, n2 = Jt; r2 < n2.length; r2 += 1) {
                if (!Ht(n2[r2], e2))
                  return null;
              }
          }
          return "Expected " + Gt(t2) + " but found " + Gt(e2) + " instead.";
        }
        var Yt = e(function(t2, e2) {
          var r2 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
          function n2(t3) {
            return (t3 = Math.round(t3)) < 0 ? 0 : t3 > 255 ? 255 : t3;
          }
          function i2(t3) {
            return t3 < 0 ? 0 : t3 > 1 ? 1 : t3;
          }
          function a2(t3) {
            return "%" === t3[t3.length - 1] ? n2(parseFloat(t3) / 100 * 255) : n2(parseInt(t3));
          }
          function o2(t3) {
            return "%" === t3[t3.length - 1] ? i2(parseFloat(t3) / 100) : i2(parseFloat(t3));
          }
          function s2(t3, e3, r3) {
            return r3 < 0 ? r3 += 1 : r3 > 1 && (r3 -= 1), 6 * r3 < 1 ? t3 + (e3 - t3) * r3 * 6 : 2 * r3 < 1 ? e3 : 3 * r3 < 2 ? t3 + (e3 - t3) * (2 / 3 - r3) * 6 : t3;
          }
          try {
            e2.parseCSSColor = function(t3) {
              var e3, i3 = t3.replace(/ /g, "").toLowerCase();
              if (i3 in r2)
                return r2[i3].slice();
              if ("#" === i3[0])
                return 4 === i3.length ? (e3 = parseInt(i3.substr(1), 16)) >= 0 && e3 <= 4095 ? [(3840 & e3) >> 4 | (3840 & e3) >> 8, 240 & e3 | (240 & e3) >> 4, 15 & e3 | (15 & e3) << 4, 1] : null : 7 === i3.length && (e3 = parseInt(i3.substr(1), 16)) >= 0 && e3 <= 16777215 ? [(16711680 & e3) >> 16, (65280 & e3) >> 8, 255 & e3, 1] : null;
              var u2 = i3.indexOf("("), l2 = i3.indexOf(")");
              if (-1 !== u2 && l2 + 1 === i3.length) {
                var p2 = i3.substr(0, u2), c2 = i3.substr(u2 + 1, l2 - (u2 + 1)).split(","), h2 = 1;
                switch (p2) {
                  case "rgba":
                    if (4 !== c2.length)
                      return null;
                    h2 = o2(c2.pop());
                  case "rgb":
                    return 3 !== c2.length ? null : [a2(c2[0]), a2(c2[1]), a2(c2[2]), h2];
                  case "hsla":
                    if (4 !== c2.length)
                      return null;
                    h2 = o2(c2.pop());
                  case "hsl":
                    if (3 !== c2.length)
                      return null;
                    var f2 = (parseFloat(c2[0]) % 360 + 360) % 360 / 360, y2 = o2(c2[1]), d2 = o2(c2[2]), m2 = d2 <= 0.5 ? d2 * (y2 + 1) : d2 + y2 - d2 * y2, v2 = 2 * d2 - m2;
                    return [n2(255 * s2(v2, m2, f2 + 1 / 3)), n2(255 * s2(v2, m2, f2)), n2(255 * s2(v2, m2, f2 - 1 / 3)), h2];
                  default:
                    return null;
                }
              }
              return null;
            };
          } catch (t3) {
          }
        }).parseCSSColor, $t = function(t2, e2, r2, n2) {
          void 0 === n2 && (n2 = 1), this.r = t2, this.g = e2, this.b = r2, this.a = n2;
        };
        $t.parse = function(t2) {
          if (t2) {
            if (t2 instanceof $t)
              return t2;
            if ("string" == typeof t2) {
              var e2 = Yt(t2);
              if (e2)
                return new $t(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]);
            }
          }
        }, $t.prototype.toString = function() {
          var t2 = this.toArray(), e2 = t2[0], r2 = t2[1], n2 = t2[2], i2 = t2[3];
          return "rgba(" + Math.round(e2) + "," + Math.round(r2) + "," + Math.round(n2) + "," + i2 + ")";
        }, $t.prototype.toArray = function() {
          var t2 = this.r, e2 = this.g, r2 = this.b, n2 = this.a;
          return 0 === n2 ? [0, 0, 0, 0] : [255 * t2 / n2, 255 * e2 / n2, 255 * r2 / n2, n2];
        }, $t.black = new $t(0, 0, 0, 1), $t.white = new $t(1, 1, 1, 1), $t.transparent = new $t(0, 0, 0, 0), $t.red = new $t(1, 0, 0, 1);
        var Wt = function(t2, e2, r2) {
          this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        };
        Wt.prototype.compare = function(t2, e2) {
          return this.collator.compare(t2, e2);
        }, Wt.prototype.resolvedLocale = function() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        };
        var Qt = function(t2, e2, r2, n2, i2) {
          this.text = t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
        }, te = function(t2) {
          this.sections = t2;
        };
        te.fromString = function(t2) {
          return new te([new Qt(t2, null, null, null, null)]);
        }, te.prototype.isEmpty = function() {
          return 0 === this.sections.length || !this.sections.some(function(t2) {
            return 0 !== t2.text.length || t2.image && 0 !== t2.image.name.length;
          });
        }, te.factory = function(t2) {
          return t2 instanceof te ? t2 : te.fromString(t2);
        }, te.prototype.toString = function() {
          return 0 === this.sections.length ? "" : this.sections.map(function(t2) {
            return t2.text;
          }).join("");
        }, te.prototype.serialize = function() {
          for (var t2 = ["format"], e2 = 0, r2 = this.sections; e2 < r2.length; e2 += 1) {
            var n2 = r2[e2];
            if (n2.image)
              t2.push(["image", n2.image.name]);
            else {
              t2.push(n2.text);
              var i2 = {};
              n2.fontStack && (i2["text-font"] = ["literal", n2.fontStack.split(",")]), n2.scale && (i2["font-scale"] = n2.scale), n2.textColor && (i2["text-color"] = ["rgba"].concat(n2.textColor.toArray())), t2.push(i2);
            }
          }
          return t2;
        };
        var ee = function(t2) {
          this.name = t2.name, this.available = t2.available;
        };
        function re(t2, e2, r2, n2) {
          return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : "Invalid rgba value [" + [t2, e2, r2, n2].join(", ") + "]: 'a' must be between 0 and 1." : "Invalid rgba value [" + ("number" == typeof n2 ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255.";
        }
        function ne(t2) {
          if (null === t2)
            return Lt;
          if ("string" == typeof t2)
            return Dt;
          if ("boolean" == typeof t2)
            return Rt;
          if ("number" == typeof t2)
            return Ot;
          if (t2 instanceof $t)
            return Ut;
          if (t2 instanceof Wt)
            return Nt;
          if (t2 instanceof te)
            return Kt;
          if (t2 instanceof ee)
            return Xt;
          if (Array.isArray(t2)) {
            for (var e2, r2 = t2.length, n2 = 0, i2 = t2; n2 < i2.length; n2 += 1) {
              var a2 = ne(i2[n2]);
              if (e2) {
                if (e2 === a2)
                  continue;
                e2 = qt;
                break;
              }
              e2 = a2;
            }
            return Zt(e2 || qt, r2);
          }
          return jt;
        }
        function ie(t2) {
          var e2 = typeof t2;
          return null === t2 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t2) : t2 instanceof $t || t2 instanceof te || t2 instanceof ee ? t2.toString() : JSON.stringify(t2);
        }
        ee.prototype.toString = function() {
          return this.name;
        }, ee.fromString = function(t2) {
          return new ee({ name: t2, available: false });
        }, ee.prototype.serialize = function() {
          return ["image", this.name];
        };
        var ae = function(t2, e2) {
          this.type = t2, this.value = e2;
        };
        ae.parse = function(t2, e2) {
          if (2 !== t2.length)
            return e2.error("'literal' expression requires exactly one argument, but found " + (t2.length - 1) + " instead.");
          if (!function t3(e3) {
            if (null === e3)
              return true;
            if ("string" == typeof e3)
              return true;
            if ("boolean" == typeof e3)
              return true;
            if ("number" == typeof e3)
              return true;
            if (e3 instanceof $t)
              return true;
            if (e3 instanceof Wt)
              return true;
            if (e3 instanceof te)
              return true;
            if (e3 instanceof ee)
              return true;
            if (Array.isArray(e3)) {
              for (var r3 = 0, n3 = e3; r3 < n3.length; r3 += 1) {
                if (!t3(n3[r3]))
                  return false;
              }
              return true;
            }
            if ("object" == typeof e3) {
              for (var i3 in e3)
                if (!t3(e3[i3]))
                  return false;
              return true;
            }
            return false;
          }(t2[1]))
            return e2.error("invalid value");
          var r2 = t2[1], n2 = ne(r2), i2 = e2.expectedType;
          return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new ae(n2, r2);
        }, ae.prototype.evaluate = function() {
          return this.value;
        }, ae.prototype.eachChild = function() {
        }, ae.prototype.possibleOutputs = function() {
          return [this.value];
        }, ae.prototype.serialize = function() {
          return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof $t ? ["rgba"].concat(this.value.toArray()) : this.value instanceof te ? this.value.serialize() : this.value;
        };
        var oe = function(t2) {
          this.name = "ExpressionEvaluationError", this.message = t2;
        };
        oe.prototype.toJSON = function() {
          return this.message;
        };
        var se = { string: Dt, number: Ot, boolean: Rt, object: jt }, ue = function(t2, e2) {
          this.type = t2, this.args = e2;
        };
        ue.parse = function(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          var r2, n2 = 1, i2 = t2[0];
          if ("array" === i2) {
            var a2, o2;
            if (t2.length > 2) {
              var s2 = t2[1];
              if ("string" != typeof s2 || !(s2 in se) || "object" === s2)
                return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
              a2 = se[s2], n2++;
            } else
              a2 = qt;
            if (t2.length > 3) {
              if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                return e2.error('The length argument to "array" must be a positive integer literal', 2);
              o2 = t2[2], n2++;
            }
            r2 = Zt(a2, o2);
          } else
            r2 = se[i2];
          for (var u2 = []; n2 < t2.length; n2++) {
            var l2 = e2.parse(t2[n2], n2, qt);
            if (!l2)
              return null;
            u2.push(l2);
          }
          return new ue(r2, u2);
        }, ue.prototype.evaluate = function(t2) {
          for (var e2 = 0; e2 < this.args.length; e2++) {
            var r2 = this.args[e2].evaluate(t2);
            if (!Ht(this.type, ne(r2)))
              return r2;
            if (e2 === this.args.length - 1)
              throw new oe("Expected value to be of type " + Gt(this.type) + ", but found " + Gt(ne(r2)) + " instead.");
          }
          return null;
        }, ue.prototype.eachChild = function(t2) {
          this.args.forEach(t2);
        }, ue.prototype.possibleOutputs = function() {
          var t2;
          return (t2 = []).concat.apply(t2, this.args.map(function(t3) {
            return t3.possibleOutputs();
          }));
        }, ue.prototype.serialize = function() {
          var t2 = this.type, e2 = [t2.kind];
          if ("array" === t2.kind) {
            var r2 = t2.itemType;
            if ("string" === r2.kind || "number" === r2.kind || "boolean" === r2.kind) {
              e2.push(r2.kind);
              var n2 = t2.N;
              ("number" == typeof n2 || this.args.length > 1) && e2.push(n2);
            }
          }
          return e2.concat(this.args.map(function(t3) {
            return t3.serialize();
          }));
        };
        var le = function(t2) {
          this.type = Kt, this.sections = t2;
        };
        le.parse = function(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          var r2 = t2[1];
          if (!Array.isArray(r2) && "object" == typeof r2)
            return e2.error("First argument must be an image or text section.");
          for (var n2 = [], i2 = false, a2 = 1; a2 <= t2.length - 1; ++a2) {
            var o2 = t2[a2];
            if (i2 && "object" == typeof o2 && !Array.isArray(o2)) {
              i2 = false;
              var s2 = null;
              if (o2["font-scale"] && !(s2 = e2.parse(o2["font-scale"], 1, Ot)))
                return null;
              var u2 = null;
              if (o2["text-font"] && !(u2 = e2.parse(o2["text-font"], 1, Zt(Dt))))
                return null;
              var l2 = null;
              if (o2["text-color"] && !(l2 = e2.parse(o2["text-color"], 1, Ut)))
                return null;
              var p2 = n2[n2.length - 1];
              p2.scale = s2, p2.font = u2, p2.textColor = l2;
            } else {
              var c2 = e2.parse(t2[a2], 1, qt);
              if (!c2)
                return null;
              var h2 = c2.type.kind;
              if ("string" !== h2 && "value" !== h2 && "null" !== h2 && "resolvedImage" !== h2)
                return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              i2 = true, n2.push({ content: c2, scale: null, font: null, textColor: null });
            }
          }
          return new le(n2);
        }, le.prototype.evaluate = function(t2) {
          return new te(this.sections.map(function(e2) {
            var r2 = e2.content.evaluate(t2);
            return ne(r2) === Xt ? new Qt("", r2, null, null, null) : new Qt(ie(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
          }));
        }, le.prototype.eachChild = function(t2) {
          for (var e2 = 0, r2 = this.sections; e2 < r2.length; e2 += 1) {
            var n2 = r2[e2];
            t2(n2.content), n2.scale && t2(n2.scale), n2.font && t2(n2.font), n2.textColor && t2(n2.textColor);
          }
        }, le.prototype.possibleOutputs = function() {
          return [void 0];
        }, le.prototype.serialize = function() {
          for (var t2 = ["format"], e2 = 0, r2 = this.sections; e2 < r2.length; e2 += 1) {
            var n2 = r2[e2];
            t2.push(n2.content.serialize());
            var i2 = {};
            n2.scale && (i2["font-scale"] = n2.scale.serialize()), n2.font && (i2["text-font"] = n2.font.serialize()), n2.textColor && (i2["text-color"] = n2.textColor.serialize()), t2.push(i2);
          }
          return t2;
        };
        var pe = function(t2) {
          this.type = Xt, this.input = t2;
        };
        pe.parse = function(t2, e2) {
          if (2 !== t2.length)
            return e2.error("Expected two arguments.");
          var r2 = e2.parse(t2[1], 1, Dt);
          return r2 ? new pe(r2) : e2.error("No image name provided.");
        }, pe.prototype.evaluate = function(t2) {
          var e2 = this.input.evaluate(t2), r2 = false;
          return t2.availableImages && t2.availableImages.indexOf(e2) > -1 && (r2 = true), new ee({ name: e2, available: r2 });
        }, pe.prototype.eachChild = function(t2) {
          t2(this.input);
        }, pe.prototype.possibleOutputs = function() {
          return [void 0];
        }, pe.prototype.serialize = function() {
          return ["image", this.input.serialize()];
        };
        var ce = { "to-boolean": Rt, "to-color": Ut, "to-number": Ot, "to-string": Dt }, he = function(t2, e2) {
          this.type = t2, this.args = e2;
        };
        he.parse = function(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          var r2 = t2[0];
          if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length)
            return e2.error("Expected one argument.");
          for (var n2 = ce[r2], i2 = [], a2 = 1; a2 < t2.length; a2++) {
            var o2 = e2.parse(t2[a2], a2, qt);
            if (!o2)
              return null;
            i2.push(o2);
          }
          return new he(n2, i2);
        }, he.prototype.evaluate = function(t2) {
          if ("boolean" === this.type.kind)
            return Boolean(this.args[0].evaluate(t2));
          if ("color" === this.type.kind) {
            for (var e2, r2, n2 = 0, i2 = this.args; n2 < i2.length; n2 += 1) {
              if (r2 = null, (e2 = i2[n2].evaluate(t2)) instanceof $t)
                return e2;
              if ("string" == typeof e2) {
                var a2 = t2.parseColor(e2);
                if (a2)
                  return a2;
              } else if (Array.isArray(e2) && !(r2 = e2.length < 3 || e2.length > 4 ? "Invalid rbga value " + JSON.stringify(e2) + ": expected an array containing either three or four numeric values." : re(e2[0], e2[1], e2[2], e2[3])))
                return new $t(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
            }
            throw new oe(r2 || "Could not parse color from value '" + ("string" == typeof e2 ? e2 : String(JSON.stringify(e2))) + "'");
          }
          if ("number" === this.type.kind) {
            for (var o2 = null, s2 = 0, u2 = this.args; s2 < u2.length; s2 += 1) {
              if (null === (o2 = u2[s2].evaluate(t2)))
                return 0;
              var l2 = Number(o2);
              if (!isNaN(l2))
                return l2;
            }
            throw new oe("Could not convert " + JSON.stringify(o2) + " to number.");
          }
          return "formatted" === this.type.kind ? te.fromString(ie(this.args[0].evaluate(t2))) : "resolvedImage" === this.type.kind ? ee.fromString(ie(this.args[0].evaluate(t2))) : ie(this.args[0].evaluate(t2));
        }, he.prototype.eachChild = function(t2) {
          this.args.forEach(t2);
        }, he.prototype.possibleOutputs = function() {
          var t2;
          return (t2 = []).concat.apply(t2, this.args.map(function(t3) {
            return t3.possibleOutputs();
          }));
        }, he.prototype.serialize = function() {
          if ("formatted" === this.type.kind)
            return new le([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if ("resolvedImage" === this.type.kind)
            return new pe(this.args[0]).serialize();
          var t2 = ["to-" + this.type.kind];
          return this.eachChild(function(e2) {
            t2.push(e2.serialize());
          }), t2;
        };
        var fe = ["Unknown", "Point", "LineString", "Polygon"], ye = function() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null;
        };
        ye.prototype.id = function() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }, ye.prototype.geometryType = function() {
          return this.feature ? "number" == typeof this.feature.type ? fe[this.feature.type] : this.feature.type : null;
        }, ye.prototype.properties = function() {
          return this.feature && this.feature.properties || {};
        }, ye.prototype.parseColor = function(t2) {
          var e2 = this._parseColorCache[t2];
          return e2 || (e2 = this._parseColorCache[t2] = $t.parse(t2)), e2;
        };
        var de = function(t2, e2, r2, n2) {
          this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
        };
        de.prototype.evaluate = function(t2) {
          return this._evaluate(t2, this.args);
        }, de.prototype.eachChild = function(t2) {
          this.args.forEach(t2);
        }, de.prototype.possibleOutputs = function() {
          return [void 0];
        }, de.prototype.serialize = function() {
          return [this.name].concat(this.args.map(function(t2) {
            return t2.serialize();
          }));
        }, de.parse = function(t2, e2) {
          var r2, n2 = t2[0], i2 = de.definitions[n2];
          if (!i2)
            return e2.error('Unknown expression "' + n2 + '". If you wanted a literal array, use ["literal", [...]].', 0);
          for (var a2 = Array.isArray(i2) ? i2[0] : i2.type, o2 = Array.isArray(i2) ? [[i2[1], i2[2]]] : i2.overloads, s2 = o2.filter(function(e3) {
            var r3 = e3[0];
            return !Array.isArray(r3) || r3.length === t2.length - 1;
          }), u2 = null, l2 = 0, p2 = s2; l2 < p2.length; l2 += 1) {
            var c2 = p2[l2], h2 = c2[0], f2 = c2[1];
            u2 = new _e(e2.registry, e2.path, null, e2.scope);
            for (var y2 = [], d2 = false, m2 = 1; m2 < t2.length; m2++) {
              var v2 = t2[m2], g2 = Array.isArray(h2) ? h2[m2 - 1] : h2.type, x2 = u2.parse(v2, 1 + y2.length, g2);
              if (!x2) {
                d2 = true;
                break;
              }
              y2.push(x2);
            }
            if (!d2)
              if (Array.isArray(h2) && h2.length !== y2.length)
                u2.error("Expected " + h2.length + " arguments, but found " + y2.length + " instead.");
              else {
                for (var b2 = 0; b2 < y2.length; b2++) {
                  var _2 = Array.isArray(h2) ? h2[b2] : h2.type, w2 = y2[b2];
                  u2.concat(b2 + 1).checkSubtype(_2, w2.type);
                }
                if (0 === u2.errors.length)
                  return new de(n2, a2, f2, y2);
              }
          }
          if (1 === s2.length)
            (r2 = e2.errors).push.apply(r2, u2.errors);
          else {
            for (var A2 = (s2.length ? s2 : o2).map(function(t3) {
              var e3, r3 = t3[0];
              return e3 = r3, Array.isArray(e3) ? "(" + e3.map(Gt).join(", ") + ")" : "(" + Gt(e3.type) + "...)";
            }).join(" | "), S2 = [], k2 = 1; k2 < t2.length; k2++) {
              var I2 = e2.parse(t2[k2], 1 + S2.length);
              if (!I2)
                return null;
              S2.push(Gt(I2.type));
            }
            e2.error("Expected arguments of type " + A2 + ", but found (" + S2.join(", ") + ") instead.");
          }
          return null;
        }, de.register = function(t2, e2) {
          for (var r2 in de.definitions = e2, e2)
            t2[r2] = de;
        };
        var me = function(t2, e2, r2) {
          this.type = Nt, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
        };
        function ve(t2) {
          if (t2 instanceof de) {
            if ("get" === t2.name && 1 === t2.args.length)
              return false;
            if ("feature-state" === t2.name)
              return false;
            if ("has" === t2.name && 1 === t2.args.length)
              return false;
            if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name)
              return false;
            if (/^filter-/.test(t2.name))
              return false;
          }
          var e2 = true;
          return t2.eachChild(function(t3) {
            e2 && !ve(t3) && (e2 = false);
          }), e2;
        }
        function ge(t2) {
          if (t2 instanceof de && "feature-state" === t2.name)
            return false;
          var e2 = true;
          return t2.eachChild(function(t3) {
            e2 && !ge(t3) && (e2 = false);
          }), e2;
        }
        function xe(t2, e2) {
          if (t2 instanceof de && e2.indexOf(t2.name) >= 0)
            return false;
          var r2 = true;
          return t2.eachChild(function(t3) {
            r2 && !xe(t3, e2) && (r2 = false);
          }), r2;
        }
        me.parse = function(t2, e2) {
          if (2 !== t2.length)
            return e2.error("Expected one argument.");
          var r2 = t2[1];
          if ("object" != typeof r2 || Array.isArray(r2))
            return e2.error("Collator options argument must be an object.");
          var n2 = e2.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, Rt);
          if (!n2)
            return null;
          var i2 = e2.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, Rt);
          if (!i2)
            return null;
          var a2 = null;
          return r2.locale && !(a2 = e2.parse(r2.locale, 1, Dt)) ? null : new me(n2, i2, a2);
        }, me.prototype.evaluate = function(t2) {
          return new Wt(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
        }, me.prototype.eachChild = function(t2) {
          t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
        }, me.prototype.possibleOutputs = function() {
          return [void 0];
        }, me.prototype.serialize = function() {
          var t2 = {};
          return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
        };
        var be = function(t2, e2) {
          this.type = e2.type, this.name = t2, this.boundExpression = e2;
        };
        be.parse = function(t2, e2) {
          if (2 !== t2.length || "string" != typeof t2[1])
            return e2.error("'var' expression requires exactly one string literal argument.");
          var r2 = t2[1];
          return e2.scope.has(r2) ? new be(r2, e2.scope.get(r2)) : e2.error('Unknown variable "' + r2 + '". Make sure "' + r2 + '" has been bound in an enclosing "let" expression before using it.', 1);
        }, be.prototype.evaluate = function(t2) {
          return this.boundExpression.evaluate(t2);
        }, be.prototype.eachChild = function() {
        }, be.prototype.possibleOutputs = function() {
          return [void 0];
        }, be.prototype.serialize = function() {
          return ["var", this.name];
        };
        var _e = function(t2, e2, r2, n2, i2) {
          void 0 === e2 && (e2 = []), void 0 === n2 && (n2 = new Ft()), void 0 === i2 && (i2 = []), this.registry = t2, this.path = e2, this.key = e2.map(function(t3) {
            return "[" + t3 + "]";
          }).join(""), this.scope = n2, this.errors = i2, this.expectedType = r2;
        };
        function we(t2, e2) {
          for (var r2, n2, i2 = t2.length - 1, a2 = 0, o2 = i2, s2 = 0; a2 <= o2; )
            if (r2 = t2[s2 = Math.floor((a2 + o2) / 2)], n2 = t2[s2 + 1], r2 <= e2) {
              if (s2 === i2 || e2 < n2)
                return s2;
              a2 = s2 + 1;
            } else {
              if (!(r2 > e2))
                throw new oe("Input is not a number.");
              o2 = s2 - 1;
            }
          return 0;
        }
        _e.prototype.parse = function(t2, e2, r2, n2, i2) {
          return void 0 === i2 && (i2 = {}), e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
        }, _e.prototype._parse = function(t2, e2) {
          function r2(t3, e3, r3) {
            return "assert" === r3 ? new ue(e3, [t3]) : "coerce" === r3 ? new he(e3, [t3]) : t3;
          }
          if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
            if (0 === t2.length)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            var n2 = t2[0];
            if ("string" != typeof n2)
              return this.error("Expression name must be a string, but found " + typeof n2 + ' instead. If you wanted a literal array, use ["literal", [...]].', 0), null;
            var i2 = this.registry[n2];
            if (i2) {
              var a2 = i2.parse(t2, this);
              if (!a2)
                return null;
              if (this.expectedType) {
                var o2 = this.expectedType, s2 = a2.type;
                if ("string" !== o2.kind && "number" !== o2.kind && "boolean" !== o2.kind && "object" !== o2.kind && "array" !== o2.kind || "value" !== s2.kind)
                  if ("color" !== o2.kind && "formatted" !== o2.kind && "resolvedImage" !== o2.kind || "value" !== s2.kind && "string" !== s2.kind) {
                    if (this.checkSubtype(o2, s2))
                      return null;
                  } else
                    a2 = r2(a2, o2, e2.typeAnnotation || "coerce");
                else
                  a2 = r2(a2, o2, e2.typeAnnotation || "assert");
              }
              if (!(a2 instanceof ae) && "resolvedImage" !== a2.type.kind && function t3(e3) {
                if (e3 instanceof be)
                  return t3(e3.boundExpression);
                if (e3 instanceof de && "error" === e3.name)
                  return false;
                if (e3 instanceof me)
                  return false;
                var r3 = e3 instanceof he || e3 instanceof ue, n3 = true;
                if (e3.eachChild(function(e4) {
                  n3 = r3 ? n3 && t3(e4) : n3 && e4 instanceof ae;
                }), !n3)
                  return false;
                return ve(e3) && xe(e3, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
              }(a2)) {
                var u2 = new ye();
                try {
                  a2 = new ae(a2.type, a2.evaluate(u2));
                } catch (t3) {
                  return this.error(t3.message), null;
                }
              }
              return a2;
            }
            return this.error('Unknown expression "' + n2 + '". If you wanted a literal array, use ["literal", [...]].', 0);
          }
          return void 0 === t2 ? this.error("'undefined' value invalid. Use null instead.") : "object" == typeof t2 ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error("Expected an array, but found " + typeof t2 + " instead.");
        }, _e.prototype.concat = function(t2, e2, r2) {
          var n2 = "number" == typeof t2 ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
          return new _e(this.registry, n2, e2 || null, i2, this.errors);
        }, _e.prototype.error = function(t2) {
          for (var e2 = [], r2 = arguments.length - 1; r2-- > 0; )
            e2[r2] = arguments[r2 + 1];
          var n2 = "" + this.key + e2.map(function(t3) {
            return "[" + t3 + "]";
          }).join("");
          this.errors.push(new Vt(n2, t2));
        }, _e.prototype.checkSubtype = function(t2, e2) {
          var r2 = Ht(t2, e2);
          return r2 && this.error(r2), r2;
        };
        var Ae = function(t2, e2, r2) {
          this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
          for (var n2 = 0, i2 = r2; n2 < i2.length; n2 += 1) {
            var a2 = i2[n2], o2 = a2[0], s2 = a2[1];
            this.labels.push(o2), this.outputs.push(s2);
          }
        };
        function Se(t2, e2, r2) {
          return t2 * (1 - r2) + e2 * r2;
        }
        Ae.parse = function(t2, e2) {
          if (t2.length - 1 < 4)
            return e2.error("Expected at least 4 arguments, but found only " + (t2.length - 1) + ".");
          if ((t2.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          var r2 = e2.parse(t2[1], 1, Ot);
          if (!r2)
            return null;
          var n2 = [], i2 = null;
          e2.expectedType && "value" !== e2.expectedType.kind && (i2 = e2.expectedType);
          for (var a2 = 1; a2 < t2.length; a2 += 2) {
            var o2 = 1 === a2 ? -1 / 0 : t2[a2], s2 = t2[a2 + 1], u2 = a2, l2 = a2 + 1;
            if ("number" != typeof o2)
              return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u2);
            if (n2.length && n2[n2.length - 1][0] >= o2)
              return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', u2);
            var p2 = e2.parse(s2, l2, i2);
            if (!p2)
              return null;
            i2 = i2 || p2.type, n2.push([o2, p2]);
          }
          return new Ae(i2, r2, n2);
        }, Ae.prototype.evaluate = function(t2) {
          var e2 = this.labels, r2 = this.outputs;
          if (1 === e2.length)
            return r2[0].evaluate(t2);
          var n2 = this.input.evaluate(t2);
          if (n2 <= e2[0])
            return r2[0].evaluate(t2);
          var i2 = e2.length;
          return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[we(e2, n2)].evaluate(t2);
        }, Ae.prototype.eachChild = function(t2) {
          t2(this.input);
          for (var e2 = 0, r2 = this.outputs; e2 < r2.length; e2 += 1) {
            t2(r2[e2]);
          }
        }, Ae.prototype.possibleOutputs = function() {
          var t2;
          return (t2 = []).concat.apply(t2, this.outputs.map(function(t3) {
            return t3.possibleOutputs();
          }));
        }, Ae.prototype.serialize = function() {
          for (var t2 = ["step", this.input.serialize()], e2 = 0; e2 < this.labels.length; e2++)
            e2 > 0 && t2.push(this.labels[e2]), t2.push(this.outputs[e2].serialize());
          return t2;
        };
        var ke = Object.freeze({ __proto__: null, number: Se, color: function(t2, e2, r2) {
          return new $t(Se(t2.r, e2.r, r2), Se(t2.g, e2.g, r2), Se(t2.b, e2.b, r2), Se(t2.a, e2.a, r2));
        }, array: function(t2, e2, r2) {
          return t2.map(function(t3, n2) {
            return Se(t3, e2[n2], r2);
          });
        } }), Ie = 6 / 29, ze = 3 * Ie * Ie, Ce = Math.PI / 180, Be = 180 / Math.PI;
        function Pe(t2) {
          return t2 > 0.008856451679035631 ? Math.pow(t2, 1 / 3) : t2 / ze + 4 / 29;
        }
        function Te(t2) {
          return t2 > Ie ? t2 * t2 * t2 : ze * (t2 - 4 / 29);
        }
        function Ee(t2) {
          return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
        }
        function Me(t2) {
          return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
        }
        function Ve(t2) {
          var e2 = Me(t2.r), r2 = Me(t2.g), n2 = Me(t2.b), i2 = Pe((0.4124564 * e2 + 0.3575761 * r2 + 0.1804375 * n2) / 0.95047), a2 = Pe((0.2126729 * e2 + 0.7151522 * r2 + 0.072175 * n2) / 1);
          return { l: 116 * a2 - 16, a: 500 * (i2 - a2), b: 200 * (a2 - Pe((0.0193339 * e2 + 0.119192 * r2 + 0.9503041 * n2) / 1.08883)), alpha: t2.a };
        }
        function Fe(t2) {
          var e2 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e2 : e2 + t2.a / 500, n2 = isNaN(t2.b) ? e2 : e2 - t2.b / 200;
          return e2 = 1 * Te(e2), r2 = 0.95047 * Te(r2), n2 = 1.08883 * Te(n2), new $t(Ee(3.2404542 * r2 - 1.5371385 * e2 - 0.4985314 * n2), Ee(-0.969266 * r2 + 1.8760108 * e2 + 0.041556 * n2), Ee(0.0556434 * r2 - 0.2040259 * e2 + 1.0572252 * n2), t2.alpha);
        }
        function Le(t2, e2, r2) {
          var n2 = e2 - t2;
          return t2 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
        }
        var Oe = { forward: Ve, reverse: Fe, interpolate: function(t2, e2, r2) {
          return { l: Se(t2.l, e2.l, r2), a: Se(t2.a, e2.a, r2), b: Se(t2.b, e2.b, r2), alpha: Se(t2.alpha, e2.alpha, r2) };
        } }, De = { forward: function(t2) {
          var e2 = Ve(t2), r2 = e2.l, n2 = e2.a, i2 = e2.b, a2 = Math.atan2(i2, n2) * Be;
          return { h: a2 < 0 ? a2 + 360 : a2, c: Math.sqrt(n2 * n2 + i2 * i2), l: r2, alpha: t2.a };
        }, reverse: function(t2) {
          var e2 = t2.h * Ce, r2 = t2.c;
          return Fe({ l: t2.l, a: Math.cos(e2) * r2, b: Math.sin(e2) * r2, alpha: t2.alpha });
        }, interpolate: function(t2, e2, r2) {
          return { h: Le(t2.h, e2.h, r2), c: Se(t2.c, e2.c, r2), l: Se(t2.l, e2.l, r2), alpha: Se(t2.alpha, e2.alpha, r2) };
        } }, Re = Object.freeze({ __proto__: null, lab: Oe, hcl: De }), Ue = function(t2, e2, r2, n2, i2) {
          this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
          for (var a2 = 0, o2 = i2; a2 < o2.length; a2 += 1) {
            var s2 = o2[a2], u2 = s2[0], l2 = s2[1];
            this.labels.push(u2), this.outputs.push(l2);
          }
        };
        function je(t2, e2, r2, n2) {
          var i2 = n2 - r2, a2 = t2 - r2;
          return 0 === i2 ? 0 : 1 === e2 ? a2 / i2 : (Math.pow(e2, a2) - 1) / (Math.pow(e2, i2) - 1);
        }
        Ue.interpolationFactor = function(t2, e2, n2, i2) {
          var a2 = 0;
          if ("exponential" === t2.name)
            a2 = je(e2, t2.base, n2, i2);
          else if ("linear" === t2.name)
            a2 = je(e2, 1, n2, i2);
          else if ("cubic-bezier" === t2.name) {
            var o2 = t2.controlPoints;
            a2 = new r(o2[0], o2[1], o2[2], o2[3]).solve(je(e2, 1, n2, i2));
          }
          return a2;
        }, Ue.parse = function(t2, e2) {
          var r2 = t2[0], n2 = t2[1], i2 = t2[2], a2 = t2.slice(3);
          if (!Array.isArray(n2) || 0 === n2.length)
            return e2.error("Expected an interpolation type expression.", 1);
          if ("linear" === n2[0])
            n2 = { name: "linear" };
          else if ("exponential" === n2[0]) {
            var o2 = n2[1];
            if ("number" != typeof o2)
              return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
            n2 = { name: "exponential", base: o2 };
          } else {
            if ("cubic-bezier" !== n2[0])
              return e2.error("Unknown interpolation type " + String(n2[0]), 1, 0);
            var s2 = n2.slice(1);
            if (4 !== s2.length || s2.some(function(t3) {
              return "number" != typeof t3 || t3 < 0 || t3 > 1;
            }))
              return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
            n2 = { name: "cubic-bezier", controlPoints: s2 };
          }
          if (t2.length - 1 < 4)
            return e2.error("Expected at least 4 arguments, but found only " + (t2.length - 1) + ".");
          if ((t2.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          if (!(i2 = e2.parse(i2, 2, Ot)))
            return null;
          var u2 = [], l2 = null;
          "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? l2 = Ut : e2.expectedType && "value" !== e2.expectedType.kind && (l2 = e2.expectedType);
          for (var p2 = 0; p2 < a2.length; p2 += 2) {
            var c2 = a2[p2], h2 = a2[p2 + 1], f2 = p2 + 3, y2 = p2 + 4;
            if ("number" != typeof c2)
              return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', f2);
            if (u2.length && u2[u2.length - 1][0] >= c2)
              return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', f2);
            var d2 = e2.parse(h2, y2, l2);
            if (!d2)
              return null;
            l2 = l2 || d2.type, u2.push([c2, d2]);
          }
          return "number" === l2.kind || "color" === l2.kind || "array" === l2.kind && "number" === l2.itemType.kind && "number" == typeof l2.N ? new Ue(l2, r2, n2, i2, u2) : e2.error("Type " + Gt(l2) + " is not interpolatable.");
        }, Ue.prototype.evaluate = function(t2) {
          var e2 = this.labels, r2 = this.outputs;
          if (1 === e2.length)
            return r2[0].evaluate(t2);
          var n2 = this.input.evaluate(t2);
          if (n2 <= e2[0])
            return r2[0].evaluate(t2);
          var i2 = e2.length;
          if (n2 >= e2[i2 - 1])
            return r2[i2 - 1].evaluate(t2);
          var a2 = we(e2, n2), o2 = e2[a2], s2 = e2[a2 + 1], u2 = Ue.interpolationFactor(this.interpolation, n2, o2, s2), l2 = r2[a2].evaluate(t2), p2 = r2[a2 + 1].evaluate(t2);
          return "interpolate" === this.operator ? ke[this.type.kind.toLowerCase()](l2, p2, u2) : "interpolate-hcl" === this.operator ? De.reverse(De.interpolate(De.forward(l2), De.forward(p2), u2)) : Oe.reverse(Oe.interpolate(Oe.forward(l2), Oe.forward(p2), u2));
        }, Ue.prototype.eachChild = function(t2) {
          t2(this.input);
          for (var e2 = 0, r2 = this.outputs; e2 < r2.length; e2 += 1) {
            t2(r2[e2]);
          }
        }, Ue.prototype.possibleOutputs = function() {
          var t2;
          return (t2 = []).concat.apply(t2, this.outputs.map(function(t3) {
            return t3.possibleOutputs();
          }));
        }, Ue.prototype.serialize = function() {
          var t2;
          t2 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
          for (var e2 = [this.operator, t2, this.input.serialize()], r2 = 0; r2 < this.labels.length; r2++)
            e2.push(this.labels[r2], this.outputs[r2].serialize());
          return e2;
        };
        var qe = function(t2, e2) {
          this.type = t2, this.args = e2;
        };
        qe.parse = function(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expectected at least one argument.");
          var r2 = null, n2 = e2.expectedType;
          n2 && "value" !== n2.kind && (r2 = n2);
          for (var i2 = [], a2 = 0, o2 = t2.slice(1); a2 < o2.length; a2 += 1) {
            var s2 = o2[a2], u2 = e2.parse(s2, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
            if (!u2)
              return null;
            r2 = r2 || u2.type, i2.push(u2);
          }
          var l2 = n2 && i2.some(function(t3) {
            return Ht(n2, t3.type);
          });
          return new qe(l2 ? qt : r2, i2);
        }, qe.prototype.evaluate = function(t2) {
          for (var e2, r2 = null, n2 = 0, i2 = 0, a2 = this.args; i2 < a2.length; i2 += 1) {
            if (n2++, (r2 = a2[i2].evaluate(t2)) && r2 instanceof ee && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), null !== r2)
              break;
          }
          return r2;
        }, qe.prototype.eachChild = function(t2) {
          this.args.forEach(t2);
        }, qe.prototype.possibleOutputs = function() {
          var t2;
          return (t2 = []).concat.apply(t2, this.args.map(function(t3) {
            return t3.possibleOutputs();
          }));
        }, qe.prototype.serialize = function() {
          var t2 = ["coalesce"];
          return this.eachChild(function(e2) {
            t2.push(e2.serialize());
          }), t2;
        };
        var Ne = function(t2, e2) {
          this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
        };
        Ne.prototype.evaluate = function(t2) {
          return this.result.evaluate(t2);
        }, Ne.prototype.eachChild = function(t2) {
          for (var e2 = 0, r2 = this.bindings; e2 < r2.length; e2 += 1) {
            t2(r2[e2][1]);
          }
          t2(this.result);
        }, Ne.parse = function(t2, e2) {
          if (t2.length < 4)
            return e2.error("Expected at least 3 arguments, but found " + (t2.length - 1) + " instead.");
          for (var r2 = [], n2 = 1; n2 < t2.length - 1; n2 += 2) {
            var i2 = t2[n2];
            if ("string" != typeof i2)
              return e2.error("Expected string, but found " + typeof i2 + " instead.", n2);
            if (/[^a-zA-Z0-9_]/.test(i2))
              return e2.error("Variable names must contain only alphanumeric characters or '_'.", n2);
            var a2 = e2.parse(t2[n2 + 1], n2 + 1);
            if (!a2)
              return null;
            r2.push([i2, a2]);
          }
          var o2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
          return o2 ? new Ne(r2, o2) : null;
        }, Ne.prototype.possibleOutputs = function() {
          return this.result.possibleOutputs();
        }, Ne.prototype.serialize = function() {
          for (var t2 = ["let"], e2 = 0, r2 = this.bindings; e2 < r2.length; e2 += 1) {
            var n2 = r2[e2], i2 = n2[0], a2 = n2[1];
            t2.push(i2, a2.serialize());
          }
          return t2.push(this.result.serialize()), t2;
        };
        var Ke = function(t2, e2, r2) {
          this.type = t2, this.index = e2, this.input = r2;
        };
        Ke.parse = function(t2, e2) {
          if (3 !== t2.length)
            return e2.error("Expected 2 arguments, but found " + (t2.length - 1) + " instead.");
          var r2 = e2.parse(t2[1], 1, Ot), n2 = e2.parse(t2[2], 2, Zt(e2.expectedType || qt));
          if (!r2 || !n2)
            return null;
          var i2 = n2.type;
          return new Ke(i2.itemType, r2, n2);
        }, Ke.prototype.evaluate = function(t2) {
          var e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
          if (e2 < 0)
            throw new oe("Array index out of bounds: " + e2 + " < 0.");
          if (e2 >= r2.length)
            throw new oe("Array index out of bounds: " + e2 + " > " + (r2.length - 1) + ".");
          if (e2 !== Math.floor(e2))
            throw new oe("Array index must be an integer, but found " + e2 + " instead.");
          return r2[e2];
        }, Ke.prototype.eachChild = function(t2) {
          t2(this.index), t2(this.input);
        }, Ke.prototype.possibleOutputs = function() {
          return [void 0];
        }, Ke.prototype.serialize = function() {
          return ["at", this.index.serialize(), this.input.serialize()];
        };
        var Xe = function(t2, e2) {
          this.type = Rt, this.needle = t2, this.haystack = e2;
        };
        Xe.parse = function(t2, e2) {
          if (3 !== t2.length)
            return e2.error("Expected 2 arguments, but found " + (t2.length - 1) + " instead.");
          var r2, n2 = e2.parse(t2[1], 1, qt), i2 = e2.parse(t2[2], 2, qt);
          return n2 && i2 ? "boolean" !== (r2 = n2.type).kind && "string" !== r2.kind && "number" !== r2.kind && "null" !== r2.kind && "value" !== r2.kind ? e2.error("Expected first argument to be of type boolean, string, number or null, but found " + Gt(n2.type) + " instead") : new Xe(n2, i2) : null;
        }, Xe.prototype.evaluate = function(t2) {
          var e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
          if (!e2 || !r2)
            return false;
          if (!/* @__PURE__ */ function(t3) {
            return "boolean" == typeof t3 || "string" == typeof t3 || "number" == typeof t3;
          }(e2))
            throw new oe("Expected first argument to be of type boolean, string or number, but found " + Gt(ne(e2)) + " instead.");
          if (!function(t3) {
            return Array.isArray(t3) || "string" == typeof t3;
          }(r2))
            throw new oe("Expected second argument to be of type array or string, but found " + Gt(ne(r2)) + " instead.");
          return r2.indexOf(e2) >= 0;
        }, Xe.prototype.eachChild = function(t2) {
          t2(this.needle), t2(this.haystack);
        }, Xe.prototype.possibleOutputs = function() {
          return [true, false];
        }, Xe.prototype.serialize = function() {
          return ["in", this.needle.serialize(), this.haystack.serialize()];
        };
        var Ze = function(t2, e2, r2, n2, i2, a2) {
          this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = a2;
        };
        Ze.parse = function(t2, e2) {
          if (t2.length < 5)
            return e2.error("Expected at least 4 arguments, but found only " + (t2.length - 1) + ".");
          if (t2.length % 2 != 1)
            return e2.error("Expected an even number of arguments.");
          var r2, n2;
          e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
          for (var i2 = {}, a2 = [], o2 = 2; o2 < t2.length - 1; o2 += 2) {
            var s2 = t2[o2], u2 = t2[o2 + 1];
            Array.isArray(s2) || (s2 = [s2]);
            var l2 = e2.concat(o2);
            if (0 === s2.length)
              return l2.error("Expected at least one branch label.");
            for (var p2 = 0, c2 = s2; p2 < c2.length; p2 += 1) {
              var h2 = c2[p2];
              if ("number" != typeof h2 && "string" != typeof h2)
                return l2.error("Branch labels must be numbers or strings.");
              if ("number" == typeof h2 && Math.abs(h2) > Number.MAX_SAFE_INTEGER)
                return l2.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
              if ("number" == typeof h2 && Math.floor(h2) !== h2)
                return l2.error("Numeric branch labels must be integer values.");
              if (r2) {
                if (l2.checkSubtype(r2, ne(h2)))
                  return null;
              } else
                r2 = ne(h2);
              if (void 0 !== i2[String(h2)])
                return l2.error("Branch labels must be unique.");
              i2[String(h2)] = a2.length;
            }
            var f2 = e2.parse(u2, o2, n2);
            if (!f2)
              return null;
            n2 = n2 || f2.type, a2.push(f2);
          }
          var y2 = e2.parse(t2[1], 1, qt);
          if (!y2)
            return null;
          var d2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
          return d2 ? "value" !== y2.type.kind && e2.concat(1).checkSubtype(r2, y2.type) ? null : new Ze(r2, n2, y2, i2, a2, d2) : null;
        }, Ze.prototype.evaluate = function(t2) {
          var e2 = this.input.evaluate(t2);
          return (ne(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
        }, Ze.prototype.eachChild = function(t2) {
          t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
        }, Ze.prototype.possibleOutputs = function() {
          var t2;
          return (t2 = []).concat.apply(t2, this.outputs.map(function(t3) {
            return t3.possibleOutputs();
          })).concat(this.otherwise.possibleOutputs());
        }, Ze.prototype.serialize = function() {
          for (var t2 = this, e2 = ["match", this.input.serialize()], r2 = [], n2 = {}, i2 = 0, a2 = Object.keys(this.cases).sort(); i2 < a2.length; i2 += 1) {
            var o2 = a2[i2];
            void 0 === (c2 = n2[this.cases[o2]]) ? (n2[this.cases[o2]] = r2.length, r2.push([this.cases[o2], [o2]])) : r2[c2][1].push(o2);
          }
          for (var s2 = function(e3) {
            return "number" === t2.inputType.kind ? Number(e3) : e3;
          }, u2 = 0, l2 = r2; u2 < l2.length; u2 += 1) {
            var p2 = l2[u2], c2 = p2[0], h2 = p2[1];
            1 === h2.length ? e2.push(s2(h2[0])) : e2.push(h2.map(s2)), e2.push(this.outputs[outputIndex$1].serialize());
          }
          return e2.push(this.otherwise.serialize()), e2;
        };
        var Ge = function(t2, e2, r2) {
          this.type = t2, this.branches = e2, this.otherwise = r2;
        };
        function Je(t2, e2) {
          return "==" === t2 || "!=" === t2 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
        }
        function He(t2, e2, r2, n2) {
          return 0 === n2.compare(e2, r2);
        }
        function Ye(t2, e2, r2) {
          var n2 = "==" !== t2 && "!=" !== t2;
          return function() {
            function i2(t3, e3, r3) {
              this.type = Rt, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
            }
            return i2.parse = function(t3, e3) {
              if (3 !== t3.length && 4 !== t3.length)
                return e3.error("Expected two or three arguments.");
              var r3 = t3[0], a2 = e3.parse(t3[1], 1, qt);
              if (!a2)
                return null;
              if (!Je(r3, a2.type))
                return e3.concat(1).error('"' + r3 + `" comparisons are not supported for type '` + Gt(a2.type) + "'.");
              var o2 = e3.parse(t3[2], 2, qt);
              if (!o2)
                return null;
              if (!Je(r3, o2.type))
                return e3.concat(2).error('"' + r3 + `" comparisons are not supported for type '` + Gt(o2.type) + "'.");
              if (a2.type.kind !== o2.type.kind && "value" !== a2.type.kind && "value" !== o2.type.kind)
                return e3.error("Cannot compare types '" + Gt(a2.type) + "' and '" + Gt(o2.type) + "'.");
              n2 && ("value" === a2.type.kind && "value" !== o2.type.kind ? a2 = new ue(o2.type, [a2]) : "value" !== a2.type.kind && "value" === o2.type.kind && (o2 = new ue(a2.type, [o2])));
              var s2 = null;
              if (4 === t3.length) {
                if ("string" !== a2.type.kind && "string" !== o2.type.kind && "value" !== a2.type.kind && "value" !== o2.type.kind)
                  return e3.error("Cannot use collator to compare non-string types.");
                if (!(s2 = e3.parse(t3[3], 3, Nt)))
                  return null;
              }
              return new i2(a2, o2, s2);
            }, i2.prototype.evaluate = function(i3) {
              var a2 = this.lhs.evaluate(i3), o2 = this.rhs.evaluate(i3);
              if (n2 && this.hasUntypedArgument) {
                var s2 = ne(a2), u2 = ne(o2);
                if (s2.kind !== u2.kind || "string" !== s2.kind && "number" !== s2.kind)
                  throw new oe('Expected arguments for "' + t2 + '" to be (string, string) or (number, number), but found (' + s2.kind + ", " + u2.kind + ") instead.");
              }
              if (this.collator && !n2 && this.hasUntypedArgument) {
                var l2 = ne(a2), p2 = ne(o2);
                if ("string" !== l2.kind || "string" !== p2.kind)
                  return e2(i3, a2, o2);
              }
              return this.collator ? r2(i3, a2, o2, this.collator.evaluate(i3)) : e2(i3, a2, o2);
            }, i2.prototype.eachChild = function(t3) {
              t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
            }, i2.prototype.possibleOutputs = function() {
              return [true, false];
            }, i2.prototype.serialize = function() {
              var e3 = [t2];
              return this.eachChild(function(t3) {
                e3.push(t3.serialize());
              }), e3;
            }, i2;
          }();
        }
        Ge.parse = function(t2, e2) {
          if (t2.length < 4)
            return e2.error("Expected at least 3 arguments, but found only " + (t2.length - 1) + ".");
          if (t2.length % 2 != 0)
            return e2.error("Expected an odd number of arguments.");
          var r2;
          e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
          for (var n2 = [], i2 = 1; i2 < t2.length - 1; i2 += 2) {
            var a2 = e2.parse(t2[i2], i2, Rt);
            if (!a2)
              return null;
            var o2 = e2.parse(t2[i2 + 1], i2 + 1, r2);
            if (!o2)
              return null;
            n2.push([a2, o2]), r2 = r2 || o2.type;
          }
          var s2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
          return s2 ? new Ge(r2, n2, s2) : null;
        }, Ge.prototype.evaluate = function(t2) {
          for (var e2 = 0, r2 = this.branches; e2 < r2.length; e2 += 1) {
            var n2 = r2[e2], i2 = n2[0], a2 = n2[1];
            if (i2.evaluate(t2))
              return a2.evaluate(t2);
          }
          return this.otherwise.evaluate(t2);
        }, Ge.prototype.eachChild = function(t2) {
          for (var e2 = 0, r2 = this.branches; e2 < r2.length; e2 += 1) {
            var n2 = r2[e2], i2 = n2[0], a2 = n2[1];
            t2(i2), t2(a2);
          }
          t2(this.otherwise);
        }, Ge.prototype.possibleOutputs = function() {
          var t2;
          return (t2 = []).concat.apply(t2, this.branches.map(function(t3) {
            t3[0];
            return t3[1].possibleOutputs();
          })).concat(this.otherwise.possibleOutputs());
        }, Ge.prototype.serialize = function() {
          var t2 = ["case"];
          return this.eachChild(function(e2) {
            t2.push(e2.serialize());
          }), t2;
        };
        var $e = Ye("==", function(t2, e2, r2) {
          return e2 === r2;
        }, He), We = Ye("!=", function(t2, e2, r2) {
          return e2 !== r2;
        }, function(t2, e2, r2, n2) {
          return !He(0, e2, r2, n2);
        }), Qe = Ye("<", function(t2, e2, r2) {
          return e2 < r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) < 0;
        }), tr = Ye(">", function(t2, e2, r2) {
          return e2 > r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) > 0;
        }), er = Ye("<=", function(t2, e2, r2) {
          return e2 <= r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) <= 0;
        }), rr = Ye(">=", function(t2, e2, r2) {
          return e2 >= r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) >= 0;
        }), nr = function(t2, e2, r2, n2, i2) {
          this.type = Dt, this.number = t2, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
        };
        nr.parse = function(t2, e2) {
          if (3 !== t2.length)
            return e2.error("Expected two arguments.");
          var r2 = e2.parse(t2[1], 1, Ot);
          if (!r2)
            return null;
          var n2 = t2[2];
          if ("object" != typeof n2 || Array.isArray(n2))
            return e2.error("NumberFormat options argument must be an object.");
          var i2 = null;
          if (n2.locale && !(i2 = e2.parse(n2.locale, 1, Dt)))
            return null;
          var a2 = null;
          if (n2.currency && !(a2 = e2.parse(n2.currency, 1, Dt)))
            return null;
          var o2 = null;
          if (n2["min-fraction-digits"] && !(o2 = e2.parse(n2["min-fraction-digits"], 1, Ot)))
            return null;
          var s2 = null;
          return n2["max-fraction-digits"] && !(s2 = e2.parse(n2["max-fraction-digits"], 1, Ot)) ? null : new nr(r2, i2, a2, o2, s2);
        }, nr.prototype.evaluate = function(t2) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
        }, nr.prototype.eachChild = function(t2) {
          t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
        }, nr.prototype.possibleOutputs = function() {
          return [void 0];
        }, nr.prototype.serialize = function() {
          var t2 = {};
          return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
        };
        var ir = function(t2) {
          this.type = Ot, this.input = t2;
        };
        ir.parse = function(t2, e2) {
          if (2 !== t2.length)
            return e2.error("Expected 1 argument, but found " + (t2.length - 1) + " instead.");
          var r2 = e2.parse(t2[1], 1);
          return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error("Expected argument of type string or array, but found " + Gt(r2.type) + " instead.") : new ir(r2) : null;
        }, ir.prototype.evaluate = function(t2) {
          var e2 = this.input.evaluate(t2);
          if ("string" == typeof e2)
            return e2.length;
          if (Array.isArray(e2))
            return e2.length;
          throw new oe("Expected value to be of type string or array, but found " + Gt(ne(e2)) + " instead.");
        }, ir.prototype.eachChild = function(t2) {
          t2(this.input);
        }, ir.prototype.possibleOutputs = function() {
          return [void 0];
        }, ir.prototype.serialize = function() {
          var t2 = ["length"];
          return this.eachChild(function(e2) {
            t2.push(e2.serialize());
          }), t2;
        };
        var ar = { "==": $e, "!=": We, ">": tr, "<": Qe, ">=": rr, "<=": er, array: ue, at: Ke, boolean: ue, case: Ge, coalesce: qe, collator: me, format: le, image: pe, in: Xe, interpolate: Ue, "interpolate-hcl": Ue, "interpolate-lab": Ue, length: ir, let: Ne, literal: ae, match: Ze, number: ue, "number-format": nr, object: ue, step: Ae, string: ue, "to-boolean": he, "to-color": he, "to-number": he, "to-string": he, var: be };
        function or(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], a2 = e2[3];
          r2 = r2.evaluate(t2), n2 = n2.evaluate(t2), i2 = i2.evaluate(t2);
          var o2 = a2 ? a2.evaluate(t2) : 1, s2 = re(r2, n2, i2, o2);
          if (s2)
            throw new oe(s2);
          return new $t(r2 / 255 * o2, n2 / 255 * o2, i2 / 255 * o2, o2);
        }
        function sr(t2, e2) {
          return t2 in e2;
        }
        function ur(t2, e2) {
          var r2 = e2[t2];
          return void 0 === r2 ? null : r2;
        }
        function lr(t2) {
          return { type: t2 };
        }
        function pr(t2) {
          return { result: "success", value: t2 };
        }
        function cr(t2) {
          return { result: "error", value: t2 };
        }
        function hr(t2) {
          return "data-driven" === t2["property-type"] || "cross-faded-data-driven" === t2["property-type"];
        }
        function fr(t2) {
          return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
        }
        function yr(t2) {
          return !!t2.expression && t2.expression.interpolated;
        }
        function dr(t2) {
          return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
        }
        function mr(t2) {
          return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
        }
        function vr(t2) {
          return t2;
        }
        function gr(t2, e2, r2) {
          return void 0 !== t2 ? t2 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
        }
        function xr(t2, e2, r2, n2, i2) {
          return gr(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
        }
        function br(t2, e2, r2) {
          if ("number" !== dr(r2))
            return gr(t2.default, e2.default);
          var n2 = t2.stops.length;
          if (1 === n2)
            return t2.stops[0][1];
          if (r2 <= t2.stops[0][0])
            return t2.stops[0][1];
          if (r2 >= t2.stops[n2 - 1][0])
            return t2.stops[n2 - 1][1];
          var i2 = we(t2.stops.map(function(t3) {
            return t3[0];
          }), r2);
          return t2.stops[i2][1];
        }
        function _r(t2, e2, r2) {
          var n2 = void 0 !== t2.base ? t2.base : 1;
          if ("number" !== dr(r2))
            return gr(t2.default, e2.default);
          var i2 = t2.stops.length;
          if (1 === i2)
            return t2.stops[0][1];
          if (r2 <= t2.stops[0][0])
            return t2.stops[0][1];
          if (r2 >= t2.stops[i2 - 1][0])
            return t2.stops[i2 - 1][1];
          var a2 = we(t2.stops.map(function(t3) {
            return t3[0];
          }), r2), o2 = function(t3, e3, r3, n3) {
            var i3 = n3 - r3, a3 = t3 - r3;
            return 0 === i3 ? 0 : 1 === e3 ? a3 / i3 : (Math.pow(e3, a3) - 1) / (Math.pow(e3, i3) - 1);
          }(r2, n2, t2.stops[a2][0], t2.stops[a2 + 1][0]), s2 = t2.stops[a2][1], u2 = t2.stops[a2 + 1][1], l2 = ke[e2.type] || vr;
          if (t2.colorSpace && "rgb" !== t2.colorSpace) {
            var p2 = Re[t2.colorSpace];
            l2 = function(t3, e3) {
              return p2.reverse(p2.interpolate(p2.forward(t3), p2.forward(e3), o2));
            };
          }
          return "function" == typeof s2.evaluate ? { evaluate: function() {
            for (var t3 = [], e3 = arguments.length; e3--; )
              t3[e3] = arguments[e3];
            var r3 = s2.evaluate.apply(void 0, t3), n3 = u2.evaluate.apply(void 0, t3);
            if (void 0 !== r3 && void 0 !== n3)
              return l2(r3, n3, o2);
          } } : l2(s2, u2, o2);
        }
        function wr(t2, e2, r2) {
          return "color" === e2.type ? r2 = $t.parse(r2) : "formatted" === e2.type ? r2 = te.fromString(r2.toString()) : "resolvedImage" === e2.type ? r2 = ee.fromString(r2.toString()) : dr(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0), gr(r2, t2.default, e2.default);
        }
        de.register(ar, { error: [{ kind: "error" }, [Dt], function(t2, e2) {
          var r2 = e2[0];
          throw new oe(r2.evaluate(t2));
        }], typeof: [Dt, [qt], function(t2, e2) {
          return Gt(ne(e2[0].evaluate(t2)));
        }], "to-rgba": [Zt(Ot, 4), [Ut], function(t2, e2) {
          return e2[0].evaluate(t2).toArray();
        }], rgb: [Ut, [Ot, Ot, Ot], or], rgba: [Ut, [Ot, Ot, Ot, Ot], or], has: { type: Rt, overloads: [[[Dt], function(t2, e2) {
          return sr(e2[0].evaluate(t2), t2.properties());
        }], [[Dt, jt], function(t2, e2) {
          var r2 = e2[0], n2 = e2[1];
          return sr(r2.evaluate(t2), n2.evaluate(t2));
        }]] }, get: { type: qt, overloads: [[[Dt], function(t2, e2) {
          return ur(e2[0].evaluate(t2), t2.properties());
        }], [[Dt, jt], function(t2, e2) {
          var r2 = e2[0], n2 = e2[1];
          return ur(r2.evaluate(t2), n2.evaluate(t2));
        }]] }, "feature-state": [qt, [Dt], function(t2, e2) {
          return ur(e2[0].evaluate(t2), t2.featureState || {});
        }], properties: [jt, [], function(t2) {
          return t2.properties();
        }], "geometry-type": [Dt, [], function(t2) {
          return t2.geometryType();
        }], id: [qt, [], function(t2) {
          return t2.id();
        }], zoom: [Ot, [], function(t2) {
          return t2.globals.zoom;
        }], "heatmap-density": [Ot, [], function(t2) {
          return t2.globals.heatmapDensity || 0;
        }], "line-progress": [Ot, [], function(t2) {
          return t2.globals.lineProgress || 0;
        }], accumulated: [qt, [], function(t2) {
          return void 0 === t2.globals.accumulated ? null : t2.globals.accumulated;
        }], "+": [Ot, lr(Ot), function(t2, e2) {
          for (var r2 = 0, n2 = 0, i2 = e2; n2 < i2.length; n2 += 1) {
            r2 += i2[n2].evaluate(t2);
          }
          return r2;
        }], "*": [Ot, lr(Ot), function(t2, e2) {
          for (var r2 = 1, n2 = 0, i2 = e2; n2 < i2.length; n2 += 1) {
            r2 *= i2[n2].evaluate(t2);
          }
          return r2;
        }], "-": { type: Ot, overloads: [[[Ot, Ot], function(t2, e2) {
          var r2 = e2[0], n2 = e2[1];
          return r2.evaluate(t2) - n2.evaluate(t2);
        }], [[Ot], function(t2, e2) {
          return -e2[0].evaluate(t2);
        }]] }, "/": [Ot, [Ot, Ot], function(t2, e2) {
          var r2 = e2[0], n2 = e2[1];
          return r2.evaluate(t2) / n2.evaluate(t2);
        }], "%": [Ot, [Ot, Ot], function(t2, e2) {
          var r2 = e2[0], n2 = e2[1];
          return r2.evaluate(t2) % n2.evaluate(t2);
        }], ln2: [Ot, [], function() {
          return Math.LN2;
        }], pi: [Ot, [], function() {
          return Math.PI;
        }], e: [Ot, [], function() {
          return Math.E;
        }], "^": [Ot, [Ot, Ot], function(t2, e2) {
          var r2 = e2[0], n2 = e2[1];
          return Math.pow(r2.evaluate(t2), n2.evaluate(t2));
        }], sqrt: [Ot, [Ot], function(t2, e2) {
          var r2 = e2[0];
          return Math.sqrt(r2.evaluate(t2));
        }], log10: [Ot, [Ot], function(t2, e2) {
          var r2 = e2[0];
          return Math.log(r2.evaluate(t2)) / Math.LN10;
        }], ln: [Ot, [Ot], function(t2, e2) {
          var r2 = e2[0];
          return Math.log(r2.evaluate(t2));
        }], log2: [Ot, [Ot], function(t2, e2) {
          var r2 = e2[0];
          return Math.log(r2.evaluate(t2)) / Math.LN2;
        }], sin: [Ot, [Ot], function(t2, e2) {
          var r2 = e2[0];
          return Math.sin(r2.evaluate(t2));
        }], cos: [Ot, [Ot], function(t2, e2) {
          var r2 = e2[0];
          return Math.cos(r2.evaluate(t2));
        }], tan: [Ot, [Ot], function(t2, e2) {
          var r2 = e2[0];
          return Math.tan(r2.evaluate(t2));
        }], asin: [Ot, [Ot], function(t2, e2) {
          var r2 = e2[0];
          return Math.asin(r2.evaluate(t2));
        }], acos: [Ot, [Ot], function(t2, e2) {
          var r2 = e2[0];
          return Math.acos(r2.evaluate(t2));
        }], atan: [Ot, [Ot], function(t2, e2) {
          var r2 = e2[0];
          return Math.atan(r2.evaluate(t2));
        }], min: [Ot, lr(Ot), function(t2, e2) {
          return Math.min.apply(Math, e2.map(function(e3) {
            return e3.evaluate(t2);
          }));
        }], max: [Ot, lr(Ot), function(t2, e2) {
          return Math.max.apply(Math, e2.map(function(e3) {
            return e3.evaluate(t2);
          }));
        }], abs: [Ot, [Ot], function(t2, e2) {
          var r2 = e2[0];
          return Math.abs(r2.evaluate(t2));
        }], round: [Ot, [Ot], function(t2, e2) {
          var r2 = e2[0].evaluate(t2);
          return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
        }], floor: [Ot, [Ot], function(t2, e2) {
          var r2 = e2[0];
          return Math.floor(r2.evaluate(t2));
        }], ceil: [Ot, [Ot], function(t2, e2) {
          var r2 = e2[0];
          return Math.ceil(r2.evaluate(t2));
        }], "filter-==": [Rt, [Dt, qt], function(t2, e2) {
          var r2 = e2[0], n2 = e2[1];
          return t2.properties()[r2.value] === n2.value;
        }], "filter-id-==": [Rt, [qt], function(t2, e2) {
          var r2 = e2[0];
          return t2.id() === r2.value;
        }], "filter-type-==": [Rt, [Dt], function(t2, e2) {
          var r2 = e2[0];
          return t2.geometryType() === r2.value;
        }], "filter-<": [Rt, [Dt, qt], function(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = t2.properties()[r2.value], a2 = n2.value;
          return typeof i2 == typeof a2 && i2 < a2;
        }], "filter-id-<": [Rt, [qt], function(t2, e2) {
          var r2 = e2[0], n2 = t2.id(), i2 = r2.value;
          return typeof n2 == typeof i2 && n2 < i2;
        }], "filter->": [Rt, [Dt, qt], function(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = t2.properties()[r2.value], a2 = n2.value;
          return typeof i2 == typeof a2 && i2 > a2;
        }], "filter-id->": [Rt, [qt], function(t2, e2) {
          var r2 = e2[0], n2 = t2.id(), i2 = r2.value;
          return typeof n2 == typeof i2 && n2 > i2;
        }], "filter-<=": [Rt, [Dt, qt], function(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = t2.properties()[r2.value], a2 = n2.value;
          return typeof i2 == typeof a2 && i2 <= a2;
        }], "filter-id-<=": [Rt, [qt], function(t2, e2) {
          var r2 = e2[0], n2 = t2.id(), i2 = r2.value;
          return typeof n2 == typeof i2 && n2 <= i2;
        }], "filter->=": [Rt, [Dt, qt], function(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = t2.properties()[r2.value], a2 = n2.value;
          return typeof i2 == typeof a2 && i2 >= a2;
        }], "filter-id->=": [Rt, [qt], function(t2, e2) {
          var r2 = e2[0], n2 = t2.id(), i2 = r2.value;
          return typeof n2 == typeof i2 && n2 >= i2;
        }], "filter-has": [Rt, [qt], function(t2, e2) {
          return e2[0].value in t2.properties();
        }], "filter-has-id": [Rt, [], function(t2) {
          return null !== t2.id();
        }], "filter-type-in": [Rt, [Zt(Dt)], function(t2, e2) {
          return e2[0].value.indexOf(t2.geometryType()) >= 0;
        }], "filter-id-in": [Rt, [Zt(qt)], function(t2, e2) {
          return e2[0].value.indexOf(t2.id()) >= 0;
        }], "filter-in-small": [Rt, [Dt, Zt(qt)], function(t2, e2) {
          var r2 = e2[0];
          return e2[1].value.indexOf(t2.properties()[r2.value]) >= 0;
        }], "filter-in-large": [Rt, [Dt, Zt(qt)], function(t2, e2) {
          var r2 = e2[0], n2 = e2[1];
          return function(t3, e3, r3, n3) {
            for (; r3 <= n3; ) {
              var i2 = r3 + n3 >> 1;
              if (e3[i2] === t3)
                return true;
              e3[i2] > t3 ? n3 = i2 - 1 : r3 = i2 + 1;
            }
            return false;
          }(t2.properties()[r2.value], n2.value, 0, n2.value.length - 1);
        }], all: { type: Rt, overloads: [[[Rt, Rt], function(t2, e2) {
          var r2 = e2[0], n2 = e2[1];
          return r2.evaluate(t2) && n2.evaluate(t2);
        }], [lr(Rt), function(t2, e2) {
          for (var r2 = 0, n2 = e2; r2 < n2.length; r2 += 1) {
            if (!n2[r2].evaluate(t2))
              return false;
          }
          return true;
        }]] }, any: { type: Rt, overloads: [[[Rt, Rt], function(t2, e2) {
          var r2 = e2[0], n2 = e2[1];
          return r2.evaluate(t2) || n2.evaluate(t2);
        }], [lr(Rt), function(t2, e2) {
          for (var r2 = 0, n2 = e2; r2 < n2.length; r2 += 1) {
            if (n2[r2].evaluate(t2))
              return true;
          }
          return false;
        }]] }, "!": [Rt, [Rt], function(t2, e2) {
          return !e2[0].evaluate(t2);
        }], "is-supported-script": [Rt, [Dt], function(t2, e2) {
          var r2 = e2[0], n2 = t2.globals && t2.globals.isSupportedScript;
          return !n2 || n2(r2.evaluate(t2));
        }], upcase: [Dt, [Dt], function(t2, e2) {
          return e2[0].evaluate(t2).toUpperCase();
        }], downcase: [Dt, [Dt], function(t2, e2) {
          return e2[0].evaluate(t2).toLowerCase();
        }], concat: [Dt, lr(qt), function(t2, e2) {
          return e2.map(function(e3) {
            return ie(e3.evaluate(t2));
          }).join("");
        }], "resolved-locale": [Dt, [Nt], function(t2, e2) {
          return e2[0].evaluate(t2).resolvedLocale();
        }] });
        var Ar = function(t2, e2) {
          this.expression = t2, this._warningHistory = {}, this._evaluator = new ye(), this._defaultValue = e2 ? function(t3) {
            return "color" === t3.type && mr(t3.default) ? new $t(0, 0, 0, 0) : "color" === t3.type ? $t.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
          }(e2) : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
        };
        function Sr(t2) {
          return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in ar;
        }
        function kr(t2, e2) {
          var r2 = new _e(ar, [], e2 ? function(t3) {
            var e3 = { color: Ut, string: Dt, number: Ot, enum: Dt, boolean: Rt, formatted: Kt, resolvedImage: Xt };
            if ("array" === t3.type)
              return Zt(e3[t3.value] || qt, t3.length);
            return e3[t3.type];
          }(e2) : void 0), n2 = r2.parse(t2, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
          return n2 ? pr(new Ar(n2, e2)) : cr(r2.errors);
        }
        Ar.prototype.evaluateWithoutErrorHandling = function(t2, e2, r2, n2, i2) {
          return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.availableImages = n2 || null, this._evaluator.formattedSection = i2, this.expression.evaluate(this._evaluator);
        }, Ar.prototype.evaluate = function(t2, e2, r2, n2, i2) {
          this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.availableImages = n2 || null, this._evaluator.formattedSection = i2 || null;
          try {
            var a2 = this.expression.evaluate(this._evaluator);
            if (null == a2 || "number" == typeof a2 && a2 != a2)
              return this._defaultValue;
            if (this._enumValues && !(a2 in this._enumValues))
              throw new oe("Expected value to be one of " + Object.keys(this._enumValues).map(function(t3) {
                return JSON.stringify(t3);
              }).join(", ") + ", but found " + JSON.stringify(a2) + " instead.");
            return a2;
          } catch (t3) {
            return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(t3.message)), this._defaultValue;
          }
        };
        var Ir = function(t2, e2) {
          this.kind = t2, this._styleExpression = e2, this.isStateDependent = "constant" !== t2 && !ge(e2.expression);
        };
        Ir.prototype.evaluateWithoutErrorHandling = function(t2, e2, r2, n2, i2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2);
        }, Ir.prototype.evaluate = function(t2, e2, r2, n2, i2) {
          return this._styleExpression.evaluate(t2, e2, r2, n2, i2);
        };
        var zr = function(t2, e2, r2, n2) {
          this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t2 && !ge(e2.expression), this.interpolationType = n2;
        };
        function Cr(t2, e2) {
          if ("error" === (t2 = kr(t2, e2)).result)
            return t2;
          var r2 = t2.value.expression, n2 = ve(r2);
          if (!n2 && !hr(e2))
            return cr([new Vt("", "data expressions not supported")]);
          var i2 = xe(r2, ["zoom"]);
          if (!i2 && !fr(e2))
            return cr([new Vt("", "zoom expressions not supported")]);
          var a2 = function t3(e3) {
            var r3 = null;
            if (e3 instanceof Ne)
              r3 = t3(e3.result);
            else if (e3 instanceof qe)
              for (var n3 = 0, i3 = e3.args; n3 < i3.length; n3 += 1) {
                var a3 = i3[n3];
                if (r3 = t3(a3))
                  break;
              }
            else
              (e3 instanceof Ae || e3 instanceof Ue) && e3.input instanceof de && "zoom" === e3.input.name && (r3 = e3);
            if (r3 instanceof Vt)
              return r3;
            return e3.eachChild(function(e4) {
              var n4 = t3(e4);
              n4 instanceof Vt ? r3 = n4 : !r3 && n4 ? r3 = new Vt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : r3 && n4 && r3 !== n4 && (r3 = new Vt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), r3;
          }(r2);
          if (!a2 && !i2)
            return cr([new Vt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
          if (a2 instanceof Vt)
            return cr([a2]);
          if (a2 instanceof Ue && !yr(e2))
            return cr([new Vt("", '"interpolate" expressions cannot be used with this property')]);
          if (!a2)
            return pr(new Ir(n2 ? "constant" : "source", t2.value));
          var o2 = a2 instanceof Ue ? a2.interpolation : void 0;
          return pr(new zr(n2 ? "camera" : "composite", t2.value, a2.labels, o2));
        }
        zr.prototype.evaluateWithoutErrorHandling = function(t2, e2, r2, n2, i2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2);
        }, zr.prototype.evaluate = function(t2, e2, r2, n2, i2) {
          return this._styleExpression.evaluate(t2, e2, r2, n2, i2);
        }, zr.prototype.interpolationFactor = function(t2, e2, r2) {
          return this.interpolationType ? Ue.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
        };
        var Br = function(t2, e2) {
          this._parameters = t2, this._specification = e2, Tt(this, function t3(e3, r2) {
            var n2, i2, a2, o2 = "color" === r2.type, s2 = e3.stops && "object" == typeof e3.stops[0][0], u2 = s2 || void 0 !== e3.property, l2 = s2 || !u2, p2 = e3.type || (yr(r2) ? "exponential" : "interval");
            if (o2 && ((e3 = Tt({}, e3)).stops && (e3.stops = e3.stops.map(function(t4) {
              return [t4[0], $t.parse(t4[1])];
            })), e3.default ? e3.default = $t.parse(e3.default) : e3.default = $t.parse(r2.default)), e3.colorSpace && "rgb" !== e3.colorSpace && !Re[e3.colorSpace])
              throw new Error("Unknown color space: " + e3.colorSpace);
            if ("exponential" === p2)
              n2 = _r;
            else if ("interval" === p2)
              n2 = br;
            else if ("categorical" === p2) {
              n2 = xr, i2 = /* @__PURE__ */ Object.create(null);
              for (var c2 = 0, h2 = e3.stops; c2 < h2.length; c2 += 1) {
                var f2 = h2[c2];
                i2[f2[0]] = f2[1];
              }
              a2 = typeof e3.stops[0][0];
            } else {
              if ("identity" !== p2)
                throw new Error('Unknown function type "' + p2 + '"');
              n2 = wr;
            }
            if (s2) {
              for (var y2 = {}, d2 = [], m2 = 0; m2 < e3.stops.length; m2++) {
                var v2 = e3.stops[m2], g2 = v2[0].zoom;
                void 0 === y2[g2] && (y2[g2] = { zoom: g2, type: e3.type, property: e3.property, default: e3.default, stops: [] }, d2.push(g2)), y2[g2].stops.push([v2[0].value, v2[1]]);
              }
              for (var x2 = [], b2 = 0, _2 = d2; b2 < _2.length; b2 += 1) {
                var w2 = _2[b2];
                x2.push([y2[w2].zoom, t3(y2[w2], r2)]);
              }
              var A2 = { name: "linear" };
              return { kind: "composite", interpolationType: A2, interpolationFactor: Ue.interpolationFactor.bind(void 0, A2), zoomStops: x2.map(function(t4) {
                return t4[0];
              }), evaluate: function(t4, n3) {
                var i3 = t4.zoom;
                return _r({ stops: x2, base: e3.base }, r2, i3).evaluate(i3, n3);
              } };
            }
            if (l2) {
              var S2 = "exponential" === p2 ? { name: "exponential", base: void 0 !== e3.base ? e3.base : 1 } : null;
              return { kind: "camera", interpolationType: S2, interpolationFactor: Ue.interpolationFactor.bind(void 0, S2), zoomStops: e3.stops.map(function(t4) {
                return t4[0];
              }), evaluate: function(t4) {
                var o3 = t4.zoom;
                return n2(e3, r2, o3, i2, a2);
              } };
            }
            return { kind: "source", evaluate: function(t4, o3) {
              var s3 = o3 && o3.properties ? o3.properties[e3.property] : void 0;
              return void 0 === s3 ? gr(e3.default, r2.default) : n2(e3, r2, s3, i2, a2);
            } };
          }(this._parameters, this._specification));
        };
        function Pr(t2) {
          var e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, a2 = t2.style, o2 = t2.styleSpec, s2 = [], u2 = dr(r2);
          if ("object" !== u2)
            return [new Bt(e2, r2, "object expected, " + u2 + " found")];
          for (var l2 in r2) {
            var p2 = l2.split(".")[0], c2 = n2[p2] || n2["*"], h2 = void 0;
            if (i2[p2])
              h2 = i2[p2];
            else if (n2[p2])
              h2 = en;
            else if (i2["*"])
              h2 = i2["*"];
            else {
              if (!n2["*"]) {
                s2.push(new Bt(e2, r2[l2], 'unknown property "' + l2 + '"'));
                continue;
              }
              h2 = en;
            }
            s2 = s2.concat(h2({ key: (e2 ? e2 + "." : e2) + l2, value: r2[l2], valueSpec: c2, style: a2, styleSpec: o2, object: r2, objectKey: l2 }, r2));
          }
          for (var f2 in n2)
            i2[f2] || n2[f2].required && void 0 === n2[f2].default && void 0 === r2[f2] && s2.push(new Bt(e2, r2, 'missing required property "' + f2 + '"'));
          return s2;
        }
        function Tr(t2) {
          var e2 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, a2 = t2.key, o2 = t2.arrayElementValidator || en;
          if ("array" !== dr(e2))
            return [new Bt(a2, e2, "array expected, " + dr(e2) + " found")];
          if (r2.length && e2.length !== r2.length)
            return [new Bt(a2, e2, "array length " + r2.length + " expected, length " + e2.length + " found")];
          if (r2["min-length"] && e2.length < r2["min-length"])
            return [new Bt(a2, e2, "array length at least " + r2["min-length"] + " expected, length " + e2.length + " found")];
          var s2 = { type: r2.value, values: r2.values };
          i2.$version < 7 && (s2.function = r2.function), "object" === dr(r2.value) && (s2 = r2.value);
          for (var u2 = [], l2 = 0; l2 < e2.length; l2++)
            u2 = u2.concat(o2({ array: e2, arrayIndex: l2, value: e2[l2], valueSpec: s2, style: n2, styleSpec: i2, key: a2 + "[" + l2 + "]" }));
          return u2;
        }
        function Er(t2) {
          var e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = dr(r2);
          return "number" === i2 && r2 != r2 && (i2 = "NaN"), "number" !== i2 ? [new Bt(e2, r2, "number expected, " + i2 + " found")] : "minimum" in n2 && r2 < n2.minimum ? [new Bt(e2, r2, r2 + " is less than the minimum value " + n2.minimum)] : "maximum" in n2 && r2 > n2.maximum ? [new Bt(e2, r2, r2 + " is greater than the maximum value " + n2.maximum)] : [];
        }
        function Mr(t2) {
          var e2, r2, n2, i2 = t2.valueSpec, a2 = Et(t2.value.type), o2 = {}, s2 = "categorical" !== a2 && void 0 === t2.value.property, u2 = !s2, l2 = "array" === dr(t2.value.stops) && "array" === dr(t2.value.stops[0]) && "object" === dr(t2.value.stops[0][0]), p2 = Pr({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
            if ("identity" === a2)
              return [new Bt(t3.key, t3.value, 'identity function may not have a "stops" property')];
            var e3 = [], r3 = t3.value;
            e3 = e3.concat(Tr({ key: t3.key, value: r3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: c2 })), "array" === dr(r3) && 0 === r3.length && e3.push(new Bt(t3.key, r3, "array must have at least one stop"));
            return e3;
          }, default: function(t3) {
            return en({ key: t3.key, value: t3.value, valueSpec: i2, style: t3.style, styleSpec: t3.styleSpec });
          } } });
          return "identity" === a2 && s2 && p2.push(new Bt(t2.key, t2.value, 'missing required property "property"')), "identity" === a2 || t2.value.stops || p2.push(new Bt(t2.key, t2.value, 'missing required property "stops"')), "exponential" === a2 && t2.valueSpec.expression && !yr(t2.valueSpec) && p2.push(new Bt(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (u2 && !hr(t2.valueSpec) ? p2.push(new Bt(t2.key, t2.value, "property functions not supported")) : s2 && !fr(t2.valueSpec) && p2.push(new Bt(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== a2 && !l2 || void 0 !== t2.value.property || p2.push(new Bt(t2.key, t2.value, '"property" property is required')), p2;
          function c2(t3) {
            var e3 = [], a3 = t3.value, s3 = t3.key;
            if ("array" !== dr(a3))
              return [new Bt(s3, a3, "array expected, " + dr(a3) + " found")];
            if (2 !== a3.length)
              return [new Bt(s3, a3, "array length 2 expected, length " + a3.length + " found")];
            if (l2) {
              if ("object" !== dr(a3[0]))
                return [new Bt(s3, a3, "object expected, " + dr(a3[0]) + " found")];
              if (void 0 === a3[0].zoom)
                return [new Bt(s3, a3, "object stop key must have zoom")];
              if (void 0 === a3[0].value)
                return [new Bt(s3, a3, "object stop key must have value")];
              if (n2 && n2 > Et(a3[0].zoom))
                return [new Bt(s3, a3[0].zoom, "stop zoom values must appear in ascending order")];
              Et(a3[0].zoom) !== n2 && (n2 = Et(a3[0].zoom), r2 = void 0, o2 = {}), e3 = e3.concat(Pr({ key: s3 + "[0]", value: a3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: Er, value: h2 } }));
            } else
              e3 = e3.concat(h2({ key: s3 + "[0]", value: a3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, a3));
            return Sr(Mt(a3[1])) ? e3.concat([new Bt(s3 + "[1]", a3[1], "expressions are not allowed in function stops.")]) : e3.concat(en({ key: s3 + "[1]", value: a3[1], valueSpec: i2, style: t3.style, styleSpec: t3.styleSpec }));
          }
          function h2(t3, n3) {
            var s3 = dr(t3.value), u3 = Et(t3.value), l3 = null !== t3.value ? t3.value : n3;
            if (e2) {
              if (s3 !== e2)
                return [new Bt(t3.key, l3, s3 + " stop domain type must match previous stop domain type " + e2)];
            } else
              e2 = s3;
            if ("number" !== s3 && "string" !== s3 && "boolean" !== s3)
              return [new Bt(t3.key, l3, "stop domain value must be a number, string, or boolean")];
            if ("number" !== s3 && "categorical" !== a2) {
              var p3 = "number expected, " + s3 + " found";
              return hr(i2) && void 0 === a2 && (p3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Bt(t3.key, l3, p3)];
            }
            return "categorical" !== a2 || "number" !== s3 || isFinite(u3) && Math.floor(u3) === u3 ? "categorical" !== a2 && "number" === s3 && void 0 !== r2 && u3 < r2 ? [new Bt(t3.key, l3, "stop domain values must appear in ascending order")] : (r2 = u3, "categorical" === a2 && u3 in o2 ? [new Bt(t3.key, l3, "stop domain values must be unique")] : (o2[u3] = true, [])) : [new Bt(t3.key, l3, "integer expected, found " + u3)];
          }
        }
        function Vr(t2) {
          var e2 = ("property" === t2.expressionContext ? Cr : kr)(Mt(t2.value), t2.valueSpec);
          if ("error" === e2.result)
            return e2.value.map(function(e3) {
              return new Bt("" + t2.key + e3.key, t2.value, e3.message);
            });
          var r2 = e2.value.expression || e2.value._styleExpression.expression;
          if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && -1 !== r2.possibleOutputs().indexOf(void 0))
            return [new Bt(t2.key, t2.value, 'Invalid data expression for "' + t2.propertyKey + '". Output values must be contained as literals within the expression.')];
          if ("property" === t2.expressionContext && "layout" === t2.propertyType && !ge(r2))
            return [new Bt(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t2.expressionContext && !ge(r2))
            return [new Bt(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
          if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
            if (!xe(r2, ["zoom", "feature-state"]))
              return [new Bt(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t2.expressionContext && !ve(r2))
              return [new Bt(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function Fr(t2) {
          var e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
          return Array.isArray(n2.values) ? -1 === n2.values.indexOf(Et(r2)) && i2.push(new Bt(e2, r2, "expected one of [" + n2.values.join(", ") + "], " + JSON.stringify(r2) + " found")) : -1 === Object.keys(n2.values).indexOf(Et(r2)) && i2.push(new Bt(e2, r2, "expected one of [" + Object.keys(n2.values).join(", ") + "], " + JSON.stringify(r2) + " found")), i2;
        }
        function Lr(t2) {
          if (true === t2 || false === t2)
            return true;
          if (!Array.isArray(t2) || 0 === t2.length)
            return false;
          switch (t2[0]) {
            case "has":
              return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
            case "in":
              return t2.length >= 3 && Array.isArray(t2[2]);
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
            case "any":
            case "all":
              for (var e2 = 0, r2 = t2.slice(1); e2 < r2.length; e2 += 1) {
                var n2 = r2[e2];
                if (!Lr(n2) && "boolean" != typeof n2)
                  return false;
              }
              return true;
            default:
              return true;
          }
        }
        Br.deserialize = function(t2) {
          return new Br(t2._parameters, t2._specification);
        }, Br.serialize = function(t2) {
          return { _parameters: t2._parameters, _specification: t2._specification };
        };
        var Or = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function Dr(t2) {
          if (null == t2)
            return function() {
              return true;
            };
          Lr(t2) || (t2 = Ur(t2));
          var e2 = kr(t2, Or);
          if ("error" === e2.result)
            throw new Error(e2.value.map(function(t3) {
              return t3.key + ": " + t3.message;
            }).join(", "));
          return function(t3, r2) {
            return e2.value.evaluate(t3, r2);
          };
        }
        function Rr(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function Ur(t2) {
          if (!t2)
            return true;
          var e2, r2 = t2[0];
          return t2.length <= 1 ? "any" !== r2 : "==" === r2 ? jr(t2[1], t2[2], "==") : "!=" === r2 ? Kr(jr(t2[1], t2[2], "==")) : "<" === r2 || ">" === r2 || "<=" === r2 || ">=" === r2 ? jr(t2[1], t2[2], r2) : "any" === r2 ? (e2 = t2.slice(1), ["any"].concat(e2.map(Ur))) : "all" === r2 ? ["all"].concat(t2.slice(1).map(Ur)) : "none" === r2 ? ["all"].concat(t2.slice(1).map(Ur).map(Kr)) : "in" === r2 ? qr(t2[1], t2.slice(2)) : "!in" === r2 ? Kr(qr(t2[1], t2.slice(2))) : "has" === r2 ? Nr(t2[1]) : "!has" !== r2 || Kr(Nr(t2[1]));
        }
        function jr(t2, e2, r2) {
          switch (t2) {
            case "$type":
              return ["filter-type-" + r2, e2];
            case "$id":
              return ["filter-id-" + r2, e2];
            default:
              return ["filter-" + r2, t2, e2];
          }
        }
        function qr(t2, e2) {
          if (0 === e2.length)
            return false;
          switch (t2) {
            case "$type":
              return ["filter-type-in", ["literal", e2]];
            case "$id":
              return ["filter-id-in", ["literal", e2]];
            default:
              return e2.length > 200 && !e2.some(function(t3) {
                return typeof t3 != typeof e2[0];
              }) ? ["filter-in-large", t2, ["literal", e2.sort(Rr)]] : ["filter-in-small", t2, ["literal", e2]];
          }
        }
        function Nr(t2) {
          switch (t2) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t2];
          }
        }
        function Kr(t2) {
          return ["!", t2];
        }
        function Xr(t2) {
          return Lr(Mt(t2.value)) ? Vr(Tt({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : function t3(e2) {
            var r2 = e2.value, n2 = e2.key;
            if ("array" !== dr(r2))
              return [new Bt(n2, r2, "array expected, " + dr(r2) + " found")];
            var i2, a2 = e2.styleSpec, o2 = [];
            if (r2.length < 1)
              return [new Bt(n2, r2, "filter array must have at least 1 element")];
            switch (o2 = o2.concat(Fr({ key: n2 + "[0]", value: r2[0], valueSpec: a2.filter_operator, style: e2.style, styleSpec: e2.styleSpec })), Et(r2[0])) {
              case "<":
              case "<=":
              case ">":
              case ">=":
                r2.length >= 2 && "$type" === Et(r2[1]) && o2.push(new Bt(n2, r2, '"$type" cannot be use with operator "' + r2[0] + '"'));
              case "==":
              case "!=":
                3 !== r2.length && o2.push(new Bt(n2, r2, 'filter array for operator "' + r2[0] + '" must have 3 elements'));
              case "in":
              case "!in":
                r2.length >= 2 && "string" !== (i2 = dr(r2[1])) && o2.push(new Bt(n2 + "[1]", r2[1], "string expected, " + i2 + " found"));
                for (var s2 = 2; s2 < r2.length; s2++)
                  i2 = dr(r2[s2]), "$type" === Et(r2[1]) ? o2 = o2.concat(Fr({ key: n2 + "[" + s2 + "]", value: r2[s2], valueSpec: a2.geometry_type, style: e2.style, styleSpec: e2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && o2.push(new Bt(n2 + "[" + s2 + "]", r2[s2], "string, number, or boolean expected, " + i2 + " found"));
                break;
              case "any":
              case "all":
              case "none":
                for (var u2 = 1; u2 < r2.length; u2++)
                  o2 = o2.concat(t3({ key: n2 + "[" + u2 + "]", value: r2[u2], style: e2.style, styleSpec: e2.styleSpec }));
                break;
              case "has":
              case "!has":
                i2 = dr(r2[1]), 2 !== r2.length ? o2.push(new Bt(n2, r2, 'filter array for "' + r2[0] + '" operator must have 2 elements')) : "string" !== i2 && o2.push(new Bt(n2 + "[1]", r2[1], "string expected, " + i2 + " found"));
            }
            return o2;
          }(t2);
        }
        function Zr(t2, e2) {
          var r2 = t2.key, n2 = t2.style, i2 = t2.styleSpec, a2 = t2.value, o2 = t2.objectKey, s2 = i2[e2 + "_" + t2.layerType];
          if (!s2)
            return [];
          var u2 = o2.match(/^(.*)-transition$/);
          if ("paint" === e2 && u2 && s2[u2[1]] && s2[u2[1]].transition)
            return en({ key: r2, value: a2, valueSpec: i2.transition, style: n2, styleSpec: i2 });
          var l2, p2 = t2.valueSpec || s2[o2];
          if (!p2)
            return [new Bt(r2, a2, 'unknown property "' + o2 + '"')];
          if ("string" === dr(a2) && hr(p2) && !p2.tokens && (l2 = /^{([^}]+)}$/.exec(a2)))
            return [new Bt(r2, a2, '"' + o2 + '" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(l2[1]) + " }`.")];
          var c2 = [];
          return "symbol" === t2.layerType && ("text-field" === o2 && n2 && !n2.glyphs && c2.push(new Bt(r2, a2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o2 && mr(Mt(a2)) && "identity" === Et(a2.type) && c2.push(new Bt(r2, a2, '"text-font" does not support identity functions'))), c2.concat(en({ key: t2.key, value: a2, valueSpec: p2, style: n2, styleSpec: i2, expressionContext: "property", propertyType: e2, propertyKey: o2 }));
        }
        function Gr(t2) {
          return Zr(t2, "paint");
        }
        function Jr(t2) {
          return Zr(t2, "layout");
        }
        function Hr(t2) {
          var e2 = [], r2 = t2.value, n2 = t2.key, i2 = t2.style, a2 = t2.styleSpec;
          r2.type || r2.ref || e2.push(new Bt(n2, r2, 'either "type" or "ref" is required'));
          var o2, s2 = Et(r2.type), u2 = Et(r2.ref);
          if (r2.id)
            for (var l2 = Et(r2.id), p2 = 0; p2 < t2.arrayIndex; p2++) {
              var c2 = i2.layers[p2];
              Et(c2.id) === l2 && e2.push(new Bt(n2, r2.id, 'duplicate layer id "' + r2.id + '", previously used at line ' + c2.id.__line__));
            }
          if ("ref" in r2)
            ["type", "source", "source-layer", "filter", "layout"].forEach(function(t3) {
              t3 in r2 && e2.push(new Bt(n2, r2[t3], '"' + t3 + '" is prohibited for ref layers'));
            }), i2.layers.forEach(function(t3) {
              Et(t3.id) === u2 && (o2 = t3);
            }), o2 ? o2.ref ? e2.push(new Bt(n2, r2.ref, "ref cannot reference another ref layer")) : s2 = Et(o2.type) : e2.push(new Bt(n2, r2.ref, 'ref layer "' + u2 + '" not found'));
          else if ("background" !== s2)
            if (r2.source) {
              var h2 = i2.sources && i2.sources[r2.source], f2 = h2 && Et(h2.type);
              h2 ? "vector" === f2 && "raster" === s2 ? e2.push(new Bt(n2, r2.source, 'layer "' + r2.id + '" requires a raster source')) : "raster" === f2 && "raster" !== s2 ? e2.push(new Bt(n2, r2.source, 'layer "' + r2.id + '" requires a vector source')) : "vector" !== f2 || r2["source-layer"] ? "raster-dem" === f2 && "hillshade" !== s2 ? e2.push(new Bt(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s2 || !r2.paint || !r2.paint["line-gradient"] || "geojson" === f2 && h2.lineMetrics || e2.push(new Bt(n2, r2, 'layer "' + r2.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')) : e2.push(new Bt(n2, r2, 'layer "' + r2.id + '" must specify a "source-layer"')) : e2.push(new Bt(n2, r2.source, 'source "' + r2.source + '" not found'));
            } else
              e2.push(new Bt(n2, r2, 'missing required property "source"'));
          return e2 = e2.concat(Pr({ key: n2, value: r2, valueSpec: a2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": function() {
            return [];
          }, type: function() {
            return en({ key: n2 + ".type", value: r2.type, valueSpec: a2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: r2, objectKey: "type" });
          }, filter: Xr, layout: function(t3) {
            return Pr({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": function(t4) {
              return Jr(Tt({ layerType: s2 }, t4));
            } } });
          }, paint: function(t3) {
            return Pr({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": function(t4) {
              return Gr(Tt({ layerType: s2 }, t4));
            } } });
          } } }));
        }
        function Yr(t2) {
          var e2 = t2.value, r2 = t2.key, n2 = dr(e2);
          return "string" !== n2 ? [new Bt(r2, e2, "string expected, " + n2 + " found")] : [];
        }
        var $r = { promoteId: function(t2) {
          var e2 = t2.key, r2 = t2.value;
          if ("string" === dr(r2))
            return Yr({ key: e2, value: r2 });
          var n2 = [];
          for (var i2 in r2)
            n2.push.apply(n2, Yr({ key: e2 + "." + i2, value: r2[i2] }));
          return n2;
        } };
        function Wr(t2) {
          var e2 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style;
          if (!e2.type)
            return [new Bt(r2, e2, '"type" is required')];
          var a2, o2 = Et(e2.type);
          switch (o2) {
            case "vector":
            case "raster":
            case "raster-dem":
              return a2 = Pr({ key: r2, value: e2, valueSpec: n2["source_" + o2.replace("-", "_")], style: t2.style, styleSpec: n2, objectElementValidators: $r });
            case "geojson":
              if (a2 = Pr({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, objectElementValidators: $r }), e2.cluster)
                for (var s2 in e2.clusterProperties) {
                  var u2 = e2.clusterProperties[s2], l2 = u2[0], p2 = u2[1], c2 = "string" == typeof l2 ? [l2, ["accumulated"], ["get", s2]] : l2;
                  a2.push.apply(a2, Vr({ key: r2 + "." + s2 + ".map", value: p2, expressionContext: "cluster-map" })), a2.push.apply(a2, Vr({ key: r2 + "." + s2 + ".reduce", value: c2, expressionContext: "cluster-reduce" }));
                }
              return a2;
            case "video":
              return Pr({ key: r2, value: e2, valueSpec: n2.source_video, style: i2, styleSpec: n2 });
            case "image":
              return Pr({ key: r2, value: e2, valueSpec: n2.source_image, style: i2, styleSpec: n2 });
            case "canvas":
              return [new Bt(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return Fr({ key: r2 + ".type", value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i2, styleSpec: n2 });
          }
        }
        function Qr(t2) {
          var e2 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style, a2 = [], o2 = dr(e2);
          if (void 0 === e2)
            return a2;
          if ("object" !== o2)
            return a2 = a2.concat([new Bt("light", e2, "object expected, " + o2 + " found")]);
          for (var s2 in e2) {
            var u2 = s2.match(/^(.*)-transition$/);
            a2 = u2 && n2[u2[1]] && n2[u2[1]].transition ? a2.concat(en({ key: s2, value: e2[s2], valueSpec: r2.transition, style: i2, styleSpec: r2 })) : n2[s2] ? a2.concat(en({ key: s2, value: e2[s2], valueSpec: n2[s2], style: i2, styleSpec: r2 })) : a2.concat([new Bt(s2, e2[s2], 'unknown property "' + s2 + '"')]);
          }
          return a2;
        }
        var tn = { "*": function() {
          return [];
        }, array: Tr, boolean: function(t2) {
          var e2 = t2.value, r2 = t2.key, n2 = dr(e2);
          return "boolean" !== n2 ? [new Bt(r2, e2, "boolean expected, " + n2 + " found")] : [];
        }, number: Er, color: function(t2) {
          var e2 = t2.key, r2 = t2.value, n2 = dr(r2);
          return "string" !== n2 ? [new Bt(e2, r2, "color expected, " + n2 + " found")] : null === Yt(r2) ? [new Bt(e2, r2, 'color expected, "' + r2 + '" found')] : [];
        }, constants: Pt, enum: Fr, filter: Xr, function: Mr, layer: Hr, object: Pr, source: Wr, light: Qr, string: Yr, formatted: function(t2) {
          return 0 === Yr(t2).length ? [] : Vr(t2);
        }, resolvedImage: function(t2) {
          return 0 === Yr(t2).length ? [] : Vr(t2);
        } };
        function en(t2) {
          var e2 = t2.value, r2 = t2.valueSpec, n2 = t2.styleSpec;
          return r2.expression && mr(Et(e2)) ? Mr(t2) : r2.expression && Sr(Mt(e2)) ? Vr(t2) : r2.type && tn[r2.type] ? tn[r2.type](t2) : Pr(Tt({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
        }
        function rn(t2) {
          var e2 = t2.value, r2 = t2.key, n2 = Yr(t2);
          return n2.length || (-1 === e2.indexOf("{fontstack}") && n2.push(new Bt(r2, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n2.push(new Bt(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
        }
        function nn(t2, e2) {
          void 0 === e2 && (e2 = Ct);
          var r2 = [];
          return r2 = r2.concat(en({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, objectElementValidators: { glyphs: rn, "*": function() {
            return [];
          } } })), t2.constants && (r2 = r2.concat(Pt({ key: "constants", value: t2.constants, style: t2, styleSpec: e2 }))), an(r2);
        }
        function an(t2) {
          return [].concat(t2).sort(function(t3, e2) {
            return t3.line - e2.line;
          });
        }
        function on(t2) {
          return function() {
            for (var e2 = [], r2 = arguments.length; r2--; )
              e2[r2] = arguments[r2];
            return an(t2.apply(this, e2));
          };
        }
        nn.source = on(Wr), nn.light = on(Qr), nn.layer = on(Hr), nn.filter = on(Xr), nn.paintProperty = on(Gr), nn.layoutProperty = on(Jr);
        var sn = nn, un = sn.light, ln = sn.paintProperty, pn = sn.layoutProperty;
        function cn(t2, e2) {
          var r2 = false;
          if (e2 && e2.length)
            for (var n2 = 0, i2 = e2; n2 < i2.length; n2 += 1) {
              var a2 = i2[n2];
              t2.fire(new It(new Error(a2.message))), r2 = true;
            }
          return r2;
        }
        var hn = fn;
        function fn(t2, e2, r2) {
          var n2 = this.cells = [];
          if (t2 instanceof ArrayBuffer) {
            this.arrayBuffer = t2;
            var i2 = new Int32Array(this.arrayBuffer);
            t2 = i2[0], e2 = i2[1], r2 = i2[2], this.d = e2 + 2 * r2;
            for (var a2 = 0; a2 < this.d * this.d; a2++) {
              var o2 = i2[3 + a2], s2 = i2[3 + a2 + 1];
              n2.push(o2 === s2 ? null : i2.subarray(o2, s2));
            }
            var u2 = i2[3 + n2.length], l2 = i2[3 + n2.length + 1];
            this.keys = i2.subarray(u2, l2), this.bboxes = i2.subarray(l2), this.insert = this._insertReadonly;
          } else {
            this.d = e2 + 2 * r2;
            for (var p2 = 0; p2 < this.d * this.d; p2++)
              n2.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
          var c2 = r2 / e2 * t2;
          this.min = -c2, this.max = t2 + c2;
        }
        fn.prototype.insert = function(t2, e2, r2, n2, i2) {
          this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
        }, fn.prototype._insertReadonly = function() {
          throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, fn.prototype._insertCell = function(t2, e2, r2, n2, i2, a2) {
          this.cells[i2].push(a2);
        }, fn.prototype.query = function(t2, e2, r2, n2, i2) {
          var a2 = this.min, o2 = this.max;
          if (t2 <= a2 && e2 <= a2 && o2 <= r2 && o2 <= n2 && !i2)
            return Array.prototype.slice.call(this.keys);
          var s2 = [];
          return this._forEachCell(t2, e2, r2, n2, this._queryCell, s2, {}, i2), s2;
        }, fn.prototype._queryCell = function(t2, e2, r2, n2, i2, a2, o2, s2) {
          var u2 = this.cells[i2];
          if (null !== u2)
            for (var l2 = this.keys, p2 = this.bboxes, c2 = 0; c2 < u2.length; c2++) {
              var h2 = u2[c2];
              if (void 0 === o2[h2]) {
                var f2 = 4 * h2;
                (s2 ? s2(p2[f2 + 0], p2[f2 + 1], p2[f2 + 2], p2[f2 + 3]) : t2 <= p2[f2 + 2] && e2 <= p2[f2 + 3] && r2 >= p2[f2 + 0] && n2 >= p2[f2 + 1]) ? (o2[h2] = true, a2.push(l2[h2])) : o2[h2] = false;
              }
            }
        }, fn.prototype._forEachCell = function(t2, e2, r2, n2, i2, a2, o2, s2) {
          for (var u2 = this._convertToCellCoord(t2), l2 = this._convertToCellCoord(e2), p2 = this._convertToCellCoord(r2), c2 = this._convertToCellCoord(n2), h2 = u2; h2 <= p2; h2++)
            for (var f2 = l2; f2 <= c2; f2++) {
              var y2 = this.d * f2 + h2;
              if ((!s2 || s2(this._convertFromCellCoord(h2), this._convertFromCellCoord(f2), this._convertFromCellCoord(h2 + 1), this._convertFromCellCoord(f2 + 1))) && i2.call(this, t2, e2, r2, n2, y2, a2, o2, s2))
                return;
            }
        }, fn.prototype._convertFromCellCoord = function(t2) {
          return (t2 - this.padding) / this.scale;
        }, fn.prototype._convertToCellCoord = function(t2) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
        }, fn.prototype.toArrayBuffer = function() {
          if (this.arrayBuffer)
            return this.arrayBuffer;
          for (var t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1, r2 = 0, n2 = 0; n2 < this.cells.length; n2++)
            r2 += this.cells[n2].length;
          var i2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
          i2[0] = this.extent, i2[1] = this.n, i2[2] = this.padding;
          for (var a2 = e2, o2 = 0; o2 < t2.length; o2++) {
            var s2 = t2[o2];
            i2[3 + o2] = a2, i2.set(s2, a2), a2 += s2.length;
          }
          return i2[3 + t2.length] = a2, i2.set(this.keys, a2), a2 += this.keys.length, i2[3 + t2.length + 1] = a2, i2.set(this.bboxes, a2), a2 += this.bboxes.length, i2.buffer;
        };
        var yn = self.ImageData, dn = self.ImageBitmap, mn = {};
        function vn(t2, e2, r2) {
          void 0 === r2 && (r2 = {}), Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: false }), mn[t2] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
        }
        for (var gn in vn("Object", Object), hn.serialize = function(t2, e2) {
          var r2 = t2.toArrayBuffer();
          return e2 && e2.push(r2), { buffer: r2 };
        }, hn.deserialize = function(t2) {
          return new hn(t2.buffer);
        }, vn("Grid", hn), vn("Color", $t), vn("Error", Error), vn("ResolvedImage", ee), vn("StylePropertyFunction", Br), vn("StyleExpression", Ar, { omit: ["_evaluator"] }), vn("ZoomDependentExpression", zr), vn("ZoomConstantExpression", Ir), vn("CompoundExpression", de, { omit: ["_evaluate"] }), ar)
          ar[gn]._classRegistryKey || vn("Expression_" + gn, ar[gn]);
        function xn(t2) {
          return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
        }
        function bn(t2) {
          return dn && t2 instanceof dn;
        }
        function _n(t2, e2) {
          if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp)
            return t2;
          if (xn(t2) || bn(t2))
            return e2 && e2.push(t2), t2;
          if (ArrayBuffer.isView(t2)) {
            var r2 = t2;
            return e2 && e2.push(r2.buffer), r2;
          }
          if (t2 instanceof yn)
            return e2 && e2.push(t2.data.buffer), t2;
          if (Array.isArray(t2)) {
            for (var n2 = [], i2 = 0, a2 = t2; i2 < a2.length; i2 += 1) {
              var o2 = a2[i2];
              n2.push(_n(o2, e2));
            }
            return n2;
          }
          if ("object" == typeof t2) {
            var s2 = t2.constructor, u2 = s2._classRegistryKey;
            if (!u2)
              throw new Error("can't serialize object of unregistered class");
            var l2 = s2.serialize ? s2.serialize(t2, e2) : {};
            if (!s2.serialize) {
              for (var p2 in t2)
                if (t2.hasOwnProperty(p2) && !(mn[u2].omit.indexOf(p2) >= 0)) {
                  var c2 = t2[p2];
                  l2[p2] = mn[u2].shallow.indexOf(p2) >= 0 ? c2 : _n(c2, e2);
                }
              t2 instanceof Error && (l2.message = t2.message);
            }
            if (l2.$name)
              throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== u2 && (l2.$name = u2), l2;
          }
          throw new Error("can't serialize object of type " + typeof t2);
        }
        function wn(t2) {
          if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || xn(t2) || bn(t2) || ArrayBuffer.isView(t2) || t2 instanceof yn)
            return t2;
          if (Array.isArray(t2))
            return t2.map(wn);
          if ("object" == typeof t2) {
            var e2 = t2.$name || "Object", r2 = mn[e2].klass;
            if (!r2)
              throw new Error("can't deserialize unregistered class " + e2);
            if (r2.deserialize)
              return r2.deserialize(t2);
            for (var n2 = Object.create(r2.prototype), i2 = 0, a2 = Object.keys(t2); i2 < a2.length; i2 += 1) {
              var o2 = a2[i2];
              if ("$name" !== o2) {
                var s2 = t2[o2];
                n2[o2] = mn[e2].shallow.indexOf(o2) >= 0 ? s2 : wn(s2);
              }
            }
            return n2;
          }
          throw new Error("can't deserialize object of type " + typeof t2);
        }
        var An = function() {
          this.first = true;
        };
        An.prototype.update = function(t2, e2) {
          var r2 = Math.floor(t2);
          return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, true));
        };
        var Sn = { "Latin-1 Supplement": function(t2) {
          return t2 >= 128 && t2 <= 255;
        }, Arabic: function(t2) {
          return t2 >= 1536 && t2 <= 1791;
        }, "Arabic Supplement": function(t2) {
          return t2 >= 1872 && t2 <= 1919;
        }, "Arabic Extended-A": function(t2) {
          return t2 >= 2208 && t2 <= 2303;
        }, "Hangul Jamo": function(t2) {
          return t2 >= 4352 && t2 <= 4607;
        }, "Unified Canadian Aboriginal Syllabics": function(t2) {
          return t2 >= 5120 && t2 <= 5759;
        }, Khmer: function(t2) {
          return t2 >= 6016 && t2 <= 6143;
        }, "Unified Canadian Aboriginal Syllabics Extended": function(t2) {
          return t2 >= 6320 && t2 <= 6399;
        }, "General Punctuation": function(t2) {
          return t2 >= 8192 && t2 <= 8303;
        }, "Letterlike Symbols": function(t2) {
          return t2 >= 8448 && t2 <= 8527;
        }, "Number Forms": function(t2) {
          return t2 >= 8528 && t2 <= 8591;
        }, "Miscellaneous Technical": function(t2) {
          return t2 >= 8960 && t2 <= 9215;
        }, "Control Pictures": function(t2) {
          return t2 >= 9216 && t2 <= 9279;
        }, "Optical Character Recognition": function(t2) {
          return t2 >= 9280 && t2 <= 9311;
        }, "Enclosed Alphanumerics": function(t2) {
          return t2 >= 9312 && t2 <= 9471;
        }, "Geometric Shapes": function(t2) {
          return t2 >= 9632 && t2 <= 9727;
        }, "Miscellaneous Symbols": function(t2) {
          return t2 >= 9728 && t2 <= 9983;
        }, "Miscellaneous Symbols and Arrows": function(t2) {
          return t2 >= 11008 && t2 <= 11263;
        }, "CJK Radicals Supplement": function(t2) {
          return t2 >= 11904 && t2 <= 12031;
        }, "Kangxi Radicals": function(t2) {
          return t2 >= 12032 && t2 <= 12255;
        }, "Ideographic Description Characters": function(t2) {
          return t2 >= 12272 && t2 <= 12287;
        }, "CJK Symbols and Punctuation": function(t2) {
          return t2 >= 12288 && t2 <= 12351;
        }, Hiragana: function(t2) {
          return t2 >= 12352 && t2 <= 12447;
        }, Katakana: function(t2) {
          return t2 >= 12448 && t2 <= 12543;
        }, Bopomofo: function(t2) {
          return t2 >= 12544 && t2 <= 12591;
        }, "Hangul Compatibility Jamo": function(t2) {
          return t2 >= 12592 && t2 <= 12687;
        }, Kanbun: function(t2) {
          return t2 >= 12688 && t2 <= 12703;
        }, "Bopomofo Extended": function(t2) {
          return t2 >= 12704 && t2 <= 12735;
        }, "CJK Strokes": function(t2) {
          return t2 >= 12736 && t2 <= 12783;
        }, "Katakana Phonetic Extensions": function(t2) {
          return t2 >= 12784 && t2 <= 12799;
        }, "Enclosed CJK Letters and Months": function(t2) {
          return t2 >= 12800 && t2 <= 13055;
        }, "CJK Compatibility": function(t2) {
          return t2 >= 13056 && t2 <= 13311;
        }, "CJK Unified Ideographs Extension A": function(t2) {
          return t2 >= 13312 && t2 <= 19903;
        }, "Yijing Hexagram Symbols": function(t2) {
          return t2 >= 19904 && t2 <= 19967;
        }, "CJK Unified Ideographs": function(t2) {
          return t2 >= 19968 && t2 <= 40959;
        }, "Yi Syllables": function(t2) {
          return t2 >= 40960 && t2 <= 42127;
        }, "Yi Radicals": function(t2) {
          return t2 >= 42128 && t2 <= 42191;
        }, "Hangul Jamo Extended-A": function(t2) {
          return t2 >= 43360 && t2 <= 43391;
        }, "Hangul Syllables": function(t2) {
          return t2 >= 44032 && t2 <= 55215;
        }, "Hangul Jamo Extended-B": function(t2) {
          return t2 >= 55216 && t2 <= 55295;
        }, "Private Use Area": function(t2) {
          return t2 >= 57344 && t2 <= 63743;
        }, "CJK Compatibility Ideographs": function(t2) {
          return t2 >= 63744 && t2 <= 64255;
        }, "Arabic Presentation Forms-A": function(t2) {
          return t2 >= 64336 && t2 <= 65023;
        }, "Vertical Forms": function(t2) {
          return t2 >= 65040 && t2 <= 65055;
        }, "CJK Compatibility Forms": function(t2) {
          return t2 >= 65072 && t2 <= 65103;
        }, "Small Form Variants": function(t2) {
          return t2 >= 65104 && t2 <= 65135;
        }, "Arabic Presentation Forms-B": function(t2) {
          return t2 >= 65136 && t2 <= 65279;
        }, "Halfwidth and Fullwidth Forms": function(t2) {
          return t2 >= 65280 && t2 <= 65519;
        } };
        function kn(t2) {
          for (var e2 = 0, r2 = t2; e2 < r2.length; e2 += 1) {
            if (zn(r2[e2].charCodeAt(0)))
              return true;
          }
          return false;
        }
        function In(t2) {
          return !Sn.Arabic(t2) && (!Sn["Arabic Supplement"](t2) && (!Sn["Arabic Extended-A"](t2) && (!Sn["Arabic Presentation Forms-A"](t2) && !Sn["Arabic Presentation Forms-B"](t2))));
        }
        function zn(t2) {
          return 746 === t2 || 747 === t2 || !(t2 < 4352) && (!!Sn["Bopomofo Extended"](t2) || (!!Sn.Bopomofo(t2) || (!(!Sn["CJK Compatibility Forms"](t2) || t2 >= 65097 && t2 <= 65103) || (!!Sn["CJK Compatibility Ideographs"](t2) || (!!Sn["CJK Compatibility"](t2) || (!!Sn["CJK Radicals Supplement"](t2) || (!!Sn["CJK Strokes"](t2) || (!(!Sn["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || (!!Sn["CJK Unified Ideographs Extension A"](t2) || (!!Sn["CJK Unified Ideographs"](t2) || (!!Sn["Enclosed CJK Letters and Months"](t2) || (!!Sn["Hangul Compatibility Jamo"](t2) || (!!Sn["Hangul Jamo Extended-A"](t2) || (!!Sn["Hangul Jamo Extended-B"](t2) || (!!Sn["Hangul Jamo"](t2) || (!!Sn["Hangul Syllables"](t2) || (!!Sn.Hiragana(t2) || (!!Sn["Ideographic Description Characters"](t2) || (!!Sn.Kanbun(t2) || (!!Sn["Kangxi Radicals"](t2) || (!!Sn["Katakana Phonetic Extensions"](t2) || (!(!Sn.Katakana(t2) || 12540 === t2) || (!(!Sn["Halfwidth and Fullwidth Forms"](t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || (!(!Sn["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || (!!Sn["Unified Canadian Aboriginal Syllabics"](t2) || (!!Sn["Unified Canadian Aboriginal Syllabics Extended"](t2) || (!!Sn["Vertical Forms"](t2) || (!!Sn["Yijing Hexagram Symbols"](t2) || (!!Sn["Yi Syllables"](t2) || !!Sn["Yi Radicals"](t2))))))))))))))))))))))))))))));
        }
        function Cn(t2) {
          return !(zn(t2) || function(t3) {
            return !(!Sn["Latin-1 Supplement"](t3) || 167 !== t3 && 169 !== t3 && 174 !== t3 && 177 !== t3 && 188 !== t3 && 189 !== t3 && 190 !== t3 && 215 !== t3 && 247 !== t3) || (!(!Sn["General Punctuation"](t3) || 8214 !== t3 && 8224 !== t3 && 8225 !== t3 && 8240 !== t3 && 8241 !== t3 && 8251 !== t3 && 8252 !== t3 && 8258 !== t3 && 8263 !== t3 && 8264 !== t3 && 8265 !== t3 && 8273 !== t3) || (!!Sn["Letterlike Symbols"](t3) || (!!Sn["Number Forms"](t3) || (!(!Sn["Miscellaneous Technical"](t3) || !(t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215)) || (!(!Sn["Control Pictures"](t3) || 9251 === t3) || (!!Sn["Optical Character Recognition"](t3) || (!!Sn["Enclosed Alphanumerics"](t3) || (!!Sn["Geometric Shapes"](t3) || (!(!Sn["Miscellaneous Symbols"](t3) || t3 >= 9754 && t3 <= 9759) || (!(!Sn["Miscellaneous Symbols and Arrows"](t3) || !(t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243)) || (!!Sn["CJK Symbols and Punctuation"](t3) || (!!Sn.Katakana(t3) || (!!Sn["Private Use Area"](t3) || (!!Sn["CJK Compatibility Forms"](t3) || (!!Sn["Small Form Variants"](t3) || (!!Sn["Halfwidth and Fullwidth Forms"](t3) || (8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3)))))))))))))))));
          }(t2));
        }
        function Bn(t2) {
          return t2 >= 1424 && t2 <= 2303 || Sn["Arabic Presentation Forms-A"](t2) || Sn["Arabic Presentation Forms-B"](t2);
        }
        function Pn(t2, e2) {
          return !(!e2 && Bn(t2)) && !(t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || Sn.Khmer(t2));
        }
        function Tn(t2) {
          for (var e2 = 0, r2 = t2; e2 < r2.length; e2 += 1) {
            if (Bn(r2[e2].charCodeAt(0)))
              return true;
          }
          return false;
        }
        var En = "deferred", Mn = "loading", Vn = "loaded", Fn = null, Ln = "unavailable", On = null, Dn = function(t2) {
          Fn && Fn(t2);
        };
        function Rn() {
          Un.fire(new kt("pluginStateChange", { pluginStatus: Ln, pluginURL: On }));
        }
        var Un = new zt(), jn = function() {
          return Ln;
        }, qn = function() {
          if (Ln !== En || !On)
            throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          Ln = Mn, Rn(), On && xt({ url: On }, function(t2) {
            t2 ? Dn(t2) : (Ln = Vn, Rn());
          });
        }, Nn = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: function() {
          return Ln === Vn || null != Nn.applyArabicShaping;
        }, isLoading: function() {
          return Ln === Mn;
        }, setState: function(t2) {
          Ln = t2.pluginStatus, On = t2.pluginURL;
        }, isParsed: function() {
          return null != Nn.applyArabicShaping && null != Nn.processBidirectionalText && null != Nn.processStyledBidirectionalText;
        }, getPluginURL: function() {
          return On;
        } }, Kn = function(t2, e2) {
          this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new An(), this.transition = {});
        };
        Kn.prototype.isSupportedScript = function(t2) {
          return function(t3, e2) {
            for (var r2 = 0, n2 = t3; r2 < n2.length; r2 += 1) {
              if (!Pn(n2[r2].charCodeAt(0), e2))
                return false;
            }
            return true;
          }(t2, Nn.isLoaded());
        }, Kn.prototype.crossFadingFactor = function() {
          return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }, Kn.prototype.getCrossfadeParameters = function() {
          var t2 = this.zoom, e2 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
          return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
        };
        var Xn = function(t2, e2) {
          this.property = t2, this.value = e2, this.expression = function(t3, e3) {
            if (mr(t3))
              return new Br(t3, e3);
            if (Sr(t3)) {
              var r2 = Cr(t3, e3);
              if ("error" === r2.result)
                throw new Error(r2.value.map(function(t4) {
                  return t4.key + ": " + t4.message;
                }).join(", "));
              return r2.value;
            }
            var n2 = t3;
            return "string" == typeof t3 && "color" === e3.type && (n2 = $t.parse(t3)), { kind: "constant", evaluate: function() {
              return n2;
            } };
          }(void 0 === e2 ? t2.specification.default : e2, t2.specification);
        };
        Xn.prototype.isDataDriven = function() {
          return "source" === this.expression.kind || "composite" === this.expression.kind;
        }, Xn.prototype.possiblyEvaluate = function(t2, e2) {
          return this.property.possiblyEvaluate(this, t2, e2);
        };
        var Zn = function(t2) {
          this.property = t2, this.value = new Xn(t2, void 0);
        };
        Zn.prototype.transitioned = function(t2, e2) {
          return new Jn(this.property, this.value, e2, p({}, t2.transition, this.transition), t2.now);
        }, Zn.prototype.untransitioned = function() {
          return new Jn(this.property, this.value, null, {}, 0);
        };
        var Gn = function(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
        };
        Gn.prototype.getValue = function(t2) {
          return x(this._values[t2].value.value);
        }, Gn.prototype.setValue = function(t2, e2) {
          this._values.hasOwnProperty(t2) || (this._values[t2] = new Zn(this._values[t2].property)), this._values[t2].value = new Xn(this._values[t2].property, null === e2 ? void 0 : x(e2));
        }, Gn.prototype.getTransition = function(t2) {
          return x(this._values[t2].transition);
        }, Gn.prototype.setTransition = function(t2, e2) {
          this._values.hasOwnProperty(t2) || (this._values[t2] = new Zn(this._values[t2].property)), this._values[t2].transition = x(e2) || void 0;
        }, Gn.prototype.serialize = function() {
          for (var t2 = {}, e2 = 0, r2 = Object.keys(this._values); e2 < r2.length; e2 += 1) {
            var n2 = r2[e2], i2 = this.getValue(n2);
            void 0 !== i2 && (t2[n2] = i2);
            var a2 = this.getTransition(n2);
            void 0 !== a2 && (t2[n2 + "-transition"] = a2);
          }
          return t2;
        }, Gn.prototype.transitioned = function(t2, e2) {
          for (var r2 = new Hn(this._properties), n2 = 0, i2 = Object.keys(this._values); n2 < i2.length; n2 += 1) {
            var a2 = i2[n2];
            r2._values[a2] = this._values[a2].transitioned(t2, e2._values[a2]);
          }
          return r2;
        }, Gn.prototype.untransitioned = function() {
          for (var t2 = new Hn(this._properties), e2 = 0, r2 = Object.keys(this._values); e2 < r2.length; e2 += 1) {
            var n2 = r2[e2];
            t2._values[n2] = this._values[n2].untransitioned();
          }
          return t2;
        };
        var Jn = function(t2, e2, r2, n2, i2) {
          this.property = t2, this.value = e2, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
        };
        Jn.prototype.possiblyEvaluate = function(t2, e2) {
          var r2 = t2.now || 0, n2 = this.value.possiblyEvaluate(t2, e2), i2 = this.prior;
          if (i2) {
            if (r2 > this.end)
              return this.prior = null, n2;
            if (this.value.isDataDriven())
              return this.prior = null, n2;
            if (r2 < this.begin)
              return i2.possiblyEvaluate(t2, e2);
            var a2 = (r2 - this.begin) / (this.end - this.begin);
            return this.property.interpolate(i2.possiblyEvaluate(t2, e2), n2, function(t3) {
              if (t3 <= 0)
                return 0;
              if (t3 >= 1)
                return 1;
              var e3 = t3 * t3, r3 = e3 * t3;
              return 4 * (t3 < 0.5 ? r3 : 3 * (t3 - e3) + r3 - 0.75);
            }(a2));
          }
          return n2;
        };
        var Hn = function(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
        };
        Hn.prototype.possiblyEvaluate = function(t2, e2) {
          for (var r2 = new Wn(this._properties), n2 = 0, i2 = Object.keys(this._values); n2 < i2.length; n2 += 1) {
            var a2 = i2[n2];
            r2._values[a2] = this._values[a2].possiblyEvaluate(t2, e2);
          }
          return r2;
        }, Hn.prototype.hasTransition = function() {
          for (var t2 = 0, e2 = Object.keys(this._values); t2 < e2.length; t2 += 1) {
            var r2 = e2[t2];
            if (this._values[r2].prior)
              return true;
          }
          return false;
        };
        var Yn = function(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
        };
        Yn.prototype.getValue = function(t2) {
          return x(this._values[t2].value);
        }, Yn.prototype.setValue = function(t2, e2) {
          this._values[t2] = new Xn(this._values[t2].property, null === e2 ? void 0 : x(e2));
        }, Yn.prototype.serialize = function() {
          for (var t2 = {}, e2 = 0, r2 = Object.keys(this._values); e2 < r2.length; e2 += 1) {
            var n2 = r2[e2], i2 = this.getValue(n2);
            void 0 !== i2 && (t2[n2] = i2);
          }
          return t2;
        }, Yn.prototype.possiblyEvaluate = function(t2, e2) {
          for (var r2 = new Wn(this._properties), n2 = 0, i2 = Object.keys(this._values); n2 < i2.length; n2 += 1) {
            var a2 = i2[n2];
            r2._values[a2] = this._values[a2].possiblyEvaluate(t2, e2);
          }
          return r2;
        };
        var $n = function(t2, e2, r2) {
          this.property = t2, this.value = e2, this.parameters = r2;
        };
        $n.prototype.isConstant = function() {
          return "constant" === this.value.kind;
        }, $n.prototype.constantOr = function(t2) {
          return "constant" === this.value.kind ? this.value.value : t2;
        }, $n.prototype.evaluate = function(t2, e2, r2) {
          return this.property.evaluate(this.value, this.parameters, t2, e2, r2);
        };
        var Wn = function(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
        };
        Wn.prototype.get = function(t2) {
          return this._values[t2];
        };
        var Qn = function(t2) {
          this.specification = t2;
        };
        Qn.prototype.possiblyEvaluate = function(t2, e2) {
          return t2.expression.evaluate(e2);
        }, Qn.prototype.interpolate = function(t2, e2, r2) {
          var n2 = ke[this.specification.type];
          return n2 ? n2(t2, e2, r2) : t2;
        };
        var ti = function(t2, e2) {
          this.specification = t2, this.overrides = e2;
        };
        ti.prototype.possiblyEvaluate = function(t2, e2, r2) {
          return "constant" === t2.expression.kind || "camera" === t2.expression.kind ? new $n(this, { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2) }, e2) : new $n(this, t2.expression, e2);
        }, ti.prototype.interpolate = function(t2, e2, r2) {
          if ("constant" !== t2.value.kind || "constant" !== e2.value.kind)
            return t2;
          if (void 0 === t2.value.value || void 0 === e2.value.value)
            return new $n(this, { kind: "constant", value: void 0 }, t2.parameters);
          var n2 = ke[this.specification.type];
          return n2 ? new $n(this, { kind: "constant", value: n2(t2.value.value, e2.value.value, r2) }, t2.parameters) : t2;
        }, ti.prototype.evaluate = function(t2, e2, r2, n2, i2) {
          return "constant" === t2.kind ? t2.value : t2.evaluate(e2, r2, n2, i2);
        };
        var ei = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.possiblyEvaluate = function(t3, e3, r2) {
            if (void 0 === t3.value)
              return new $n(this, { kind: "constant", value: void 0 }, e3);
            if ("constant" === t3.expression.kind) {
              var n2 = t3.expression.evaluate(e3, null, {}, r2), i2 = "resolvedImage" === t3.property.specification.type && "string" != typeof n2 ? n2.name : n2, a2 = this._calculate(i2, i2, i2, e3);
              return new $n(this, { kind: "constant", value: a2 }, e3);
            }
            if ("camera" === t3.expression.kind) {
              var o2 = this._calculate(t3.expression.evaluate({ zoom: e3.zoom - 1 }), t3.expression.evaluate({ zoom: e3.zoom }), t3.expression.evaluate({ zoom: e3.zoom + 1 }), e3);
              return new $n(this, { kind: "constant", value: o2 }, e3);
            }
            return new $n(this, t3.expression, e3);
          }, e2.prototype.evaluate = function(t3, e3, r2, n2, i2) {
            if ("source" === t3.kind) {
              var a2 = t3.evaluate(e3, r2, n2, i2);
              return this._calculate(a2, a2, a2, e3);
            }
            return "composite" === t3.kind ? this._calculate(t3.evaluate({ zoom: Math.floor(e3.zoom) - 1 }, r2, n2), t3.evaluate({ zoom: Math.floor(e3.zoom) }, r2, n2), t3.evaluate({ zoom: Math.floor(e3.zoom) + 1 }, r2, n2), e3) : t3.value;
          }, e2.prototype._calculate = function(t3, e3, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t3, to: e3 } : { from: r2, to: e3 };
          }, e2.prototype.interpolate = function(t3) {
            return t3;
          }, e2;
        }(ti), ri = function(t2) {
          this.specification = t2;
        };
        ri.prototype.possiblyEvaluate = function(t2, e2, r2) {
          if (void 0 !== t2.value) {
            if ("constant" === t2.expression.kind) {
              var n2 = t2.expression.evaluate(e2, null, {}, r2);
              return this._calculate(n2, n2, n2, e2);
            }
            return this._calculate(t2.expression.evaluate(new Kn(Math.floor(e2.zoom - 1), e2)), t2.expression.evaluate(new Kn(Math.floor(e2.zoom), e2)), t2.expression.evaluate(new Kn(Math.floor(e2.zoom + 1), e2)), e2);
          }
        }, ri.prototype._calculate = function(t2, e2, r2, n2) {
          return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
        }, ri.prototype.interpolate = function(t2) {
          return t2;
        };
        var ni = function(t2) {
          this.specification = t2;
        };
        ni.prototype.possiblyEvaluate = function(t2, e2, r2) {
          return !!t2.expression.evaluate(e2, null, {}, r2);
        }, ni.prototype.interpolate = function() {
          return false;
        };
        var ii = function(t2) {
          for (var e2 in this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], t2) {
            var r2 = t2[e2];
            r2.specification.overridable && this.overridableProperties.push(e2);
            var n2 = this.defaultPropertyValues[e2] = new Xn(r2, void 0), i2 = this.defaultTransitionablePropertyValues[e2] = new Zn(r2);
            this.defaultTransitioningPropertyValues[e2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
          }
        };
        vn("DataDrivenProperty", ti), vn("DataConstantProperty", Qn), vn("CrossFadedDataDrivenProperty", ei), vn("CrossFadedProperty", ri), vn("ColorRampProperty", ni);
        var ai = function(t2) {
          function e2(e3, r2) {
            if (t2.call(this), this.id = e3.id, this.type = e3.type, this._featureFilter = function() {
              return true;
            }, "custom" !== e3.type && (e3 = e3, this.metadata = e3.metadata, this.minzoom = e3.minzoom, this.maxzoom = e3.maxzoom, "background" !== e3.type && (this.source = e3.source, this.sourceLayer = e3["source-layer"], this.filter = e3.filter), r2.layout && (this._unevaluatedLayout = new Yn(r2.layout)), r2.paint)) {
              for (var n2 in this._transitionablePaint = new Gn(r2.paint), e3.paint)
                this.setPaintProperty(n2, e3.paint[n2], { validate: false });
              for (var i2 in e3.layout)
                this.setLayoutProperty(i2, e3.layout[i2], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned();
            }
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getCrossfadeParameters = function() {
            return this._crossfadeParameters;
          }, e2.prototype.getLayoutProperty = function(t3) {
            return "visibility" === t3 ? this.visibility : this._unevaluatedLayout.getValue(t3);
          }, e2.prototype.setLayoutProperty = function(t3, e3, r2) {
            if (void 0 === r2 && (r2 = {}), null != e3) {
              var n2 = "layers." + this.id + ".layout." + t3;
              if (this._validate(pn, n2, t3, e3, r2))
                return;
            }
            "visibility" !== t3 ? this._unevaluatedLayout.setValue(t3, e3) : this.visibility = e3;
          }, e2.prototype.getPaintProperty = function(t3) {
            return m(t3, "-transition") ? this._transitionablePaint.getTransition(t3.slice(0, -"-transition".length)) : this._transitionablePaint.getValue(t3);
          }, e2.prototype.setPaintProperty = function(t3, e3, r2) {
            if (void 0 === r2 && (r2 = {}), null != e3) {
              var n2 = "layers." + this.id + ".paint." + t3;
              if (this._validate(ln, n2, t3, e3, r2))
                return false;
            }
            if (m(t3, "-transition"))
              return this._transitionablePaint.setTransition(t3.slice(0, -"-transition".length), e3 || void 0), false;
            var i2 = this._transitionablePaint._values[t3], a2 = "cross-faded-data-driven" === i2.property.specification["property-type"], o2 = i2.value.isDataDriven(), s2 = i2.value;
            this._transitionablePaint.setValue(t3, e3), this._handleSpecialPaintPropertyUpdate(t3);
            var u2 = this._transitionablePaint._values[t3].value;
            return u2.isDataDriven() || o2 || a2 || this._handleOverridablePaintPropertyUpdate(t3, s2, u2);
          }, e2.prototype._handleSpecialPaintPropertyUpdate = function(t3) {
          }, e2.prototype._handleOverridablePaintPropertyUpdate = function(t3, e3, r2) {
            return false;
          }, e2.prototype.isHidden = function(t3) {
            return !!(this.minzoom && t3 < this.minzoom) || (!!(this.maxzoom && t3 >= this.maxzoom) || "none" === this.visibility);
          }, e2.prototype.updateTransitions = function(t3) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t3, this._transitioningPaint);
          }, e2.prototype.hasTransition = function() {
            return this._transitioningPaint.hasTransition();
          }, e2.prototype.recalculate = function(t3, e3) {
            t3.getCrossfadeParameters && (this._crossfadeParameters = t3.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t3, e3)), this.paint = this._transitioningPaint.possiblyEvaluate(t3, e3);
          }, e2.prototype.serialize = function() {
            var t3 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t3.layout = t3.layout || {}, t3.layout.visibility = this.visibility), g(t3, function(t4, e3) {
              return !(void 0 === t4 || "layout" === e3 && !Object.keys(t4).length || "paint" === e3 && !Object.keys(t4).length);
            });
          }, e2.prototype._validate = function(t3, e3, r2, n2, i2) {
            return void 0 === i2 && (i2 = {}), (!i2 || false !== i2.validate) && cn(this, t3.call(sn, { key: e3, layerType: this.type, objectKey: r2, value: n2, styleSpec: Ct, style: { glyphs: true, sprite: true } }));
          }, e2.prototype.is3D = function() {
            return false;
          }, e2.prototype.isTileClipped = function() {
            return false;
          }, e2.prototype.hasOffscreenPass = function() {
            return false;
          }, e2.prototype.resize = function() {
          }, e2.prototype.isStateDependent = function() {
            for (var t3 in this.paint._values) {
              var e3 = this.paint.get(t3);
              if (e3 instanceof $n && hr(e3.property.specification) && (("source" === e3.value.kind || "composite" === e3.value.kind) && e3.value.isStateDependent))
                return true;
            }
            return false;
          }, e2;
        }(zt), oi = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }, si = function(t2, e2) {
          this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }, ui = function() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        };
        function li(t2, e2) {
          void 0 === e2 && (e2 = 1);
          var r2 = 0, n2 = 0;
          return { members: t2.map(function(t3) {
            var i2, a2 = (i2 = t3.type, oi[i2].BYTES_PER_ELEMENT), o2 = r2 = pi(r2, Math.max(e2, a2)), s2 = t3.components || 1;
            return n2 = Math.max(n2, a2), r2 += a2 * s2, { name: t3.name, type: t3.type, components: s2, offset: o2 };
          }), size: pi(r2, Math.max(n2, e2)), alignment: e2 };
        }
        function pi(t2, e2) {
          return Math.ceil(t2 / e2) * e2;
        }
        ui.serialize = function(t2, e2) {
          return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
        }, ui.deserialize = function(t2) {
          var e2 = Object.create(this.prototype);
          return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
        }, ui.prototype._trim = function() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }, ui.prototype.clear = function() {
          this.length = 0;
        }, ui.prototype.resize = function(t2) {
          this.reserve(t2), this.length = t2;
        }, ui.prototype.reserve = function(t2) {
          if (t2 > this.capacity) {
            this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            var e2 = this.uint8;
            this._refreshViews(), e2 && this.uint8.set(e2);
          }
        }, ui.prototype._refreshViews = function() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        };
        var ci = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3) {
            var r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t3, e3);
          }, e2.prototype.emplace = function(t3, e3, r2) {
            var n2 = 2 * t3;
            return this.int16[n2 + 0] = e3, this.int16[n2 + 1] = r2, t3;
          }, e2;
        }(ui);
        ci.prototype.bytesPerElement = 4, vn("StructArrayLayout2i4", ci);
        var hi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2, n2) {
            var i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t3, e3, r2, n2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2, i2) {
            var a2 = 4 * t3;
            return this.int16[a2 + 0] = e3, this.int16[a2 + 1] = r2, this.int16[a2 + 2] = n2, this.int16[a2 + 3] = i2, t3;
          }, e2;
        }(ui);
        hi.prototype.bytesPerElement = 8, vn("StructArrayLayout4i8", hi);
        var fi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2) {
            var o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t3, e3, r2, n2, i2, a2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2) {
            var s2 = 6 * t3;
            return this.int16[s2 + 0] = e3, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, this.int16[s2 + 4] = a2, this.int16[s2 + 5] = o2, t3;
          }, e2;
        }(ui);
        fi.prototype.bytesPerElement = 12, vn("StructArrayLayout2i4i12", fi);
        var yi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2) {
            var o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t3, e3, r2, n2, i2, a2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2) {
            var s2 = 4 * t3, u2 = 8 * t3;
            return this.int16[s2 + 0] = e3, this.int16[s2 + 1] = r2, this.uint8[u2 + 4] = n2, this.uint8[u2 + 5] = i2, this.uint8[u2 + 6] = a2, this.uint8[u2 + 7] = o2, t3;
          }, e2;
        }(ui);
        yi.prototype.bytesPerElement = 8, vn("StructArrayLayout2i4ub8", yi);
        var di = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2) {
            var u2 = this.length;
            return this.resize(u2 + 1), this.emplace(u2, t3, e3, r2, n2, i2, a2, o2, s2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2) {
            var l2 = 8 * t3;
            return this.uint16[l2 + 0] = e3, this.uint16[l2 + 1] = r2, this.uint16[l2 + 2] = n2, this.uint16[l2 + 3] = i2, this.uint16[l2 + 4] = a2, this.uint16[l2 + 5] = o2, this.uint16[l2 + 6] = s2, this.uint16[l2 + 7] = u2, t3;
          }, e2;
        }(ui);
        di.prototype.bytesPerElement = 16, vn("StructArrayLayout8ui16", di);
        var mi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2) {
            var h2 = this.length;
            return this.resize(h2 + 1), this.emplace(h2, t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2) {
            var f2 = 12 * t3;
            return this.int16[f2 + 0] = e3, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = a2, this.uint16[f2 + 5] = o2, this.uint16[f2 + 6] = s2, this.uint16[f2 + 7] = u2, this.int16[f2 + 8] = l2, this.int16[f2 + 9] = p2, this.int16[f2 + 10] = c2, this.int16[f2 + 11] = h2, t3;
          }, e2;
        }(ui);
        mi.prototype.bytesPerElement = 24, vn("StructArrayLayout4i4ui4i24", mi);
        var vi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2) {
            var n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t3, e3, r2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2) {
            var i2 = 3 * t3;
            return this.float32[i2 + 0] = e3, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t3;
          }, e2;
        }(ui);
        vi.prototype.bytesPerElement = 12, vn("StructArrayLayout3f12", vi);
        var gi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3) {
            var e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t3);
          }, e2.prototype.emplace = function(t3, e3) {
            var r2 = 1 * t3;
            return this.uint32[r2 + 0] = e3, t3;
          }, e2;
        }(ui);
        gi.prototype.bytesPerElement = 4, vn("StructArrayLayout1ul4", gi);
        var xi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2) {
            var c2 = this.length;
            return this.resize(c2 + 1), this.emplace(c2, t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2) {
            var h2 = 12 * t3, f2 = 6 * t3;
            return this.int16[h2 + 0] = e3, this.int16[h2 + 1] = r2, this.int16[h2 + 2] = n2, this.int16[h2 + 3] = i2, this.int16[h2 + 4] = a2, this.int16[h2 + 5] = o2, this.uint32[f2 + 3] = s2, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = l2, this.int16[h2 + 10] = p2, this.int16[h2 + 11] = c2, t3;
          }, e2;
        }(ui);
        xi.prototype.bytesPerElement = 24, vn("StructArrayLayout6i1ul2ui2i24", xi);
        var bi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2) {
            var o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t3, e3, r2, n2, i2, a2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2) {
            var s2 = 6 * t3;
            return this.int16[s2 + 0] = e3, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, this.int16[s2 + 4] = a2, this.int16[s2 + 5] = o2, t3;
          }, e2;
        }(ui);
        bi.prototype.bytesPerElement = 12, vn("StructArrayLayout2i2i2i12", bi);
        var _i = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2, n2) {
            var i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t3, e3, r2, n2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2, i2) {
            var a2 = 12 * t3, o2 = 3 * t3;
            return this.uint8[a2 + 0] = e3, this.uint8[a2 + 1] = r2, this.float32[o2 + 1] = n2, this.float32[o2 + 2] = i2, t3;
          }, e2;
        }(ui);
        _i.prototype.bytesPerElement = 12, vn("StructArrayLayout2ub2f12", _i);
        var wi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2) {
            var v2 = this.length;
            return this.resize(v2 + 1), this.emplace(v2, t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2, v2) {
            var g2 = 24 * t3, x2 = 12 * t3, b2 = 48 * t3;
            return this.int16[g2 + 0] = e3, this.int16[g2 + 1] = r2, this.uint16[g2 + 2] = n2, this.uint16[g2 + 3] = i2, this.uint32[x2 + 2] = a2, this.uint32[x2 + 3] = o2, this.uint32[x2 + 4] = s2, this.uint16[g2 + 10] = u2, this.uint16[g2 + 11] = l2, this.uint16[g2 + 12] = p2, this.float32[x2 + 7] = c2, this.float32[x2 + 8] = h2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = y2, this.uint8[b2 + 38] = d2, this.uint32[x2 + 10] = m2, this.int16[g2 + 22] = v2, t3;
          }, e2;
        }(ui);
        wi.prototype.bytesPerElement = 48, vn("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", wi);
        var Ai = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2, v2, g2, x2, b2, _2, w2, A2, S2, k2) {
            var I2 = this.length;
            return this.resize(I2 + 1), this.emplace(I2, t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2, v2, g2, x2, b2, _2, w2, A2, S2, k2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2, v2, g2, x2, b2, _2, w2, A2, S2, k2, I2) {
            var z2 = 30 * t3, C2 = 15 * t3;
            return this.int16[z2 + 0] = e3, this.int16[z2 + 1] = r2, this.int16[z2 + 2] = n2, this.int16[z2 + 3] = i2, this.int16[z2 + 4] = a2, this.int16[z2 + 5] = o2, this.int16[z2 + 6] = s2, this.int16[z2 + 7] = u2, this.uint16[z2 + 8] = l2, this.uint16[z2 + 9] = p2, this.uint16[z2 + 10] = c2, this.uint16[z2 + 11] = h2, this.uint16[z2 + 12] = f2, this.uint16[z2 + 13] = y2, this.uint16[z2 + 14] = d2, this.uint16[z2 + 15] = m2, this.uint16[z2 + 16] = v2, this.uint16[z2 + 17] = g2, this.uint16[z2 + 18] = x2, this.uint16[z2 + 19] = b2, this.uint16[z2 + 20] = _2, this.uint16[z2 + 21] = w2, this.uint32[C2 + 11] = A2, this.float32[C2 + 12] = S2, this.float32[C2 + 13] = k2, this.float32[C2 + 14] = I2, t3;
          }, e2;
        }(ui);
        Ai.prototype.bytesPerElement = 60, vn("StructArrayLayout8i14ui1ul3f60", Ai);
        var Si = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3) {
            var e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t3);
          }, e2.prototype.emplace = function(t3, e3) {
            var r2 = 1 * t3;
            return this.float32[r2 + 0] = e3, t3;
          }, e2;
        }(ui);
        Si.prototype.bytesPerElement = 4, vn("StructArrayLayout1f4", Si);
        var ki = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2) {
            var n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t3, e3, r2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2) {
            var i2 = 3 * t3;
            return this.int16[i2 + 0] = e3, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t3;
          }, e2;
        }(ui);
        ki.prototype.bytesPerElement = 6, vn("StructArrayLayout3i6", ki);
        var Ii = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2) {
            var n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t3, e3, r2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2) {
            var i2 = 2 * t3, a2 = 4 * t3;
            return this.uint32[i2 + 0] = e3, this.uint16[a2 + 2] = r2, this.uint16[a2 + 3] = n2, t3;
          }, e2;
        }(ui);
        Ii.prototype.bytesPerElement = 8, vn("StructArrayLayout1ul2ui8", Ii);
        var zi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2) {
            var n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t3, e3, r2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2) {
            var i2 = 3 * t3;
            return this.uint16[i2 + 0] = e3, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t3;
          }, e2;
        }(ui);
        zi.prototype.bytesPerElement = 6, vn("StructArrayLayout3ui6", zi);
        var Ci = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3) {
            var r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t3, e3);
          }, e2.prototype.emplace = function(t3, e3, r2) {
            var n2 = 2 * t3;
            return this.uint16[n2 + 0] = e3, this.uint16[n2 + 1] = r2, t3;
          }, e2;
        }(ui);
        Ci.prototype.bytesPerElement = 4, vn("StructArrayLayout2ui4", Ci);
        var Bi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3) {
            var e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t3);
          }, e2.prototype.emplace = function(t3, e3) {
            var r2 = 1 * t3;
            return this.uint16[r2 + 0] = e3, t3;
          }, e2;
        }(ui);
        Bi.prototype.bytesPerElement = 2, vn("StructArrayLayout1ui2", Bi);
        var Pi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3) {
            var r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t3, e3);
          }, e2.prototype.emplace = function(t3, e3, r2) {
            var n2 = 2 * t3;
            return this.float32[n2 + 0] = e3, this.float32[n2 + 1] = r2, t3;
          }, e2;
        }(ui);
        Pi.prototype.bytesPerElement = 8, vn("StructArrayLayout2f8", Pi);
        var Ti = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t3, e3, r2, n2) {
            var i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t3, e3, r2, n2);
          }, e2.prototype.emplace = function(t3, e3, r2, n2, i2) {
            var a2 = 4 * t3;
            return this.float32[a2 + 0] = e3, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.float32[a2 + 3] = i2, t3;
          }, e2;
        }(ui);
        Ti.prototype.bytesPerElement = 16, vn("StructArrayLayout4f16", Ti);
        var Ei = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2;
          var r2 = { anchorPointX: { configurable: true }, anchorPointY: { configurable: true }, x1: { configurable: true }, y1: { configurable: true }, x2: { configurable: true }, y2: { configurable: true }, featureIndex: { configurable: true }, sourceLayerIndex: { configurable: true }, bucketIndex: { configurable: true }, radius: { configurable: true }, signedDistanceFromAnchor: { configurable: true }, anchorPoint: { configurable: true } };
          return r2.anchorPointX.get = function() {
            return this._structArray.int16[this._pos2 + 0];
          }, r2.anchorPointX.set = function(t3) {
            this._structArray.int16[this._pos2 + 0] = t3;
          }, r2.anchorPointY.get = function() {
            return this._structArray.int16[this._pos2 + 1];
          }, r2.anchorPointY.set = function(t3) {
            this._structArray.int16[this._pos2 + 1] = t3;
          }, r2.x1.get = function() {
            return this._structArray.int16[this._pos2 + 2];
          }, r2.x1.set = function(t3) {
            this._structArray.int16[this._pos2 + 2] = t3;
          }, r2.y1.get = function() {
            return this._structArray.int16[this._pos2 + 3];
          }, r2.y1.set = function(t3) {
            this._structArray.int16[this._pos2 + 3] = t3;
          }, r2.x2.get = function() {
            return this._structArray.int16[this._pos2 + 4];
          }, r2.x2.set = function(t3) {
            this._structArray.int16[this._pos2 + 4] = t3;
          }, r2.y2.get = function() {
            return this._structArray.int16[this._pos2 + 5];
          }, r2.y2.set = function(t3) {
            this._structArray.int16[this._pos2 + 5] = t3;
          }, r2.featureIndex.get = function() {
            return this._structArray.uint32[this._pos4 + 3];
          }, r2.featureIndex.set = function(t3) {
            this._structArray.uint32[this._pos4 + 3] = t3;
          }, r2.sourceLayerIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 8];
          }, r2.sourceLayerIndex.set = function(t3) {
            this._structArray.uint16[this._pos2 + 8] = t3;
          }, r2.bucketIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 9];
          }, r2.bucketIndex.set = function(t3) {
            this._structArray.uint16[this._pos2 + 9] = t3;
          }, r2.radius.get = function() {
            return this._structArray.int16[this._pos2 + 10];
          }, r2.radius.set = function(t3) {
            this._structArray.int16[this._pos2 + 10] = t3;
          }, r2.signedDistanceFromAnchor.get = function() {
            return this._structArray.int16[this._pos2 + 11];
          }, r2.signedDistanceFromAnchor.set = function(t3) {
            this._structArray.int16[this._pos2 + 11] = t3;
          }, r2.anchorPoint.get = function() {
            return new i(this.anchorPointX, this.anchorPointY);
          }, Object.defineProperties(e2.prototype, r2), e2;
        }(si);
        Ei.prototype.size = 24;
        var Mi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.get = function(t3) {
            return new Ei(this, t3);
          }, e2;
        }(xi);
        vn("CollisionBoxArray", Mi);
        var Vi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2;
          var r2 = { anchorX: { configurable: true }, anchorY: { configurable: true }, glyphStartIndex: { configurable: true }, numGlyphs: { configurable: true }, vertexStartIndex: { configurable: true }, lineStartIndex: { configurable: true }, lineLength: { configurable: true }, segment: { configurable: true }, lowerSize: { configurable: true }, upperSize: { configurable: true }, lineOffsetX: { configurable: true }, lineOffsetY: { configurable: true }, writingMode: { configurable: true }, placedOrientation: { configurable: true }, hidden: { configurable: true }, crossTileID: { configurable: true }, associatedIconIndex: { configurable: true } };
          return r2.anchorX.get = function() {
            return this._structArray.int16[this._pos2 + 0];
          }, r2.anchorX.set = function(t3) {
            this._structArray.int16[this._pos2 + 0] = t3;
          }, r2.anchorY.get = function() {
            return this._structArray.int16[this._pos2 + 1];
          }, r2.anchorY.set = function(t3) {
            this._structArray.int16[this._pos2 + 1] = t3;
          }, r2.glyphStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 2];
          }, r2.glyphStartIndex.set = function(t3) {
            this._structArray.uint16[this._pos2 + 2] = t3;
          }, r2.numGlyphs.get = function() {
            return this._structArray.uint16[this._pos2 + 3];
          }, r2.numGlyphs.set = function(t3) {
            this._structArray.uint16[this._pos2 + 3] = t3;
          }, r2.vertexStartIndex.get = function() {
            return this._structArray.uint32[this._pos4 + 2];
          }, r2.vertexStartIndex.set = function(t3) {
            this._structArray.uint32[this._pos4 + 2] = t3;
          }, r2.lineStartIndex.get = function() {
            return this._structArray.uint32[this._pos4 + 3];
          }, r2.lineStartIndex.set = function(t3) {
            this._structArray.uint32[this._pos4 + 3] = t3;
          }, r2.lineLength.get = function() {
            return this._structArray.uint32[this._pos4 + 4];
          }, r2.lineLength.set = function(t3) {
            this._structArray.uint32[this._pos4 + 4] = t3;
          }, r2.segment.get = function() {
            return this._structArray.uint16[this._pos2 + 10];
          }, r2.segment.set = function(t3) {
            this._structArray.uint16[this._pos2 + 10] = t3;
          }, r2.lowerSize.get = function() {
            return this._structArray.uint16[this._pos2 + 11];
          }, r2.lowerSize.set = function(t3) {
            this._structArray.uint16[this._pos2 + 11] = t3;
          }, r2.upperSize.get = function() {
            return this._structArray.uint16[this._pos2 + 12];
          }, r2.upperSize.set = function(t3) {
            this._structArray.uint16[this._pos2 + 12] = t3;
          }, r2.lineOffsetX.get = function() {
            return this._structArray.float32[this._pos4 + 7];
          }, r2.lineOffsetX.set = function(t3) {
            this._structArray.float32[this._pos4 + 7] = t3;
          }, r2.lineOffsetY.get = function() {
            return this._structArray.float32[this._pos4 + 8];
          }, r2.lineOffsetY.set = function(t3) {
            this._structArray.float32[this._pos4 + 8] = t3;
          }, r2.writingMode.get = function() {
            return this._structArray.uint8[this._pos1 + 36];
          }, r2.writingMode.set = function(t3) {
            this._structArray.uint8[this._pos1 + 36] = t3;
          }, r2.placedOrientation.get = function() {
            return this._structArray.uint8[this._pos1 + 37];
          }, r2.placedOrientation.set = function(t3) {
            this._structArray.uint8[this._pos1 + 37] = t3;
          }, r2.hidden.get = function() {
            return this._structArray.uint8[this._pos1 + 38];
          }, r2.hidden.set = function(t3) {
            this._structArray.uint8[this._pos1 + 38] = t3;
          }, r2.crossTileID.get = function() {
            return this._structArray.uint32[this._pos4 + 10];
          }, r2.crossTileID.set = function(t3) {
            this._structArray.uint32[this._pos4 + 10] = t3;
          }, r2.associatedIconIndex.get = function() {
            return this._structArray.int16[this._pos2 + 22];
          }, r2.associatedIconIndex.set = function(t3) {
            this._structArray.int16[this._pos2 + 22] = t3;
          }, Object.defineProperties(e2.prototype, r2), e2;
        }(si);
        Vi.prototype.size = 48;
        var Fi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.get = function(t3) {
            return new Vi(this, t3);
          }, e2;
        }(wi);
        vn("PlacedSymbolArray", Fi);
        var Li = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2;
          var r2 = { anchorX: { configurable: true }, anchorY: { configurable: true }, rightJustifiedTextSymbolIndex: { configurable: true }, centerJustifiedTextSymbolIndex: { configurable: true }, leftJustifiedTextSymbolIndex: { configurable: true }, verticalPlacedTextSymbolIndex: { configurable: true }, placedIconSymbolIndex: { configurable: true }, verticalPlacedIconSymbolIndex: { configurable: true }, key: { configurable: true }, textBoxStartIndex: { configurable: true }, textBoxEndIndex: { configurable: true }, verticalTextBoxStartIndex: { configurable: true }, verticalTextBoxEndIndex: { configurable: true }, iconBoxStartIndex: { configurable: true }, iconBoxEndIndex: { configurable: true }, verticalIconBoxStartIndex: { configurable: true }, verticalIconBoxEndIndex: { configurable: true }, featureIndex: { configurable: true }, numHorizontalGlyphVertices: { configurable: true }, numVerticalGlyphVertices: { configurable: true }, numIconVertices: { configurable: true }, numVerticalIconVertices: { configurable: true }, crossTileID: { configurable: true }, textBoxScale: { configurable: true }, textOffset0: { configurable: true }, textOffset1: { configurable: true } };
          return r2.anchorX.get = function() {
            return this._structArray.int16[this._pos2 + 0];
          }, r2.anchorX.set = function(t3) {
            this._structArray.int16[this._pos2 + 0] = t3;
          }, r2.anchorY.get = function() {
            return this._structArray.int16[this._pos2 + 1];
          }, r2.anchorY.set = function(t3) {
            this._structArray.int16[this._pos2 + 1] = t3;
          }, r2.rightJustifiedTextSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 2];
          }, r2.rightJustifiedTextSymbolIndex.set = function(t3) {
            this._structArray.int16[this._pos2 + 2] = t3;
          }, r2.centerJustifiedTextSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 3];
          }, r2.centerJustifiedTextSymbolIndex.set = function(t3) {
            this._structArray.int16[this._pos2 + 3] = t3;
          }, r2.leftJustifiedTextSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 4];
          }, r2.leftJustifiedTextSymbolIndex.set = function(t3) {
            this._structArray.int16[this._pos2 + 4] = t3;
          }, r2.verticalPlacedTextSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 5];
          }, r2.verticalPlacedTextSymbolIndex.set = function(t3) {
            this._structArray.int16[this._pos2 + 5] = t3;
          }, r2.placedIconSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 6];
          }, r2.placedIconSymbolIndex.set = function(t3) {
            this._structArray.int16[this._pos2 + 6] = t3;
          }, r2.verticalPlacedIconSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 7];
          }, r2.verticalPlacedIconSymbolIndex.set = function(t3) {
            this._structArray.int16[this._pos2 + 7] = t3;
          }, r2.key.get = function() {
            return this._structArray.uint16[this._pos2 + 8];
          }, r2.key.set = function(t3) {
            this._structArray.uint16[this._pos2 + 8] = t3;
          }, r2.textBoxStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 9];
          }, r2.textBoxStartIndex.set = function(t3) {
            this._structArray.uint16[this._pos2 + 9] = t3;
          }, r2.textBoxEndIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 10];
          }, r2.textBoxEndIndex.set = function(t3) {
            this._structArray.uint16[this._pos2 + 10] = t3;
          }, r2.verticalTextBoxStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 11];
          }, r2.verticalTextBoxStartIndex.set = function(t3) {
            this._structArray.uint16[this._pos2 + 11] = t3;
          }, r2.verticalTextBoxEndIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 12];
          }, r2.verticalTextBoxEndIndex.set = function(t3) {
            this._structArray.uint16[this._pos2 + 12] = t3;
          }, r2.iconBoxStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 13];
          }, r2.iconBoxStartIndex.set = function(t3) {
            this._structArray.uint16[this._pos2 + 13] = t3;
          }, r2.iconBoxEndIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 14];
          }, r2.iconBoxEndIndex.set = function(t3) {
            this._structArray.uint16[this._pos2 + 14] = t3;
          }, r2.verticalIconBoxStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 15];
          }, r2.verticalIconBoxStartIndex.set = function(t3) {
            this._structArray.uint16[this._pos2 + 15] = t3;
          }, r2.verticalIconBoxEndIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 16];
          }, r2.verticalIconBoxEndIndex.set = function(t3) {
            this._structArray.uint16[this._pos2 + 16] = t3;
          }, r2.featureIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 17];
          }, r2.featureIndex.set = function(t3) {
            this._structArray.uint16[this._pos2 + 17] = t3;
          }, r2.numHorizontalGlyphVertices.get = function() {
            return this._structArray.uint16[this._pos2 + 18];
          }, r2.numHorizontalGlyphVertices.set = function(t3) {
            this._structArray.uint16[this._pos2 + 18] = t3;
          }, r2.numVerticalGlyphVertices.get = function() {
            return this._structArray.uint16[this._pos2 + 19];
          }, r2.numVerticalGlyphVertices.set = function(t3) {
            this._structArray.uint16[this._pos2 + 19] = t3;
          }, r2.numIconVertices.get = function() {
            return this._structArray.uint16[this._pos2 + 20];
          }, r2.numIconVertices.set = function(t3) {
            this._structArray.uint16[this._pos2 + 20] = t3;
          }, r2.numVerticalIconVertices.get = function() {
            return this._structArray.uint16[this._pos2 + 21];
          }, r2.numVerticalIconVertices.set = function(t3) {
            this._structArray.uint16[this._pos2 + 21] = t3;
          }, r2.crossTileID.get = function() {
            return this._structArray.uint32[this._pos4 + 11];
          }, r2.crossTileID.set = function(t3) {
            this._structArray.uint32[this._pos4 + 11] = t3;
          }, r2.textBoxScale.get = function() {
            return this._structArray.float32[this._pos4 + 12];
          }, r2.textBoxScale.set = function(t3) {
            this._structArray.float32[this._pos4 + 12] = t3;
          }, r2.textOffset0.get = function() {
            return this._structArray.float32[this._pos4 + 13];
          }, r2.textOffset0.set = function(t3) {
            this._structArray.float32[this._pos4 + 13] = t3;
          }, r2.textOffset1.get = function() {
            return this._structArray.float32[this._pos4 + 14];
          }, r2.textOffset1.set = function(t3) {
            this._structArray.float32[this._pos4 + 14] = t3;
          }, Object.defineProperties(e2.prototype, r2), e2;
        }(si);
        Li.prototype.size = 60;
        var Oi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.get = function(t3) {
            return new Li(this, t3);
          }, e2;
        }(Ai);
        vn("SymbolInstanceArray", Oi);
        var Di = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2;
          var r2 = { offsetX: { configurable: true } };
          return r2.offsetX.get = function() {
            return this._structArray.float32[this._pos4 + 0];
          }, r2.offsetX.set = function(t3) {
            this._structArray.float32[this._pos4 + 0] = t3;
          }, Object.defineProperties(e2.prototype, r2), e2;
        }(si);
        Di.prototype.size = 4;
        var Ri = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getoffsetX = function(t3) {
            return this.float32[1 * t3 + 0];
          }, e2.prototype.get = function(t3) {
            return new Di(this, t3);
          }, e2;
        }(Si);
        vn("GlyphOffsetArray", Ri);
        var Ui = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2;
          var r2 = { x: { configurable: true }, y: { configurable: true }, tileUnitDistanceFromAnchor: { configurable: true } };
          return r2.x.get = function() {
            return this._structArray.int16[this._pos2 + 0];
          }, r2.x.set = function(t3) {
            this._structArray.int16[this._pos2 + 0] = t3;
          }, r2.y.get = function() {
            return this._structArray.int16[this._pos2 + 1];
          }, r2.y.set = function(t3) {
            this._structArray.int16[this._pos2 + 1] = t3;
          }, r2.tileUnitDistanceFromAnchor.get = function() {
            return this._structArray.int16[this._pos2 + 2];
          }, r2.tileUnitDistanceFromAnchor.set = function(t3) {
            this._structArray.int16[this._pos2 + 2] = t3;
          }, Object.defineProperties(e2.prototype, r2), e2;
        }(si);
        Ui.prototype.size = 6;
        var ji = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getx = function(t3) {
            return this.int16[3 * t3 + 0];
          }, e2.prototype.gety = function(t3) {
            return this.int16[3 * t3 + 1];
          }, e2.prototype.gettileUnitDistanceFromAnchor = function(t3) {
            return this.int16[3 * t3 + 2];
          }, e2.prototype.get = function(t3) {
            return new Ui(this, t3);
          }, e2;
        }(ki);
        vn("SymbolLineVertexArray", ji);
        var qi = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2;
          var r2 = { featureIndex: { configurable: true }, sourceLayerIndex: { configurable: true }, bucketIndex: { configurable: true } };
          return r2.featureIndex.get = function() {
            return this._structArray.uint32[this._pos4 + 0];
          }, r2.featureIndex.set = function(t3) {
            this._structArray.uint32[this._pos4 + 0] = t3;
          }, r2.sourceLayerIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 2];
          }, r2.sourceLayerIndex.set = function(t3) {
            this._structArray.uint16[this._pos2 + 2] = t3;
          }, r2.bucketIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 3];
          }, r2.bucketIndex.set = function(t3) {
            this._structArray.uint16[this._pos2 + 3] = t3;
          }, Object.defineProperties(e2.prototype, r2), e2;
        }(si);
        qi.prototype.size = 8;
        var Ni = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.get = function(t3) {
            return new qi(this, t3);
          }, e2;
        }(Ii);
        vn("FeatureIndexArray", Ni);
        var Ki = li([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, Xi = function(t2) {
          void 0 === t2 && (t2 = []), this.segments = t2;
        };
        function Zi(t2, e2) {
          return 256 * (t2 = u(Math.floor(t2), 0, 255)) + (e2 = u(Math.floor(e2), 0, 255));
        }
        Xi.prototype.prepareSegment = function(t2, e2, r2, n2) {
          var i2 = this.segments[this.segments.length - 1];
          return t2 > Xi.MAX_VERTEX_ARRAY_LENGTH && _("Max vertices per segment is " + Xi.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + t2), (!i2 || i2.vertexLength + t2 > Xi.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i2.sortKey = n2), this.segments.push(i2)), i2;
        }, Xi.prototype.get = function() {
          return this.segments;
        }, Xi.prototype.destroy = function() {
          for (var t2 = 0, e2 = this.segments; t2 < e2.length; t2 += 1) {
            var r2 = e2[t2];
            for (var n2 in r2.vaos)
              r2.vaos[n2].destroy();
          }
        }, Xi.simpleSegment = function(t2, e2, r2, n2) {
          return new Xi([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
        }, Xi.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, vn("SegmentVector", Xi);
        var Gi = e(function(t2) {
          t2.exports = function(t3, e2) {
            var r2, n2, i2, a2, o2, s2, u2, l2;
            for (r2 = 3 & t3.length, n2 = t3.length - r2, i2 = e2, o2 = 3432918353, s2 = 461845907, l2 = 0; l2 < n2; )
              u2 = 255 & t3.charCodeAt(l2) | (255 & t3.charCodeAt(++l2)) << 8 | (255 & t3.charCodeAt(++l2)) << 16 | (255 & t3.charCodeAt(++l2)) << 24, ++l2, i2 = 27492 + (65535 & (a2 = 5 * (65535 & (i2 = (i2 ^= u2 = (65535 & (u2 = (u2 = (65535 & u2) * o2 + (((u2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 15 | u2 >>> 17)) * s2 + (((u2 >>> 16) * s2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a2 >>> 16) & 65535) << 16);
            switch (u2 = 0, r2) {
              case 3:
                u2 ^= (255 & t3.charCodeAt(l2 + 2)) << 16;
              case 2:
                u2 ^= (255 & t3.charCodeAt(l2 + 1)) << 8;
              case 1:
                i2 ^= u2 = (65535 & (u2 = (u2 = (65535 & (u2 ^= 255 & t3.charCodeAt(l2))) * o2 + (((u2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 15 | u2 >>> 17)) * s2 + (((u2 >>> 16) * s2 & 65535) << 16) & 4294967295;
            }
            return i2 ^= t3.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
          };
        }), Ji = e(function(t2) {
          t2.exports = function(t3, e2) {
            for (var r2, n2 = t3.length, i2 = e2 ^ n2, a2 = 0; n2 >= 4; )
              r2 = 1540483477 * (65535 & (r2 = 255 & t3.charCodeAt(a2) | (255 & t3.charCodeAt(++a2)) << 8 | (255 & t3.charCodeAt(++a2)) << 16 | (255 & t3.charCodeAt(++a2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++a2;
            switch (n2) {
              case 3:
                i2 ^= (255 & t3.charCodeAt(a2 + 2)) << 16;
              case 2:
                i2 ^= (255 & t3.charCodeAt(a2 + 1)) << 8;
              case 1:
                i2 = 1540483477 * (65535 & (i2 ^= 255 & t3.charCodeAt(a2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
            }
            return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
          };
        }), Hi = Gi, Yi = Gi, $i = Ji;
        Hi.murmur3 = Yi, Hi.murmur2 = $i;
        var Wi = function() {
          this.ids = [], this.positions = [], this.indexed = false;
        };
        Wi.prototype.add = function(t2, e2, r2, n2) {
          this.ids.push(ta(t2)), this.positions.push(e2, r2, n2);
        }, Wi.prototype.getPositions = function(t2) {
          for (var e2 = ta(t2), r2 = 0, n2 = this.ids.length - 1; r2 < n2; ) {
            var i2 = r2 + n2 >> 1;
            this.ids[i2] >= e2 ? n2 = i2 : r2 = i2 + 1;
          }
          for (var a2 = []; this.ids[r2] === e2; ) {
            var o2 = this.positions[3 * r2], s2 = this.positions[3 * r2 + 1], u2 = this.positions[3 * r2 + 2];
            a2.push({ index: o2, start: s2, end: u2 }), r2++;
          }
          return a2;
        }, Wi.serialize = function(t2, e2) {
          var r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
          return function t3(e3, r3, n3, i2) {
            if (n3 >= i2)
              return;
            var a2 = e3[n3 + i2 >> 1], o2 = n3 - 1, s2 = i2 + 1;
            for (; ; ) {
              do {
                o2++;
              } while (e3[o2] < a2);
              do {
                s2--;
              } while (e3[s2] > a2);
              if (o2 >= s2)
                break;
              ea(e3, o2, s2), ea(r3, 3 * o2, 3 * s2), ea(r3, 3 * o2 + 1, 3 * s2 + 1), ea(r3, 3 * o2 + 2, 3 * s2 + 2);
            }
            t3(e3, r3, n3, s2), t3(e3, r3, s2 + 1, i2);
          }(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
        }, Wi.deserialize = function(t2) {
          var e2 = new Wi();
          return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
        };
        var Qi = Math.pow(2, 53) - 1;
        function ta(t2) {
          var e2 = +t2;
          return !isNaN(e2) && e2 <= Qi ? e2 : Hi(String(t2));
        }
        function ea(t2, e2, r2) {
          var n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        vn("FeaturePositionMap", Wi);
        var ra = function(t2, e2) {
          this.gl = t2.gl, this.location = e2;
        }, na = function(t2) {
          function e2(e3, r2) {
            t2.call(this, e3, r2), this.current = 0;
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.set = function(t3) {
            this.current !== t3 && (this.current = t3, this.gl.uniform1i(this.location, t3));
          }, e2;
        }(ra), ia = function(t2) {
          function e2(e3, r2) {
            t2.call(this, e3, r2), this.current = 0;
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.set = function(t3) {
            this.current !== t3 && (this.current = t3, this.gl.uniform1f(this.location, t3));
          }, e2;
        }(ra), aa = function(t2) {
          function e2(e3, r2) {
            t2.call(this, e3, r2), this.current = [0, 0];
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.set = function(t3) {
            t3[0] === this.current[0] && t3[1] === this.current[1] || (this.current = t3, this.gl.uniform2f(this.location, t3[0], t3[1]));
          }, e2;
        }(ra), oa = function(t2) {
          function e2(e3, r2) {
            t2.call(this, e3, r2), this.current = [0, 0, 0];
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.set = function(t3) {
            t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] || (this.current = t3, this.gl.uniform3f(this.location, t3[0], t3[1], t3[2]));
          }, e2;
        }(ra), sa = function(t2) {
          function e2(e3, r2) {
            t2.call(this, e3, r2), this.current = [0, 0, 0, 0];
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.set = function(t3) {
            t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] && t3[3] === this.current[3] || (this.current = t3, this.gl.uniform4f(this.location, t3[0], t3[1], t3[2], t3[3]));
          }, e2;
        }(ra), ua = function(t2) {
          function e2(e3, r2) {
            t2.call(this, e3, r2), this.current = $t.transparent;
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.set = function(t3) {
            t3.r === this.current.r && t3.g === this.current.g && t3.b === this.current.b && t3.a === this.current.a || (this.current = t3, this.gl.uniform4f(this.location, t3.r, t3.g, t3.b, t3.a));
          }, e2;
        }(ra), la = new Float32Array(16), pa = function(t2) {
          function e2(e3, r2) {
            t2.call(this, e3, r2), this.current = la;
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.set = function(t3) {
            if (t3[12] !== this.current[12] || t3[0] !== this.current[0])
              return this.current = t3, void this.gl.uniformMatrix4fv(this.location, false, t3);
            for (var e3 = 1; e3 < 16; e3++)
              if (t3[e3] !== this.current[e3]) {
                this.current = t3, this.gl.uniformMatrix4fv(this.location, false, t3);
                break;
              }
          }, e2;
        }(ra);
        function ca(t2) {
          return [Zi(255 * t2.r, 255 * t2.g), Zi(255 * t2.b, 255 * t2.a)];
        }
        var ha = function(t2, e2, r2) {
          this.value = t2, this.names = e2, this.uniformNames = this.names.map(function(t3) {
            return "u_" + t3;
          }), this.type = r2, this.maxValue = -1 / 0;
        };
        ha.prototype.defines = function() {
          return this.names.map(function(t2) {
            return "#define HAS_UNIFORM_u_" + t2;
          });
        }, ha.prototype.setConstantPatternPositions = function() {
        }, ha.prototype.populatePaintArray = function() {
        }, ha.prototype.updatePaintArray = function() {
        }, ha.prototype.upload = function() {
        }, ha.prototype.destroy = function() {
        }, ha.prototype.setUniforms = function(t2, e2, r2, n2) {
          e2.set(n2.constantOr(this.value));
        }, ha.prototype.getBinding = function(t2, e2) {
          return "color" === this.type ? new ua(t2, e2) : new ia(t2, e2);
        }, ha.serialize = function(t2) {
          var e2 = t2.value, r2 = t2.names, n2 = t2.type;
          return { value: _n(e2), names: r2, type: n2 };
        }, ha.deserialize = function(t2) {
          var e2 = t2.value, r2 = t2.names, n2 = t2.type;
          return new ha(wn(e2), r2, n2);
        };
        var fa = function(t2, e2, r2) {
          this.value = t2, this.names = e2, this.uniformNames = this.names.map(function(t3) {
            return "u_" + t3;
          }), this.type = r2, this.maxValue = -1 / 0, this.patternPositions = { patternTo: null, patternFrom: null };
        };
        fa.prototype.defines = function() {
          return this.names.map(function(t2) {
            return "#define HAS_UNIFORM_u_" + t2;
          });
        }, fa.prototype.populatePaintArray = function() {
        }, fa.prototype.updatePaintArray = function() {
        }, fa.prototype.upload = function() {
        }, fa.prototype.destroy = function() {
        }, fa.prototype.setConstantPatternPositions = function(t2, e2) {
          this.patternPositions.patternTo = t2.tlbr, this.patternPositions.patternFrom = e2.tlbr;
        }, fa.prototype.setUniforms = function(t2, e2, r2, n2, i2) {
          var a2 = this.patternPositions;
          "u_pattern_to" === i2 && a2.patternTo && e2.set(a2.patternTo), "u_pattern_from" === i2 && a2.patternFrom && e2.set(a2.patternFrom);
        }, fa.prototype.getBinding = function(t2, e2) {
          return new sa(t2, e2);
        };
        var ya = function(t2, e2, r2, n2) {
          this.expression = t2, this.names = e2, this.type = r2, this.uniformNames = this.names.map(function(t3) {
            return "a_" + t3;
          }), this.maxValue = -1 / 0, this.paintVertexAttributes = e2.map(function(t3) {
            return { name: "a_" + t3, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 };
          }), this.paintVertexArray = new n2();
        };
        ya.prototype.defines = function() {
          return [];
        }, ya.prototype.setConstantPatternPositions = function() {
        }, ya.prototype.populatePaintArray = function(t2, e2, r2, n2) {
          var i2 = this.paintVertexArray, a2 = i2.length;
          i2.reserve(t2);
          var o2 = this.expression.evaluate(new Kn(0), e2, {}, [], n2);
          if ("color" === this.type)
            for (var s2 = ca(o2), u2 = a2; u2 < t2; u2++)
              i2.emplaceBack(s2[0], s2[1]);
          else {
            for (var l2 = a2; l2 < t2; l2++)
              i2.emplaceBack(o2);
            this.maxValue = Math.max(this.maxValue, o2);
          }
        }, ya.prototype.updatePaintArray = function(t2, e2, r2, n2) {
          var i2 = this.paintVertexArray, a2 = this.expression.evaluate({ zoom: 0 }, r2, n2);
          if ("color" === this.type)
            for (var o2 = ca(a2), s2 = t2; s2 < e2; s2++)
              i2.emplace(s2, o2[0], o2[1]);
          else {
            for (var u2 = t2; u2 < e2; u2++)
              i2.emplace(u2, a2);
            this.maxValue = Math.max(this.maxValue, a2);
          }
        }, ya.prototype.upload = function(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }, ya.prototype.destroy = function() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }, ya.prototype.setUniforms = function(t2, e2) {
          e2.set(0);
        }, ya.prototype.getBinding = function(t2, e2) {
          return new ia(t2, e2);
        };
        var da = function(t2, e2, r2, n2, i2, a2) {
          this.expression = t2, this.names = e2, this.uniformNames = this.names.map(function(t3) {
            return "u_" + t3 + "_t";
          }), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = -1 / 0;
          var o2 = a2;
          this.paintVertexAttributes = e2.map(function(t3) {
            return { name: "a_" + t3, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 };
          }), this.paintVertexArray = new o2();
        };
        da.prototype.defines = function() {
          return [];
        }, da.prototype.setConstantPatternPositions = function() {
        }, da.prototype.populatePaintArray = function(t2, e2, r2, n2) {
          var i2 = this.paintVertexArray, a2 = i2.length;
          i2.reserve(t2);
          var o2 = this.expression.evaluate(new Kn(this.zoom), e2, {}, [], n2), s2 = this.expression.evaluate(new Kn(this.zoom + 1), e2, {}, [], n2);
          if ("color" === this.type)
            for (var u2 = ca(o2), l2 = ca(s2), p2 = a2; p2 < t2; p2++)
              i2.emplaceBack(u2[0], u2[1], l2[0], l2[1]);
          else {
            for (var c2 = a2; c2 < t2; c2++)
              i2.emplaceBack(o2, s2);
            this.maxValue = Math.max(this.maxValue, o2, s2);
          }
        }, da.prototype.updatePaintArray = function(t2, e2, r2, n2) {
          var i2 = this.paintVertexArray, a2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), o2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
          if ("color" === this.type)
            for (var s2 = ca(a2), u2 = ca(o2), l2 = t2; l2 < e2; l2++)
              i2.emplace(l2, s2[0], s2[1], u2[0], u2[1]);
          else {
            for (var p2 = t2; p2 < e2; p2++)
              i2.emplace(p2, a2, o2);
            this.maxValue = Math.max(this.maxValue, a2, o2);
          }
        }, da.prototype.upload = function(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }, da.prototype.destroy = function() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }, da.prototype.interpolationFactor = function(t2) {
          return this.useIntegerZoom && (t2 = Math.floor(t2)), u(this.expression.interpolationFactor(t2, this.zoom, this.zoom + 1), 0, 1);
        }, da.prototype.setUniforms = function(t2, e2, r2) {
          e2.set(this.interpolationFactor(r2.zoom));
        }, da.prototype.getBinding = function(t2, e2) {
          return new ia(t2, e2);
        };
        var ma = function(t2, e2, r2, n2, i2, a2, o2) {
          this.expression = t2, this.names = e2, this.type = r2, this.uniformNames = this.names.map(function(t3) {
            return "u_" + t3 + "_t";
          }), this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = -1 / 0, this.layerId = o2, this.paintVertexAttributes = e2.map(function(t3) {
            return { name: "a_" + t3, type: "Uint16", components: 4, offset: 0 };
          }), this.zoomInPaintVertexArray = new a2(), this.zoomOutPaintVertexArray = new a2();
        };
        ma.prototype.defines = function() {
          return [];
        }, ma.prototype.setConstantPatternPositions = function() {
        }, ma.prototype.populatePaintArray = function(t2, e2, r2) {
          var n2 = this.zoomInPaintVertexArray, i2 = this.zoomOutPaintVertexArray, a2 = this.layerId, o2 = n2.length;
          if (n2.reserve(t2), i2.reserve(t2), r2 && e2.patterns && e2.patterns[a2]) {
            var s2 = e2.patterns[a2], u2 = s2.min, l2 = s2.mid, p2 = s2.max, c2 = r2[u2], h2 = r2[l2], f2 = r2[p2];
            if (!c2 || !h2 || !f2)
              return;
            for (var y2 = o2; y2 < t2; y2++)
              n2.emplaceBack(h2.tl[0], h2.tl[1], h2.br[0], h2.br[1], c2.tl[0], c2.tl[1], c2.br[0], c2.br[1]), i2.emplaceBack(h2.tl[0], h2.tl[1], h2.br[0], h2.br[1], f2.tl[0], f2.tl[1], f2.br[0], f2.br[1]);
          }
        }, ma.prototype.updatePaintArray = function(t2, e2, r2, n2, i2) {
          var a2 = this.zoomInPaintVertexArray, o2 = this.zoomOutPaintVertexArray, s2 = this.layerId;
          if (i2 && r2.patterns && r2.patterns[s2]) {
            var u2 = r2.patterns[s2], l2 = u2.min, p2 = u2.mid, c2 = u2.max, h2 = i2[l2], f2 = i2[p2], y2 = i2[c2];
            if (!h2 || !f2 || !y2)
              return;
            for (var d2 = t2; d2 < e2; d2++)
              a2.emplace(d2, f2.tl[0], f2.tl[1], f2.br[0], f2.br[1], h2.tl[0], h2.tl[1], h2.br[0], h2.br[1]), o2.emplace(d2, f2.tl[0], f2.tl[1], f2.br[0], f2.br[1], y2.tl[0], y2.tl[1], y2.br[0], y2.br[1]);
          }
        }, ma.prototype.upload = function(t2) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }, ma.prototype.destroy = function() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }, ma.prototype.setUniforms = function(t2, e2) {
          e2.set(0);
        }, ma.prototype.getBinding = function(t2, e2) {
          return new ia(t2, e2);
        };
        var va = function() {
          this.binders = {}, this.cacheKey = "", this._buffers = [];
        };
        va.createDynamic = function(t2, e2, r2) {
          var n2 = new va(), i2 = [];
          for (var a2 in t2.paint._values)
            if (r2(a2)) {
              var o2 = t2.paint.get(a2);
              if (o2 instanceof $n && hr(o2.property.specification)) {
                var s2 = xa(a2, t2.type), u2 = o2.property.specification.type, l2 = o2.property.useIntegerZoom;
                if ("cross-faded" === o2.property.specification["property-type"] || "cross-faded-data-driven" === o2.property.specification["property-type"])
                  if ("constant" === o2.value.kind)
                    n2.binders[a2] = new fa(o2.value.value, s2, u2), i2.push("/u_" + a2);
                  else {
                    var p2 = ba(a2, u2, "source");
                    n2.binders[a2] = new ma(o2.value, s2, u2, l2, e2, p2, t2.id), i2.push("/a_" + a2);
                  }
                else if ("constant" === o2.value.kind)
                  n2.binders[a2] = new ha(o2.value.value, s2, u2), i2.push("/u_" + a2);
                else if ("source" === o2.value.kind) {
                  var c2 = ba(a2, u2, "source");
                  n2.binders[a2] = new ya(o2.value, s2, u2, c2), i2.push("/a_" + a2);
                } else {
                  var h2 = ba(a2, u2, "composite");
                  n2.binders[a2] = new da(o2.value, s2, u2, l2, e2, h2), i2.push("/z_" + a2);
                }
              }
            }
          return n2.cacheKey = i2.sort().join(""), n2;
        }, va.prototype.populatePaintArrays = function(t2, e2, r2, n2, i2) {
          for (var a2 in this.binders) {
            this.binders[a2].populatePaintArray(t2, e2, n2, i2);
          }
        }, va.prototype.setConstantPatternPositions = function(t2, e2) {
          for (var r2 in this.binders) {
            this.binders[r2].setConstantPatternPositions(t2, e2);
          }
        }, va.prototype.updatePaintArrays = function(t2, e2, r2, n2, i2) {
          var a2 = false;
          for (var o2 in t2)
            for (var s2 = 0, u2 = e2.getPositions(o2); s2 < u2.length; s2 += 1) {
              var l2 = u2[s2], p2 = r2.feature(l2.index);
              for (var c2 in this.binders) {
                var h2 = this.binders[c2];
                if (!(h2 instanceof ha || h2 instanceof fa) && true === h2.expression.isStateDependent) {
                  var f2 = n2.paint.get(c2);
                  h2.expression = f2.value, h2.updatePaintArray(l2.start, l2.end, p2, t2[o2], i2), a2 = true;
                }
              }
            }
          return a2;
        }, va.prototype.defines = function() {
          var t2 = [];
          for (var e2 in this.binders)
            t2.push.apply(t2, this.binders[e2].defines());
          return t2;
        }, va.prototype.getPaintVertexBuffers = function() {
          return this._buffers;
        }, va.prototype.getUniforms = function(t2, e2) {
          var r2 = [];
          for (var n2 in this.binders)
            for (var i2 = this.binders[n2], a2 = 0, o2 = i2.uniformNames; a2 < o2.length; a2 += 1) {
              var s2 = o2[a2];
              if (e2[s2]) {
                var u2 = i2.getBinding(t2, e2[s2]);
                r2.push({ name: s2, property: n2, binding: u2 });
              }
            }
          return r2;
        }, va.prototype.setUniforms = function(t2, e2, r2, n2) {
          for (var i2 = 0, a2 = e2; i2 < a2.length; i2 += 1) {
            var o2 = a2[i2], s2 = o2.name, u2 = o2.property, l2 = o2.binding;
            this.binders[u2].setUniforms(t2, l2, n2, r2.get(u2), s2);
          }
        }, va.prototype.updatePatternPaintBuffers = function(t2) {
          var e2 = [];
          for (var r2 in this.binders) {
            var n2 = this.binders[r2];
            if (n2 instanceof ma) {
              var i2 = 2 === t2.fromScale ? n2.zoomInPaintVertexBuffer : n2.zoomOutPaintVertexBuffer;
              i2 && e2.push(i2);
            } else
              (n2 instanceof ya || n2 instanceof da) && n2.paintVertexBuffer && e2.push(n2.paintVertexBuffer);
          }
          this._buffers = e2;
        }, va.prototype.upload = function(t2) {
          for (var e2 in this.binders)
            this.binders[e2].upload(t2);
          var r2 = [];
          for (var n2 in this.binders) {
            var i2 = this.binders[n2];
            (i2 instanceof ya || i2 instanceof da) && i2.paintVertexBuffer && r2.push(i2.paintVertexBuffer);
          }
          this._buffers = r2;
        }, va.prototype.destroy = function() {
          for (var t2 in this.binders)
            this.binders[t2].destroy();
        };
        var ga = function(t2, e2, r2, n2) {
          void 0 === n2 && (n2 = function() {
            return true;
          }), this.programConfigurations = {};
          for (var i2 = 0, a2 = e2; i2 < a2.length; i2 += 1) {
            var o2 = a2[i2];
            this.programConfigurations[o2.id] = va.createDynamic(o2, r2, n2), this.programConfigurations[o2.id].layoutAttributes = t2;
          }
          this.needsUpload = false, this._featureMap = new Wi(), this._bufferOffset = 0;
        };
        function xa(t2, e2) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from"], "fill-pattern": ["pattern_to", "pattern_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from"] }[t2] || [t2.replace(e2 + "-", "").replace(/-/g, "_")];
        }
        function ba(t2, e2, r2) {
          var n2 = { color: { source: Pi, composite: Ti }, number: { source: Si, composite: Pi } }, i2 = function(t3) {
            return { "line-pattern": { source: di, composite: di }, "fill-pattern": { source: di, composite: di }, "fill-extrusion-pattern": { source: di, composite: di } }[t3];
          }(t2);
          return i2 && i2[r2] || n2[e2][r2];
        }
        ga.prototype.populatePaintArrays = function(t2, e2, r2, n2, i2) {
          for (var a2 in this.programConfigurations)
            this.programConfigurations[a2].populatePaintArrays(t2, e2, r2, n2, i2);
          void 0 !== e2.id && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
        }, ga.prototype.updatePaintArrays = function(t2, e2, r2, n2) {
          for (var i2 = 0, a2 = r2; i2 < a2.length; i2 += 1) {
            var o2 = a2[i2];
            this.needsUpload = this.programConfigurations[o2.id].updatePaintArrays(t2, this._featureMap, e2, o2, n2) || this.needsUpload;
          }
        }, ga.prototype.get = function(t2) {
          return this.programConfigurations[t2];
        }, ga.prototype.upload = function(t2) {
          if (this.needsUpload) {
            for (var e2 in this.programConfigurations)
              this.programConfigurations[e2].upload(t2);
            this.needsUpload = false;
          }
        }, ga.prototype.destroy = function() {
          for (var t2 in this.programConfigurations)
            this.programConfigurations[t2].destroy();
        }, vn("ConstantBinder", ha), vn("CrossFadedConstantBinder", fa), vn("SourceExpressionBinder", ya), vn("CrossFadedCompositeBinder", ma), vn("CompositeExpressionBinder", da), vn("ProgramConfiguration", va, { omit: ["_buffers"] }), vn("ProgramConfigurationSet", ga);
        var _a, wa = (_a = 15, { min: -1 * Math.pow(2, _a - 1), max: Math.pow(2, _a - 1) - 1 });
        function Aa(t2) {
          for (var e2 = 8192 / t2.extent, r2 = t2.loadGeometry(), n2 = 0; n2 < r2.length; n2++)
            for (var i2 = r2[n2], a2 = 0; a2 < i2.length; a2++) {
              var o2 = i2[a2];
              o2.x = Math.round(o2.x * e2), o2.y = Math.round(o2.y * e2), (o2.x < wa.min || o2.x > wa.max || o2.y < wa.min || o2.y > wa.max) && (_("Geometry exceeds allowed extent, reduce your vector tile buffer size"), o2.x = u(o2.x, wa.min, wa.max), o2.y = u(o2.y, wa.min, wa.max));
            }
          return r2;
        }
        function Sa(t2, e2, r2, n2, i2) {
          t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
        }
        var ka = function(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
            return t3.id;
          }), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new ci(), this.indexArray = new zi(), this.segments = new Xi(), this.programConfigurations = new ga(Ki, t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter(function(t3) {
            return t3.isStateDependent();
          }).map(function(t3) {
            return t3.id;
          });
        };
        function Ia(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            if (Fa(e2, t2[r2]))
              return true;
          for (var n2 = 0; n2 < e2.length; n2++)
            if (Fa(t2, e2[n2]))
              return true;
          return !!Pa(t2, e2);
        }
        function za(t2, e2, r2) {
          return !!Fa(t2, e2) || !!Ea(e2, t2, r2);
        }
        function Ca(t2, e2) {
          if (1 === t2.length)
            return Va(e2, t2[0]);
          for (var r2 = 0; r2 < e2.length; r2++)
            for (var n2 = e2[r2], i2 = 0; i2 < n2.length; i2++)
              if (Fa(t2, n2[i2]))
                return true;
          for (var a2 = 0; a2 < t2.length; a2++)
            if (Va(e2, t2[a2]))
              return true;
          for (var o2 = 0; o2 < e2.length; o2++)
            if (Pa(t2, e2[o2]))
              return true;
          return false;
        }
        function Ba(t2, e2, r2) {
          if (t2.length > 1) {
            if (Pa(t2, e2))
              return true;
            for (var n2 = 0; n2 < e2.length; n2++)
              if (Ea(e2[n2], t2, r2))
                return true;
          }
          for (var i2 = 0; i2 < t2.length; i2++)
            if (Ea(t2[i2], e2, r2))
              return true;
          return false;
        }
        function Pa(t2, e2) {
          if (0 === t2.length || 0 === e2.length)
            return false;
          for (var r2 = 0; r2 < t2.length - 1; r2++)
            for (var n2 = t2[r2], i2 = t2[r2 + 1], a2 = 0; a2 < e2.length - 1; a2++) {
              if (Ta(n2, i2, e2[a2], e2[a2 + 1]))
                return true;
            }
          return false;
        }
        function Ta(t2, e2, r2, n2) {
          return w(t2, r2, n2) !== w(e2, r2, n2) && w(t2, e2, r2) !== w(t2, e2, n2);
        }
        function Ea(t2, e2, r2) {
          var n2 = r2 * r2;
          if (1 === e2.length)
            return t2.distSqr(e2[0]) < n2;
          for (var i2 = 1; i2 < e2.length; i2++) {
            if (Ma(t2, e2[i2 - 1], e2[i2]) < n2)
              return true;
          }
          return false;
        }
        function Ma(t2, e2, r2) {
          var n2 = e2.distSqr(r2);
          if (0 === n2)
            return t2.distSqr(e2);
          var i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
          return i2 < 0 ? t2.distSqr(e2) : i2 > 1 ? t2.distSqr(r2) : t2.distSqr(r2.sub(e2)._mult(i2)._add(e2));
        }
        function Va(t2, e2) {
          for (var r2, n2, i2, a2 = false, o2 = 0; o2 < t2.length; o2++)
            for (var s2 = 0, u2 = (r2 = t2[o2]).length - 1; s2 < r2.length; u2 = s2++)
              n2 = r2[s2], i2 = r2[u2], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (a2 = !a2);
          return a2;
        }
        function Fa(t2, e2) {
          for (var r2 = false, n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
            var a2 = t2[n2], o2 = t2[i2];
            a2.y > e2.y != o2.y > e2.y && e2.x < (o2.x - a2.x) * (e2.y - a2.y) / (o2.y - a2.y) + a2.x && (r2 = !r2);
          }
          return r2;
        }
        function La(t2, e2, r2) {
          var n2 = r2[0], i2 = r2[2];
          if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y)
            return false;
          var a2 = w(t2, e2, r2[0]);
          return a2 !== w(t2, e2, r2[1]) || a2 !== w(t2, e2, r2[2]) || a2 !== w(t2, e2, r2[3]);
        }
        function Oa(t2, e2, r2) {
          var n2 = e2.paint.get(t2).value;
          return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e2.id).binders[t2].maxValue;
        }
        function Da(t2) {
          return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
        }
        function Ra(t2, e2, r2, n2, a2) {
          if (!e2[0] && !e2[1])
            return t2;
          var o2 = i.convert(e2)._mult(a2);
          "viewport" === r2 && o2._rotate(-n2);
          for (var s2 = [], u2 = 0; u2 < t2.length; u2++) {
            var l2 = t2[u2];
            s2.push(l2.sub(o2));
          }
          return s2;
        }
        ka.prototype.populate = function(t2, e2) {
          var r2 = this.layers[0], n2 = [], i2 = null;
          "circle" === r2.type && (i2 = r2.layout.get("circle-sort-key"));
          for (var a2 = 0, o2 = t2; a2 < o2.length; a2 += 1) {
            var s2 = o2[a2], u2 = s2.feature, l2 = s2.id, p2 = s2.index, c2 = s2.sourceLayerIndex;
            if (this.layers[0]._featureFilter(new Kn(this.zoom), u2)) {
              var h2 = Aa(u2), f2 = i2 ? i2.evaluate(u2, {}) : void 0, y2 = { id: l2, properties: u2.properties, type: u2.type, sourceLayerIndex: c2, index: p2, geometry: h2, patterns: {}, sortKey: f2 };
              n2.push(y2);
            }
          }
          i2 && n2.sort(function(t3, e3) {
            return t3.sortKey - e3.sortKey;
          });
          for (var d2 = 0, m2 = n2; d2 < m2.length; d2 += 1) {
            var v2 = m2[d2], g2 = v2, x2 = g2.geometry, b2 = g2.index, _2 = g2.sourceLayerIndex, w2 = t2[b2].feature;
            this.addFeature(v2, x2, b2), e2.featureIndex.insert(w2, x2, b2, _2, this.index);
          }
        }, ka.prototype.update = function(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }, ka.prototype.isEmpty = function() {
          return 0 === this.layoutVertexArray.length;
        }, ka.prototype.uploadPending = function() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }, ka.prototype.upload = function(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ki), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }, ka.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }, ka.prototype.addFeature = function(t2, e2, r2) {
          for (var n2 = 0, i2 = e2; n2 < i2.length; n2 += 1)
            for (var a2 = 0, o2 = i2[n2]; a2 < o2.length; a2 += 1) {
              var s2 = o2[a2], u2 = s2.x, l2 = s2.y;
              if (!(u2 < 0 || u2 >= 8192 || l2 < 0 || l2 >= 8192)) {
                var p2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), c2 = p2.vertexLength;
                Sa(this.layoutVertexArray, u2, l2, -1, -1), Sa(this.layoutVertexArray, u2, l2, 1, -1), Sa(this.layoutVertexArray, u2, l2, 1, 1), Sa(this.layoutVertexArray, u2, l2, -1, 1), this.indexArray.emplaceBack(c2, c2 + 1, c2 + 2), this.indexArray.emplaceBack(c2, c2 + 3, c2 + 2), p2.vertexLength += 4, p2.primitiveLength += 2;
              }
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {});
        }, vn("CircleBucket", ka, { omit: ["layers"] });
        var Ua = new ii({ "circle-sort-key": new ti(Ct.layout_circle["circle-sort-key"]) }), ja = { paint: new ii({ "circle-radius": new ti(Ct.paint_circle["circle-radius"]), "circle-color": new ti(Ct.paint_circle["circle-color"]), "circle-blur": new ti(Ct.paint_circle["circle-blur"]), "circle-opacity": new ti(Ct.paint_circle["circle-opacity"]), "circle-translate": new Qn(Ct.paint_circle["circle-translate"]), "circle-translate-anchor": new Qn(Ct.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Qn(Ct.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Qn(Ct.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new ti(Ct.paint_circle["circle-stroke-width"]), "circle-stroke-color": new ti(Ct.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new ti(Ct.paint_circle["circle-stroke-opacity"]) }), layout: Ua }, qa = "undefined" != typeof Float32Array ? Float32Array : Array;
        Math.hypot || (Math.hypot = function() {
          for (var t2 = arguments, e2 = 0, r2 = arguments.length; r2--; )
            e2 += t2[r2] * t2[r2];
          return Math.sqrt(e2);
        });
        var Na, Ka;
        Na = new qa(3), qa != Float32Array && (Na[0] = 0, Na[1] = 0, Na[2] = 0), Ka = Na;
        function Xa(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], a2 = e2[2], o2 = e2[3];
          return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * a2 + r2[12] * o2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * a2 + r2[13] * o2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * a2 + r2[14] * o2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * a2 + r2[15] * o2, t2;
        }
        !function() {
          var t2 = function() {
            var t3 = new qa(4);
            return qa != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 0), t3;
          }();
        }();
        var Za = function(t2) {
          function e2(e3) {
            t2.call(this, e3, ja);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.createBucket = function(t3) {
            return new ka(t3);
          }, e2.prototype.queryRadius = function(t3) {
            var e3 = t3;
            return Oa("circle-radius", this, e3) + Oa("circle-stroke-width", this, e3) + Da(this.paint.get("circle-translate"));
          }, e2.prototype.queryIntersectsFeature = function(t3, e3, r2, n2, i2, a2, o2, s2) {
            for (var u2 = Ra(t3, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a2.angle, o2), l2 = this.paint.get("circle-radius").evaluate(e3, r2) + this.paint.get("circle-stroke-width").evaluate(e3, r2), p2 = "map" === this.paint.get("circle-pitch-alignment"), c2 = p2 ? u2 : function(t4, e4) {
              return t4.map(function(t5) {
                return Ga(t5, e4);
              });
            }(u2, s2), h2 = p2 ? l2 * o2 : l2, f2 = 0, y2 = n2; f2 < y2.length; f2 += 1)
              for (var d2 = 0, m2 = y2[f2]; d2 < m2.length; d2 += 1) {
                var v2 = m2[d2], g2 = p2 ? v2 : Ga(v2, s2), x2 = h2, b2 = Xa([], [v2.x, v2.y, 0, 1], s2);
                if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? x2 *= b2[3] / a2.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (x2 *= a2.cameraToCenterDistance / b2[3]), za(c2, g2, x2))
                  return true;
              }
            return false;
          }, e2;
        }(ai);
        function Ga(t2, e2) {
          var r2 = Xa([], [t2.x, t2.y, 0, 1], e2);
          return new i(r2[0] / r2[3], r2[1] / r2[3]);
        }
        var Ja = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2;
        }(ka);
        function Ha(t2, e2, r2, n2) {
          var i2 = e2.width, a2 = e2.height;
          if (n2) {
            if (n2 instanceof Uint8ClampedArray)
              n2 = new Uint8Array(n2.buffer);
            else if (n2.length !== i2 * a2 * r2)
              throw new RangeError("mismatched image size");
          } else
            n2 = new Uint8Array(i2 * a2 * r2);
          return t2.width = i2, t2.height = a2, t2.data = n2, t2;
        }
        function Ya(t2, e2, r2) {
          var n2 = e2.width, i2 = e2.height;
          if (n2 !== t2.width || i2 !== t2.height) {
            var a2 = Ha({}, { width: n2, height: i2 }, r2);
            $a(t2, a2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, n2), height: Math.min(t2.height, i2) }, r2), t2.width = n2, t2.height = i2, t2.data = a2.data;
          }
        }
        function $a(t2, e2, r2, n2, i2, a2) {
          if (0 === i2.width || 0 === i2.height)
            return e2;
          if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
            throw new RangeError("out of range source coordinates for image copy");
          if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height)
            throw new RangeError("out of range destination coordinates for image copy");
          for (var o2 = t2.data, s2 = e2.data, u2 = 0; u2 < i2.height; u2++)
            for (var l2 = ((r2.y + u2) * t2.width + r2.x) * a2, p2 = ((n2.y + u2) * e2.width + n2.x) * a2, c2 = 0; c2 < i2.width * a2; c2++)
              s2[p2 + c2] = o2[l2 + c2];
          return e2;
        }
        vn("HeatmapBucket", Ja, { omit: ["layers"] });
        var Wa = function(t2, e2) {
          Ha(this, t2, 1, e2);
        };
        Wa.prototype.resize = function(t2) {
          Ya(this, t2, 1);
        }, Wa.prototype.clone = function() {
          return new Wa({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }, Wa.copy = function(t2, e2, r2, n2, i2) {
          $a(t2, e2, r2, n2, i2, 1);
        };
        var Qa = function(t2, e2) {
          Ha(this, t2, 4, e2);
        };
        Qa.prototype.resize = function(t2) {
          Ya(this, t2, 4);
        }, Qa.prototype.replace = function(t2, e2) {
          e2 ? this.data.set(t2) : t2 instanceof Uint8ClampedArray ? this.data = new Uint8Array(t2.buffer) : this.data = t2;
        }, Qa.prototype.clone = function() {
          return new Qa({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }, Qa.copy = function(t2, e2, r2, n2, i2) {
          $a(t2, e2, r2, n2, i2, 4);
        }, vn("AlphaImage", Wa), vn("RGBAImage", Qa);
        var to = { paint: new ii({ "heatmap-radius": new ti(Ct.paint_heatmap["heatmap-radius"]), "heatmap-weight": new ti(Ct.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Qn(Ct.paint_heatmap["heatmap-intensity"]), "heatmap-color": new ni(Ct.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Qn(Ct.paint_heatmap["heatmap-opacity"]) }) };
        function eo(t2, e2) {
          for (var r2 = new Uint8Array(1024), n2 = {}, i2 = 0, a2 = 0; i2 < 256; i2++, a2 += 4) {
            n2[e2] = i2 / 255;
            var o2 = t2.evaluate(n2);
            r2[a2 + 0] = Math.floor(255 * o2.r / o2.a), r2[a2 + 1] = Math.floor(255 * o2.g / o2.a), r2[a2 + 2] = Math.floor(255 * o2.b / o2.a), r2[a2 + 3] = Math.floor(255 * o2.a);
          }
          return new Qa({ width: 256, height: 1 }, r2);
        }
        var ro = function(t2) {
          function e2(e3) {
            t2.call(this, e3, to), this._updateColorRamp();
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.createBucket = function(t3) {
            return new Ja(t3);
          }, e2.prototype._handleSpecialPaintPropertyUpdate = function(t3) {
            "heatmap-color" === t3 && this._updateColorRamp();
          }, e2.prototype._updateColorRamp = function() {
            var t3 = this._transitionablePaint._values["heatmap-color"].value.expression;
            this.colorRamp = eo(t3, "heatmapDensity"), this.colorRampTexture = null;
          }, e2.prototype.resize = function() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }, e2.prototype.queryRadius = function() {
            return 0;
          }, e2.prototype.queryIntersectsFeature = function() {
            return false;
          }, e2.prototype.hasOffscreenPass = function() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }, e2;
        }(ai), no = { paint: new ii({ "hillshade-illumination-direction": new Qn(Ct.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Qn(Ct.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Qn(Ct.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Qn(Ct.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Qn(Ct.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Qn(Ct.paint_hillshade["hillshade-accent-color"]) }) }, io = function(t2) {
          function e2(e3) {
            t2.call(this, e3, no);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.hasOffscreenPass = function() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }, e2;
        }(ai), ao = li([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, oo = uo, so = uo;
        function uo(t2, e2, r2) {
          r2 = r2 || 2;
          var n2, i2, a2, o2, s2, u2, l2, p2 = e2 && e2.length, c2 = p2 ? e2[0] * r2 : t2.length, h2 = lo(t2, 0, c2, r2, true), f2 = [];
          if (!h2 || h2.next === h2.prev)
            return f2;
          if (p2 && (h2 = function(t3, e3, r3, n3) {
            var i3, a3, o3, s3, u3, l3 = [];
            for (i3 = 0, a3 = e3.length; i3 < a3; i3++)
              o3 = e3[i3] * n3, s3 = i3 < a3 - 1 ? e3[i3 + 1] * n3 : t3.length, (u3 = lo(t3, o3, s3, n3, false)) === u3.next && (u3.steiner = true), l3.push(_o(u3));
            for (l3.sort(vo), i3 = 0; i3 < l3.length; i3++)
              r3 = po(r3 = go(l3[i3], r3), r3.next);
            return r3;
          }(t2, e2, h2, r2)), t2.length > 80 * r2) {
            n2 = a2 = t2[0], i2 = o2 = t2[1];
            for (var y2 = r2; y2 < c2; y2 += r2)
              (s2 = t2[y2]) < n2 && (n2 = s2), (u2 = t2[y2 + 1]) < i2 && (i2 = u2), s2 > a2 && (a2 = s2), u2 > o2 && (o2 = u2);
            l2 = 0 !== (l2 = Math.max(a2 - n2, o2 - i2)) ? 1 / l2 : 0;
          }
          return co(h2, f2, r2, n2, i2, l2), f2;
        }
        function lo(t2, e2, r2, n2, i2) {
          var a2, o2;
          if (i2 === Vo(t2, e2, r2, n2) > 0)
            for (a2 = e2; a2 < r2; a2 += n2)
              o2 = To(a2, t2[a2], t2[a2 + 1], o2);
          else
            for (a2 = r2 - n2; a2 >= e2; a2 -= n2)
              o2 = To(a2, t2[a2], t2[a2 + 1], o2);
          return o2 && ko(o2, o2.next) && (Eo(o2), o2 = o2.next), o2;
        }
        function po(t2, e2) {
          if (!t2)
            return t2;
          e2 || (e2 = t2);
          var r2, n2 = t2;
          do {
            if (r2 = false, n2.steiner || !ko(n2, n2.next) && 0 !== So(n2.prev, n2, n2.next))
              n2 = n2.next;
            else {
              if (Eo(n2), (n2 = e2 = n2.prev) === n2.next)
                break;
              r2 = true;
            }
          } while (r2 || n2 !== e2);
          return e2;
        }
        function co(t2, e2, r2, n2, i2, a2, o2) {
          if (t2) {
            !o2 && a2 && function(t3, e3, r3, n3) {
              var i3 = t3;
              do {
                null === i3.z && (i3.z = bo(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
              } while (i3 !== t3);
              i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
                var e4, r4, n4, i4, a3, o3, s3, u3, l3 = 1;
                do {
                  for (r4 = t4, t4 = null, a3 = null, o3 = 0; r4; ) {
                    for (o3++, n4 = r4, s3 = 0, e4 = 0; e4 < l3 && (s3++, n4 = n4.nextZ); e4++)
                      ;
                    for (u3 = l3; s3 > 0 || u3 > 0 && n4; )
                      0 !== s3 && (0 === u3 || !n4 || r4.z <= n4.z) ? (i4 = r4, r4 = r4.nextZ, s3--) : (i4 = n4, n4 = n4.nextZ, u3--), a3 ? a3.nextZ = i4 : t4 = i4, i4.prevZ = a3, a3 = i4;
                    r4 = n4;
                  }
                  a3.nextZ = null, l3 *= 2;
                } while (o3 > 1);
              }(i3);
            }(t2, n2, i2, a2);
            for (var s2, u2, l2 = t2; t2.prev !== t2.next; )
              if (s2 = t2.prev, u2 = t2.next, a2 ? fo(t2, n2, i2, a2) : ho(t2))
                e2.push(s2.i / r2), e2.push(t2.i / r2), e2.push(u2.i / r2), Eo(t2), t2 = u2.next, l2 = u2.next;
              else if ((t2 = u2) === l2) {
                o2 ? 1 === o2 ? co(t2 = yo(po(t2), e2, r2), e2, r2, n2, i2, a2, 2) : 2 === o2 && mo(t2, e2, r2, n2, i2, a2) : co(po(t2), e2, r2, n2, i2, a2, 1);
                break;
              }
          }
        }
        function ho(t2) {
          var e2 = t2.prev, r2 = t2, n2 = t2.next;
          if (So(e2, r2, n2) >= 0)
            return false;
          for (var i2 = t2.next.next; i2 !== t2.prev; ) {
            if (wo(e2.x, e2.y, r2.x, r2.y, n2.x, n2.y, i2.x, i2.y) && So(i2.prev, i2, i2.next) >= 0)
              return false;
            i2 = i2.next;
          }
          return true;
        }
        function fo(t2, e2, r2, n2) {
          var i2 = t2.prev, a2 = t2, o2 = t2.next;
          if (So(i2, a2, o2) >= 0)
            return false;
          for (var s2 = i2.x < a2.x ? i2.x < o2.x ? i2.x : o2.x : a2.x < o2.x ? a2.x : o2.x, u2 = i2.y < a2.y ? i2.y < o2.y ? i2.y : o2.y : a2.y < o2.y ? a2.y : o2.y, l2 = i2.x > a2.x ? i2.x > o2.x ? i2.x : o2.x : a2.x > o2.x ? a2.x : o2.x, p2 = i2.y > a2.y ? i2.y > o2.y ? i2.y : o2.y : a2.y > o2.y ? a2.y : o2.y, c2 = bo(s2, u2, e2, r2, n2), h2 = bo(l2, p2, e2, r2, n2), f2 = t2.prevZ, y2 = t2.nextZ; f2 && f2.z >= c2 && y2 && y2.z <= h2; ) {
            if (f2 !== t2.prev && f2 !== t2.next && wo(i2.x, i2.y, a2.x, a2.y, o2.x, o2.y, f2.x, f2.y) && So(f2.prev, f2, f2.next) >= 0)
              return false;
            if (f2 = f2.prevZ, y2 !== t2.prev && y2 !== t2.next && wo(i2.x, i2.y, a2.x, a2.y, o2.x, o2.y, y2.x, y2.y) && So(y2.prev, y2, y2.next) >= 0)
              return false;
            y2 = y2.nextZ;
          }
          for (; f2 && f2.z >= c2; ) {
            if (f2 !== t2.prev && f2 !== t2.next && wo(i2.x, i2.y, a2.x, a2.y, o2.x, o2.y, f2.x, f2.y) && So(f2.prev, f2, f2.next) >= 0)
              return false;
            f2 = f2.prevZ;
          }
          for (; y2 && y2.z <= h2; ) {
            if (y2 !== t2.prev && y2 !== t2.next && wo(i2.x, i2.y, a2.x, a2.y, o2.x, o2.y, y2.x, y2.y) && So(y2.prev, y2, y2.next) >= 0)
              return false;
            y2 = y2.nextZ;
          }
          return true;
        }
        function yo(t2, e2, r2) {
          var n2 = t2;
          do {
            var i2 = n2.prev, a2 = n2.next.next;
            !ko(i2, a2) && Io(i2, n2, n2.next, a2) && Bo(i2, a2) && Bo(a2, i2) && (e2.push(i2.i / r2), e2.push(n2.i / r2), e2.push(a2.i / r2), Eo(n2), Eo(n2.next), n2 = t2 = a2), n2 = n2.next;
          } while (n2 !== t2);
          return po(n2);
        }
        function mo(t2, e2, r2, n2, i2, a2) {
          var o2 = t2;
          do {
            for (var s2 = o2.next.next; s2 !== o2.prev; ) {
              if (o2.i !== s2.i && Ao(o2, s2)) {
                var u2 = Po(o2, s2);
                return o2 = po(o2, o2.next), u2 = po(u2, u2.next), co(o2, e2, r2, n2, i2, a2), void co(u2, e2, r2, n2, i2, a2);
              }
              s2 = s2.next;
            }
            o2 = o2.next;
          } while (o2 !== t2);
        }
        function vo(t2, e2) {
          return t2.x - e2.x;
        }
        function go(t2, e2) {
          var r2 = function(t3, e3) {
            var r3, n3 = e3, i3 = t3.x, a2 = t3.y, o2 = -1 / 0;
            do {
              if (a2 <= n3.y && a2 >= n3.next.y && n3.next.y !== n3.y) {
                var s2 = n3.x + (a2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
                if (s2 <= i3 && s2 > o2) {
                  if (o2 = s2, s2 === i3) {
                    if (a2 === n3.y)
                      return n3;
                    if (a2 === n3.next.y)
                      return n3.next;
                  }
                  r3 = n3.x < n3.next.x ? n3 : n3.next;
                }
              }
              n3 = n3.next;
            } while (n3 !== e3);
            if (!r3)
              return null;
            if (i3 === o2)
              return r3;
            var u2, l2 = r3, p2 = r3.x, c2 = r3.y, h2 = 1 / 0;
            n3 = r3;
            do {
              i3 >= n3.x && n3.x >= p2 && i3 !== n3.x && wo(a2 < c2 ? i3 : o2, a2, p2, c2, a2 < c2 ? o2 : i3, a2, n3.x, n3.y) && (u2 = Math.abs(a2 - n3.y) / (i3 - n3.x), Bo(n3, t3) && (u2 < h2 || u2 === h2 && (n3.x > r3.x || n3.x === r3.x && xo(r3, n3))) && (r3 = n3, h2 = u2)), n3 = n3.next;
            } while (n3 !== l2);
            return r3;
          }(t2, e2);
          if (!r2)
            return e2;
          var n2 = Po(r2, t2), i2 = po(r2, r2.next);
          return po(n2, n2.next), e2 === r2 ? i2 : e2;
        }
        function xo(t2, e2) {
          return So(t2.prev, t2, e2.prev) < 0 && So(e2.next, t2, t2.next) < 0;
        }
        function bo(t2, e2, r2, n2, i2) {
          return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - r2) * i2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - n2) * i2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
        }
        function _o(t2) {
          var e2 = t2, r2 = t2;
          do {
            (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
          } while (e2 !== t2);
          return r2;
        }
        function wo(t2, e2, r2, n2, i2, a2, o2, s2) {
          return (i2 - o2) * (e2 - s2) - (t2 - o2) * (a2 - s2) >= 0 && (t2 - o2) * (n2 - s2) - (r2 - o2) * (e2 - s2) >= 0 && (r2 - o2) * (a2 - s2) - (i2 - o2) * (n2 - s2) >= 0;
        }
        function Ao(t2, e2) {
          return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
            var r2 = t3;
            do {
              if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && Io(r2, r2.next, t3, e3))
                return true;
              r2 = r2.next;
            } while (r2 !== t3);
            return false;
          }(t2, e2) && (Bo(t2, e2) && Bo(e2, t2) && function(t3, e3) {
            var r2 = t3, n2 = false, i2 = (t3.x + e3.x) / 2, a2 = (t3.y + e3.y) / 2;
            do {
              r2.y > a2 != r2.next.y > a2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (a2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
            } while (r2 !== t3);
            return n2;
          }(t2, e2) && (So(t2.prev, t2, e2.prev) || So(t2, e2.prev, e2)) || ko(t2, e2) && So(t2.prev, t2, t2.next) > 0 && So(e2.prev, e2, e2.next) > 0);
        }
        function So(t2, e2, r2) {
          return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
        }
        function ko(t2, e2) {
          return t2.x === e2.x && t2.y === e2.y;
        }
        function Io(t2, e2, r2, n2) {
          var i2 = Co(So(t2, e2, r2)), a2 = Co(So(t2, e2, n2)), o2 = Co(So(r2, n2, t2)), s2 = Co(So(r2, n2, e2));
          return i2 !== a2 && o2 !== s2 || (!(0 !== i2 || !zo(t2, r2, e2)) || (!(0 !== a2 || !zo(t2, n2, e2)) || (!(0 !== o2 || !zo(r2, t2, n2)) || !(0 !== s2 || !zo(r2, e2, n2)))));
        }
        function zo(t2, e2, r2) {
          return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
        }
        function Co(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }
        function Bo(t2, e2) {
          return So(t2.prev, t2, t2.next) < 0 ? So(t2, e2, t2.next) >= 0 && So(t2, t2.prev, e2) >= 0 : So(t2, e2, t2.prev) < 0 || So(t2, t2.next, e2) < 0;
        }
        function Po(t2, e2) {
          var r2 = new Mo(t2.i, t2.x, t2.y), n2 = new Mo(e2.i, e2.x, e2.y), i2 = t2.next, a2 = e2.prev;
          return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, a2.next = n2, n2.prev = a2, n2;
        }
        function To(t2, e2, r2, n2) {
          var i2 = new Mo(t2, e2, r2);
          return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
        }
        function Eo(t2) {
          t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
        }
        function Mo(t2, e2, r2) {
          this.i = t2, this.x = e2, this.y = r2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        function Vo(t2, e2, r2, n2) {
          for (var i2 = 0, a2 = e2, o2 = r2 - n2; a2 < r2; a2 += n2)
            i2 += (t2[o2] - t2[a2]) * (t2[a2 + 1] + t2[o2 + 1]), o2 = a2;
          return i2;
        }
        function Fo(t2, e2, r2, n2, i2) {
          !function t3(e3, r3, n3, i3, a2) {
            for (; i3 > n3; ) {
              if (i3 - n3 > 600) {
                var o2 = i3 - n3 + 1, s2 = r3 - n3 + 1, u2 = Math.log(o2), l2 = 0.5 * Math.exp(2 * u2 / 3), p2 = 0.5 * Math.sqrt(u2 * l2 * (o2 - l2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), c2 = Math.max(n3, Math.floor(r3 - s2 * l2 / o2 + p2)), h2 = Math.min(i3, Math.floor(r3 + (o2 - s2) * l2 / o2 + p2));
                t3(e3, r3, c2, h2, a2);
              }
              var f2 = e3[r3], y2 = n3, d2 = i3;
              for (Lo(e3, n3, r3), a2(e3[i3], f2) > 0 && Lo(e3, n3, i3); y2 < d2; ) {
                for (Lo(e3, y2, d2), y2++, d2--; a2(e3[y2], f2) < 0; )
                  y2++;
                for (; a2(e3[d2], f2) > 0; )
                  d2--;
              }
              0 === a2(e3[n3], f2) ? Lo(e3, n3, d2) : (d2++, Lo(e3, d2, i3)), d2 <= r3 && (n3 = d2 + 1), r3 <= d2 && (i3 = d2 - 1);
            }
          }(t2, e2, r2 || 0, n2 || t2.length - 1, i2 || Oo);
        }
        function Lo(t2, e2, r2) {
          var n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        function Oo(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function Do(t2, e2) {
          var r2 = t2.length;
          if (r2 <= 1)
            return [t2];
          for (var n2, i2, a2 = [], o2 = 0; o2 < r2; o2++) {
            var s2 = A(t2[o2]);
            0 !== s2 && (t2[o2].area = Math.abs(s2), void 0 === i2 && (i2 = s2 < 0), i2 === s2 < 0 ? (n2 && a2.push(n2), n2 = [t2[o2]]) : n2.push(t2[o2]));
          }
          if (n2 && a2.push(n2), e2 > 1)
            for (var u2 = 0; u2 < a2.length; u2++)
              a2[u2].length <= e2 || (Fo(a2[u2], e2, 1, a2[u2].length - 1, Ro), a2[u2] = a2[u2].slice(0, e2));
          return a2;
        }
        function Ro(t2, e2) {
          return e2.area - t2.area;
        }
        function Uo(t2, e2, r2) {
          for (var n2 = r2.patternDependencies, i2 = false, a2 = 0, o2 = e2; a2 < o2.length; a2 += 1) {
            var s2 = o2[a2].paint.get(t2 + "-pattern");
            s2.isConstant() || (i2 = true);
            var u2 = s2.constantOr(null);
            u2 && (i2 = true, n2[u2.to] = true, n2[u2.from] = true);
          }
          return i2;
        }
        function jo(t2, e2, r2, n2, i2) {
          for (var a2 = i2.patternDependencies, o2 = 0, s2 = e2; o2 < s2.length; o2 += 1) {
            var u2 = s2[o2], l2 = u2.paint.get(t2 + "-pattern").value;
            if ("constant" !== l2.kind) {
              var p2 = l2.evaluate({ zoom: n2 - 1 }, r2, {}, i2.availableImages), c2 = l2.evaluate({ zoom: n2 }, r2, {}, i2.availableImages), h2 = l2.evaluate({ zoom: n2 + 1 }, r2, {}, i2.availableImages);
              p2 = p2 && p2.name ? p2.name : p2, c2 = c2 && c2.name ? c2.name : c2, h2 = h2 && h2.name ? h2.name : h2, a2[p2] = true, a2[c2] = true, a2[h2] = true, r2.patterns[u2.id] = { min: p2, mid: c2, max: h2 };
            }
          }
          return r2;
        }
        uo.deviation = function(t2, e2, r2, n2) {
          var i2 = e2 && e2.length, a2 = i2 ? e2[0] * r2 : t2.length, o2 = Math.abs(Vo(t2, 0, a2, r2));
          if (i2)
            for (var s2 = 0, u2 = e2.length; s2 < u2; s2++) {
              var l2 = e2[s2] * r2, p2 = s2 < u2 - 1 ? e2[s2 + 1] * r2 : t2.length;
              o2 -= Math.abs(Vo(t2, l2, p2, r2));
            }
          var c2 = 0;
          for (s2 = 0; s2 < n2.length; s2 += 3) {
            var h2 = n2[s2] * r2, f2 = n2[s2 + 1] * r2, y2 = n2[s2 + 2] * r2;
            c2 += Math.abs((t2[h2] - t2[y2]) * (t2[f2 + 1] - t2[h2 + 1]) - (t2[h2] - t2[f2]) * (t2[y2 + 1] - t2[h2 + 1]));
          }
          return 0 === o2 && 0 === c2 ? 0 : Math.abs((c2 - o2) / o2);
        }, uo.flatten = function(t2) {
          for (var e2 = t2[0][0].length, r2 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, i2 = 0; i2 < t2.length; i2++) {
            for (var a2 = 0; a2 < t2[i2].length; a2++)
              for (var o2 = 0; o2 < e2; o2++)
                r2.vertices.push(t2[i2][a2][o2]);
            i2 > 0 && (n2 += t2[i2 - 1].length, r2.holes.push(n2));
          }
          return r2;
        }, oo.default = so;
        var qo = function(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
            return t3.id;
          }), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new ci(), this.indexArray = new zi(), this.indexArray2 = new Ci(), this.programConfigurations = new ga(ao, t2.layers, t2.zoom), this.segments = new Xi(), this.segments2 = new Xi(), this.stateDependentLayerIds = this.layers.filter(function(t3) {
            return t3.isStateDependent();
          }).map(function(t3) {
            return t3.id;
          });
        };
        qo.prototype.populate = function(t2, e2) {
          this.hasPattern = Uo("fill", this.layers, e2);
          for (var r2 = this.layers[0].layout.get("fill-sort-key"), n2 = [], i2 = 0, a2 = t2; i2 < a2.length; i2 += 1) {
            var o2 = a2[i2], s2 = o2.feature, u2 = o2.id, l2 = o2.index, p2 = o2.sourceLayerIndex;
            if (this.layers[0]._featureFilter(new Kn(this.zoom), s2)) {
              var c2 = Aa(s2), h2 = r2 ? r2.evaluate(s2, {}, e2.availableImages) : void 0, f2 = { id: u2, properties: s2.properties, type: s2.type, sourceLayerIndex: p2, index: l2, geometry: c2, patterns: {}, sortKey: h2 };
              n2.push(f2);
            }
          }
          r2 && n2.sort(function(t3, e3) {
            return t3.sortKey - e3.sortKey;
          });
          for (var y2 = 0, d2 = n2; y2 < d2.length; y2 += 1) {
            var m2 = d2[y2], v2 = m2, g2 = v2.geometry, x2 = v2.index, b2 = v2.sourceLayerIndex;
            if (this.hasPattern) {
              var _2 = jo("fill", this.layers, m2, this.zoom, e2);
              this.patternFeatures.push(_2);
            } else
              this.addFeature(m2, g2, x2, {});
            var w2 = t2[x2].feature;
            e2.featureIndex.insert(w2, g2, x2, b2, this.index);
          }
        }, qo.prototype.update = function(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }, qo.prototype.addFeatures = function(t2, e2) {
          for (var r2 = 0, n2 = this.patternFeatures; r2 < n2.length; r2 += 1) {
            var i2 = n2[r2];
            this.addFeature(i2, i2.geometry, i2.index, e2);
          }
        }, qo.prototype.isEmpty = function() {
          return 0 === this.layoutVertexArray.length;
        }, qo.prototype.uploadPending = function() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }, qo.prototype.upload = function(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, ao), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
        }, qo.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }, qo.prototype.addFeature = function(t2, e2, r2, n2) {
          for (var i2 = 0, a2 = Do(e2, 500); i2 < a2.length; i2 += 1) {
            for (var o2 = a2[i2], s2 = 0, u2 = 0, l2 = o2; u2 < l2.length; u2 += 1) {
              s2 += l2[u2].length;
            }
            for (var p2 = this.segments.prepareSegment(s2, this.layoutVertexArray, this.indexArray), c2 = p2.vertexLength, h2 = [], f2 = [], y2 = 0, d2 = o2; y2 < d2.length; y2 += 1) {
              var m2 = d2[y2];
              if (0 !== m2.length) {
                m2 !== o2[0] && f2.push(h2.length / 2);
                var v2 = this.segments2.prepareSegment(m2.length, this.layoutVertexArray, this.indexArray2), g2 = v2.vertexLength;
                this.layoutVertexArray.emplaceBack(m2[0].x, m2[0].y), this.indexArray2.emplaceBack(g2 + m2.length - 1, g2), h2.push(m2[0].x), h2.push(m2[0].y);
                for (var x2 = 1; x2 < m2.length; x2++)
                  this.layoutVertexArray.emplaceBack(m2[x2].x, m2[x2].y), this.indexArray2.emplaceBack(g2 + x2 - 1, g2 + x2), h2.push(m2[x2].x), h2.push(m2[x2].y);
                v2.vertexLength += m2.length, v2.primitiveLength += m2.length;
              }
            }
            for (var b2 = oo(h2, f2), _2 = 0; _2 < b2.length; _2 += 3)
              this.indexArray.emplaceBack(c2 + b2[_2], c2 + b2[_2 + 1], c2 + b2[_2 + 2]);
            p2.vertexLength += s2, p2.primitiveLength += b2.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, n2);
        }, vn("FillBucket", qo, { omit: ["layers", "patternFeatures"] });
        var No = new ii({ "fill-sort-key": new ti(Ct.layout_fill["fill-sort-key"]) }), Ko = { paint: new ii({ "fill-antialias": new Qn(Ct.paint_fill["fill-antialias"]), "fill-opacity": new ti(Ct.paint_fill["fill-opacity"]), "fill-color": new ti(Ct.paint_fill["fill-color"]), "fill-outline-color": new ti(Ct.paint_fill["fill-outline-color"]), "fill-translate": new Qn(Ct.paint_fill["fill-translate"]), "fill-translate-anchor": new Qn(Ct.paint_fill["fill-translate-anchor"]), "fill-pattern": new ei(Ct.paint_fill["fill-pattern"]) }), layout: No }, Xo = function(t2) {
          function e2(e3) {
            t2.call(this, e3, Ko);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.recalculate = function(e3, r2) {
            t2.prototype.recalculate.call(this, e3, r2);
            var n2 = this.paint._values["fill-outline-color"];
            "constant" === n2.value.kind && void 0 === n2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }, e2.prototype.createBucket = function(t3) {
            return new qo(t3);
          }, e2.prototype.queryRadius = function() {
            return Da(this.paint.get("fill-translate"));
          }, e2.prototype.queryIntersectsFeature = function(t3, e3, r2, n2, i2, a2, o2) {
            return Ca(Ra(t3, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a2.angle, o2), n2);
          }, e2.prototype.isTileClipped = function() {
            return true;
          }, e2;
        }(ai), Zo = li([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4).members, Go = Jo;
        function Jo(t2, e2, r2, n2, i2) {
          this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(Ho, this, e2);
        }
        function Ho(t2, e2, r2) {
          1 == t2 ? e2.id = r2.readVarint() : 2 == t2 ? function(t3, e3) {
            var r3 = t3.readVarint() + t3.pos;
            for (; t3.pos < r3; ) {
              var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
              e3.properties[n2] = i2;
            }
          }(r2, e2) : 3 == t2 ? e2.type = r2.readVarint() : 4 == t2 && (e2._geometry = r2.pos);
        }
        function Yo(t2) {
          for (var e2, r2, n2 = 0, i2 = 0, a2 = t2.length, o2 = a2 - 1; i2 < a2; o2 = i2++)
            e2 = t2[i2], n2 += ((r2 = t2[o2]).x - e2.x) * (e2.y + r2.y);
          return n2;
        }
        Jo.types = ["Unknown", "Point", "LineString", "Polygon"], Jo.prototype.loadGeometry = function() {
          var t2 = this._pbf;
          t2.pos = this._geometry;
          for (var e2, r2 = t2.readVarint() + t2.pos, n2 = 1, a2 = 0, o2 = 0, s2 = 0, u2 = []; t2.pos < r2; ) {
            if (a2 <= 0) {
              var l2 = t2.readVarint();
              n2 = 7 & l2, a2 = l2 >> 3;
            }
            if (a2--, 1 === n2 || 2 === n2)
              o2 += t2.readSVarint(), s2 += t2.readSVarint(), 1 === n2 && (e2 && u2.push(e2), e2 = []), e2.push(new i(o2, s2));
            else {
              if (7 !== n2)
                throw new Error("unknown command " + n2);
              e2 && e2.push(e2[0].clone());
            }
          }
          return e2 && u2.push(e2), u2;
        }, Jo.prototype.bbox = function() {
          var t2 = this._pbf;
          t2.pos = this._geometry;
          for (var e2 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, a2 = 0, o2 = 1 / 0, s2 = -1 / 0, u2 = 1 / 0, l2 = -1 / 0; t2.pos < e2; ) {
            if (n2 <= 0) {
              var p2 = t2.readVarint();
              r2 = 7 & p2, n2 = p2 >> 3;
            }
            if (n2--, 1 === r2 || 2 === r2)
              (i2 += t2.readSVarint()) < o2 && (o2 = i2), i2 > s2 && (s2 = i2), (a2 += t2.readSVarint()) < u2 && (u2 = a2), a2 > l2 && (l2 = a2);
            else if (7 !== r2)
              throw new Error("unknown command " + r2);
          }
          return [o2, u2, s2, l2];
        }, Jo.prototype.toGeoJSON = function(t2, e2, r2) {
          var n2, i2, a2 = this.extent * Math.pow(2, r2), o2 = this.extent * t2, s2 = this.extent * e2, u2 = this.loadGeometry(), l2 = Jo.types[this.type];
          function p2(t3) {
            for (var e3 = 0; e3 < t3.length; e3++) {
              var r3 = t3[e3], n3 = 180 - 360 * (r3.y + s2) / a2;
              t3[e3] = [360 * (r3.x + o2) / a2 - 180, 360 / Math.PI * Math.atan(Math.exp(n3 * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var c2 = [];
              for (n2 = 0; n2 < u2.length; n2++)
                c2[n2] = u2[n2][0];
              p2(u2 = c2);
              break;
            case 2:
              for (n2 = 0; n2 < u2.length; n2++)
                p2(u2[n2]);
              break;
            case 3:
              for (u2 = function(t3) {
                var e3 = t3.length;
                if (e3 <= 1)
                  return [t3];
                for (var r3, n3, i3 = [], a3 = 0; a3 < e3; a3++) {
                  var o3 = Yo(t3[a3]);
                  0 !== o3 && (void 0 === n3 && (n3 = o3 < 0), n3 === o3 < 0 ? (r3 && i3.push(r3), r3 = [t3[a3]]) : r3.push(t3[a3]));
                }
                r3 && i3.push(r3);
                return i3;
              }(u2), n2 = 0; n2 < u2.length; n2++)
                for (i2 = 0; i2 < u2[n2].length; i2++)
                  p2(u2[n2][i2]);
          }
          1 === u2.length ? u2 = u2[0] : l2 = "Multi" + l2;
          var h2 = { type: "Feature", geometry: { type: l2, coordinates: u2 }, properties: this.properties };
          return "id" in this && (h2.id = this.id), h2;
        };
        var $o = Wo;
        function Wo(t2, e2) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(Qo, this, e2), this.length = this._features.length;
        }
        function Qo(t2, e2, r2) {
          15 === t2 ? e2.version = r2.readVarint() : 1 === t2 ? e2.name = r2.readString() : 5 === t2 ? e2.extent = r2.readVarint() : 2 === t2 ? e2._features.push(r2.pos) : 3 === t2 ? e2._keys.push(r2.readString()) : 4 === t2 && e2._values.push(function(t3) {
            var e3 = null, r3 = t3.readVarint() + t3.pos;
            for (; t3.pos < r3; ) {
              var n2 = t3.readVarint() >> 3;
              e3 = 1 === n2 ? t3.readString() : 2 === n2 ? t3.readFloat() : 3 === n2 ? t3.readDouble() : 4 === n2 ? t3.readVarint64() : 5 === n2 ? t3.readVarint() : 6 === n2 ? t3.readSVarint() : 7 === n2 ? t3.readBoolean() : null;
            }
            return e3;
          }(r2));
        }
        function ts(t2, e2, r2) {
          if (3 === t2) {
            var n2 = new $o(r2, r2.readVarint() + r2.pos);
            n2.length && (e2[n2.name] = n2);
          }
        }
        Wo.prototype.feature = function(t2) {
          if (t2 < 0 || t2 >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t2];
          var e2 = this._pbf.readVarint() + this._pbf.pos;
          return new Go(this._pbf, e2, this.extent, this._keys, this._values);
        };
        var es = { VectorTile: function(t2, e2) {
          this.layers = t2.readFields(ts, {}, e2);
        }, VectorTileFeature: Go, VectorTileLayer: $o }, rs = es.VectorTileFeature.types, ns = Math.pow(2, 13);
        function is(t2, e2, r2, n2, i2, a2, o2, s2) {
          t2.emplaceBack(e2, r2, 2 * Math.floor(n2 * ns) + o2, i2 * ns * 2, a2 * ns * 2, Math.round(s2));
        }
        var as = function(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
            return t3.id;
          }), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new fi(), this.indexArray = new zi(), this.programConfigurations = new ga(Zo, t2.layers, t2.zoom), this.segments = new Xi(), this.stateDependentLayerIds = this.layers.filter(function(t3) {
            return t3.isStateDependent();
          }).map(function(t3) {
            return t3.id;
          });
        };
        function os(t2, e2) {
          return t2.x === e2.x && (t2.x < 0 || t2.x > 8192) || t2.y === e2.y && (t2.y < 0 || t2.y > 8192);
        }
        function ss(t2) {
          return t2.every(function(t3) {
            return t3.x < 0;
          }) || t2.every(function(t3) {
            return t3.x > 8192;
          }) || t2.every(function(t3) {
            return t3.y < 0;
          }) || t2.every(function(t3) {
            return t3.y > 8192;
          });
        }
        as.prototype.populate = function(t2, e2) {
          this.features = [], this.hasPattern = Uo("fill-extrusion", this.layers, e2);
          for (var r2 = 0, n2 = t2; r2 < n2.length; r2 += 1) {
            var i2 = n2[r2], a2 = i2.feature, o2 = i2.id, s2 = i2.index, u2 = i2.sourceLayerIndex;
            if (this.layers[0]._featureFilter(new Kn(this.zoom), a2)) {
              var l2 = Aa(a2), p2 = { id: o2, sourceLayerIndex: u2, index: s2, geometry: l2, properties: a2.properties, type: a2.type, patterns: {} };
              void 0 !== a2.id && (p2.id = a2.id), this.hasPattern ? this.features.push(jo("fill-extrusion", this.layers, p2, this.zoom, e2)) : this.addFeature(p2, l2, s2, {}), e2.featureIndex.insert(a2, l2, s2, u2, this.index, true);
            }
          }
        }, as.prototype.addFeatures = function(t2, e2) {
          for (var r2 = 0, n2 = this.features; r2 < n2.length; r2 += 1) {
            var i2 = n2[r2], a2 = i2.geometry;
            this.addFeature(i2, a2, i2.index, e2);
          }
        }, as.prototype.update = function(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }, as.prototype.isEmpty = function() {
          return 0 === this.layoutVertexArray.length;
        }, as.prototype.uploadPending = function() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }, as.prototype.upload = function(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Zo), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }, as.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }, as.prototype.addFeature = function(t2, e2, r2, n2) {
          for (var i2 = 0, a2 = Do(e2, 500); i2 < a2.length; i2 += 1) {
            for (var o2 = a2[i2], s2 = 0, u2 = 0, l2 = o2; u2 < l2.length; u2 += 1) {
              s2 += l2[u2].length;
            }
            for (var p2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), c2 = 0, h2 = o2; c2 < h2.length; c2 += 1) {
              var f2 = h2[c2];
              if (0 !== f2.length && !ss(f2))
                for (var y2 = 0, d2 = 0; d2 < f2.length; d2++) {
                  var m2 = f2[d2];
                  if (d2 >= 1) {
                    var v2 = f2[d2 - 1];
                    if (!os(m2, v2)) {
                      p2.vertexLength + 4 > Xi.MAX_VERTEX_ARRAY_LENGTH && (p2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                      var g2 = m2.sub(v2)._perp()._unit(), x2 = v2.dist(m2);
                      y2 + x2 > 32768 && (y2 = 0), is(this.layoutVertexArray, m2.x, m2.y, g2.x, g2.y, 0, 0, y2), is(this.layoutVertexArray, m2.x, m2.y, g2.x, g2.y, 0, 1, y2), y2 += x2, is(this.layoutVertexArray, v2.x, v2.y, g2.x, g2.y, 0, 0, y2), is(this.layoutVertexArray, v2.x, v2.y, g2.x, g2.y, 0, 1, y2);
                      var b2 = p2.vertexLength;
                      this.indexArray.emplaceBack(b2, b2 + 2, b2 + 1), this.indexArray.emplaceBack(b2 + 1, b2 + 2, b2 + 3), p2.vertexLength += 4, p2.primitiveLength += 2;
                    }
                  }
                }
            }
            if (p2.vertexLength + s2 > Xi.MAX_VERTEX_ARRAY_LENGTH && (p2 = this.segments.prepareSegment(s2, this.layoutVertexArray, this.indexArray)), "Polygon" === rs[t2.type]) {
              for (var _2 = [], w2 = [], A2 = p2.vertexLength, S2 = 0, k2 = o2; S2 < k2.length; S2 += 1) {
                var I2 = k2[S2];
                if (0 !== I2.length) {
                  I2 !== o2[0] && w2.push(_2.length / 2);
                  for (var z2 = 0; z2 < I2.length; z2++) {
                    var C2 = I2[z2];
                    is(this.layoutVertexArray, C2.x, C2.y, 0, 0, 1, 1, 0), _2.push(C2.x), _2.push(C2.y);
                  }
                }
              }
              for (var B2 = oo(_2, w2), P2 = 0; P2 < B2.length; P2 += 3)
                this.indexArray.emplaceBack(A2 + B2[P2], A2 + B2[P2 + 2], A2 + B2[P2 + 1]);
              p2.primitiveLength += B2.length / 3, p2.vertexLength += s2;
            }
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, n2);
        }, vn("FillExtrusionBucket", as, { omit: ["layers", "features"] });
        var us = { paint: new ii({ "fill-extrusion-opacity": new Qn(Ct["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new ti(Ct["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Qn(Ct["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Qn(Ct["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new ei(Ct["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new ti(Ct["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new ti(Ct["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Qn(Ct["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) }, ls = function(t2) {
          function e2(e3) {
            t2.call(this, e3, us);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.createBucket = function(t3) {
            return new as(t3);
          }, e2.prototype.queryRadius = function() {
            return Da(this.paint.get("fill-extrusion-translate"));
          }, e2.prototype.is3D = function() {
            return true;
          }, e2.prototype.queryIntersectsFeature = function(t3, e3, r2, n2, a2, o2, s2, u2) {
            var l2 = Ra(t3, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o2.angle, s2), p2 = this.paint.get("fill-extrusion-height").evaluate(e3, r2), c2 = this.paint.get("fill-extrusion-base").evaluate(e3, r2), h2 = function(t4, e4, r3, n3) {
              for (var a3 = [], o3 = 0, s3 = t4; o3 < s3.length; o3 += 1) {
                var u3 = s3[o3], l3 = [u3.x, u3.y, n3, 1];
                Xa(l3, l3, e4), a3.push(new i(l3[0] / l3[3], l3[1] / l3[3]));
              }
              return a3;
            }(l2, u2, 0, 0), f2 = function(t4, e4, r3, n3) {
              for (var a3 = [], o3 = [], s3 = n3[8] * e4, u3 = n3[9] * e4, l3 = n3[10] * e4, p3 = n3[11] * e4, c3 = n3[8] * r3, h3 = n3[9] * r3, f3 = n3[10] * r3, y2 = n3[11] * r3, d2 = 0, m2 = t4; d2 < m2.length; d2 += 1) {
                for (var v2 = m2[d2], g2 = [], x2 = [], b2 = 0, _2 = v2; b2 < _2.length; b2 += 1) {
                  var w2 = _2[b2], A2 = w2.x, S2 = w2.y, k2 = n3[0] * A2 + n3[4] * S2 + n3[12], I2 = n3[1] * A2 + n3[5] * S2 + n3[13], z2 = n3[2] * A2 + n3[6] * S2 + n3[14], C2 = n3[3] * A2 + n3[7] * S2 + n3[15], B2 = z2 + l3, P2 = C2 + p3, T2 = k2 + c3, E2 = I2 + h3, M2 = z2 + f3, V2 = C2 + y2, F2 = new i((k2 + s3) / P2, (I2 + u3) / P2);
                  F2.z = B2 / P2, g2.push(F2);
                  var L2 = new i(T2 / V2, E2 / V2);
                  L2.z = M2 / V2, x2.push(L2);
                }
                a3.push(g2), o3.push(x2);
              }
              return [a3, o3];
            }(n2, c2, p2, u2);
            return function(t4, e4, r3) {
              var n3 = 1 / 0;
              Ca(r3, e4) && (n3 = cs(r3, e4[0]));
              for (var i2 = 0; i2 < e4.length; i2++)
                for (var a3 = e4[i2], o3 = t4[i2], s3 = 0; s3 < a3.length - 1; s3++) {
                  var u3 = a3[s3], l3 = a3[s3 + 1], p3 = o3[s3], c3 = o3[s3 + 1], h3 = [u3, l3, c3, p3, u3];
                  Ia(r3, h3) && (n3 = Math.min(n3, cs(r3, h3)));
                }
              return n3 !== 1 / 0 && n3;
            }(f2[0], f2[1], h2);
          }, e2;
        }(ai);
        function ps(t2, e2) {
          return t2.x * e2.x + t2.y * e2.y;
        }
        function cs(t2, e2) {
          if (1 === t2.length) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[3], a2 = t2[0], o2 = n2.sub(r2), s2 = i2.sub(r2), u2 = a2.sub(r2), l2 = ps(o2, o2), p2 = ps(o2, s2), c2 = ps(s2, s2), h2 = ps(u2, o2), f2 = ps(u2, s2), y2 = l2 * c2 - p2 * p2, d2 = (c2 * h2 - p2 * f2) / y2, m2 = (l2 * f2 - p2 * h2) / y2, v2 = 1 - d2 - m2;
            return r2.z * v2 + n2.z * d2 + i2.z * m2;
          }
          for (var g2 = 1 / 0, x2 = 0, b2 = e2; x2 < b2.length; x2 += 1) {
            var _2 = b2[x2];
            g2 = Math.min(g2, _2.z);
          }
          return g2;
        }
        var hs = li([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4).members, fs = es.VectorTileFeature.types, ys = Math.cos(Math.PI / 180 * 37.5), ds = Math.pow(2, 14) / 0.5, ms = function(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
            return t3.id;
          }), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new yi(), this.indexArray = new zi(), this.programConfigurations = new ga(hs, t2.layers, t2.zoom), this.segments = new Xi(), this.stateDependentLayerIds = this.layers.filter(function(t3) {
            return t3.isStateDependent();
          }).map(function(t3) {
            return t3.id;
          });
        };
        ms.prototype.populate = function(t2, e2) {
          this.hasPattern = Uo("line", this.layers, e2);
          for (var r2 = this.layers[0].layout.get("line-sort-key"), n2 = [], i2 = 0, a2 = t2; i2 < a2.length; i2 += 1) {
            var o2 = a2[i2], s2 = o2.feature, u2 = o2.index, l2 = o2.sourceLayerIndex;
            if (this.layers[0]._featureFilter(new Kn(this.zoom), s2)) {
              var p2 = Aa(s2), c2 = r2 ? r2.evaluate(s2, {}) : void 0, h2 = { id: s2.id, properties: s2.properties, type: s2.type, sourceLayerIndex: l2, index: u2, geometry: p2, patterns: {}, sortKey: c2 };
              n2.push(h2);
            }
          }
          r2 && n2.sort(function(t3, e3) {
            return t3.sortKey - e3.sortKey;
          });
          for (var f2 = 0, y2 = n2; f2 < y2.length; f2 += 1) {
            var d2 = y2[f2], m2 = d2, v2 = m2.geometry, g2 = m2.index, x2 = m2.sourceLayerIndex;
            if (this.hasPattern) {
              var b2 = jo("line", this.layers, d2, this.zoom, e2);
              this.patternFeatures.push(b2);
            } else
              this.addFeature(d2, v2, g2, {});
            var _2 = t2[g2].feature;
            e2.featureIndex.insert(_2, v2, g2, x2, this.index);
          }
        }, ms.prototype.update = function(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }, ms.prototype.addFeatures = function(t2, e2) {
          for (var r2 = 0, n2 = this.patternFeatures; r2 < n2.length; r2 += 1) {
            var i2 = n2[r2];
            this.addFeature(i2, i2.geometry, i2.index, e2);
          }
        }, ms.prototype.isEmpty = function() {
          return 0 === this.layoutVertexArray.length;
        }, ms.prototype.uploadPending = function() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }, ms.prototype.upload = function(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, hs), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }, ms.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }, ms.prototype.addFeature = function(t2, e2, r2, n2) {
          for (var i2 = this.layers[0].layout, a2 = i2.get("line-join").evaluate(t2, {}), o2 = i2.get("line-cap"), s2 = i2.get("line-miter-limit"), u2 = i2.get("line-round-limit"), l2 = 0, p2 = e2; l2 < p2.length; l2 += 1) {
            var c2 = p2[l2];
            this.addLine(c2, t2, a2, o2, s2, u2, r2, n2);
          }
        }, ms.prototype.addLine = function(t2, e2, r2, n2, i2, a2, o2, s2) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, e2.properties && e2.properties.hasOwnProperty("mapbox_clip_start") && e2.properties.hasOwnProperty("mapbox_clip_end")) {
            this.clipStart = +e2.properties.mapbox_clip_start, this.clipEnd = +e2.properties.mapbox_clip_end;
            for (var u2 = 0; u2 < t2.length - 1; u2++)
              this.totalDistance += t2[u2].dist(t2[u2 + 1]);
          }
          for (var l2 = "Polygon" === fs[e2.type], p2 = t2.length; p2 >= 2 && t2[p2 - 1].equals(t2[p2 - 2]); )
            p2--;
          for (var c2 = 0; c2 < p2 - 1 && t2[c2].equals(t2[c2 + 1]); )
            c2++;
          if (!(p2 < (l2 ? 3 : 2))) {
            "bevel" === r2 && (i2 = 1.05);
            var h2, f2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, y2 = this.segments.prepareSegment(10 * p2, this.layoutVertexArray, this.indexArray), d2 = void 0, m2 = void 0, v2 = void 0, g2 = void 0;
            this.e1 = this.e2 = -1, l2 && (h2 = t2[p2 - 2], g2 = t2[c2].sub(h2)._unit()._perp());
            for (var x2 = c2; x2 < p2; x2++)
              if (!(m2 = l2 && x2 === p2 - 1 ? t2[c2 + 1] : t2[x2 + 1]) || !t2[x2].equals(m2)) {
                g2 && (v2 = g2), h2 && (d2 = h2), h2 = t2[x2], g2 = m2 ? m2.sub(h2)._unit()._perp() : v2;
                var b2 = (v2 = v2 || g2).add(g2);
                0 === b2.x && 0 === b2.y || b2._unit();
                var _2 = v2.x * g2.x + v2.y * g2.y, w2 = b2.x * g2.x + b2.y * g2.y, A2 = 0 !== w2 ? 1 / w2 : 1 / 0, S2 = 2 * Math.sqrt(2 - 2 * w2), k2 = w2 < ys && d2 && m2, I2 = v2.x * g2.y - v2.y * g2.x > 0;
                if (k2 && x2 > c2) {
                  var z2 = h2.dist(d2);
                  if (z2 > 2 * f2) {
                    var C2 = h2.sub(h2.sub(d2)._mult(f2 / z2)._round());
                    this.updateDistance(d2, C2), this.addCurrentVertex(C2, v2, 0, 0, y2), d2 = C2;
                  }
                }
                var B2 = d2 && m2, P2 = B2 ? r2 : l2 ? "butt" : n2;
                if (B2 && "round" === P2 && (A2 < a2 ? P2 = "miter" : A2 <= 2 && (P2 = "fakeround")), "miter" === P2 && A2 > i2 && (P2 = "bevel"), "bevel" === P2 && (A2 > 2 && (P2 = "flipbevel"), A2 < i2 && (P2 = "miter")), d2 && this.updateDistance(d2, h2), "miter" === P2)
                  b2._mult(A2), this.addCurrentVertex(h2, b2, 0, 0, y2);
                else if ("flipbevel" === P2) {
                  if (A2 > 100)
                    b2 = g2.mult(-1);
                  else {
                    var T2 = A2 * v2.add(g2).mag() / v2.sub(g2).mag();
                    b2._perp()._mult(T2 * (I2 ? -1 : 1));
                  }
                  this.addCurrentVertex(h2, b2, 0, 0, y2), this.addCurrentVertex(h2, b2.mult(-1), 0, 0, y2);
                } else if ("bevel" === P2 || "fakeround" === P2) {
                  var E2 = -Math.sqrt(A2 * A2 - 1), M2 = I2 ? E2 : 0, V2 = I2 ? 0 : E2;
                  if (d2 && this.addCurrentVertex(h2, v2, M2, V2, y2), "fakeround" === P2)
                    for (var F2 = Math.round(180 * S2 / Math.PI / 20), L2 = 1; L2 < F2; L2++) {
                      var O2 = L2 / F2;
                      if (0.5 !== O2) {
                        var D2 = O2 - 0.5;
                        O2 += O2 * D2 * (O2 - 1) * ((1.0904 + _2 * (_2 * (3.55645 - 1.43519 * _2) - 3.2452)) * D2 * D2 + (0.848013 + _2 * (0.215638 * _2 - 1.06021)));
                      }
                      var R2 = g2.sub(v2)._mult(O2)._add(v2)._unit()._mult(I2 ? -1 : 1);
                      this.addHalfVertex(h2, R2.x, R2.y, false, I2, 0, y2);
                    }
                  m2 && this.addCurrentVertex(h2, g2, -M2, -V2, y2);
                } else if ("butt" === P2)
                  this.addCurrentVertex(h2, b2, 0, 0, y2);
                else if ("square" === P2) {
                  var U2 = d2 ? 1 : -1;
                  this.addCurrentVertex(h2, b2, U2, U2, y2);
                } else
                  "round" === P2 && (d2 && (this.addCurrentVertex(h2, v2, 0, 0, y2), this.addCurrentVertex(h2, v2, 1, 1, y2, true)), m2 && (this.addCurrentVertex(h2, g2, -1, -1, y2, true), this.addCurrentVertex(h2, g2, 0, 0, y2)));
                if (k2 && x2 < p2 - 1) {
                  var j2 = h2.dist(m2);
                  if (j2 > 2 * f2) {
                    var q2 = h2.add(m2.sub(h2)._mult(f2 / j2)._round());
                    this.updateDistance(h2, q2), this.addCurrentVertex(q2, g2, 0, 0, y2), h2 = q2;
                  }
                }
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e2, o2, s2);
          }
        }, ms.prototype.addCurrentVertex = function(t2, e2, r2, n2, i2, a2) {
          void 0 === a2 && (a2 = false);
          var o2 = e2.x + e2.y * r2, s2 = e2.y - e2.x * r2, u2 = -e2.x + e2.y * n2, l2 = -e2.y - e2.x * n2;
          this.addHalfVertex(t2, o2, s2, a2, false, r2, i2), this.addHalfVertex(t2, u2, l2, a2, true, -n2, i2), this.distance > ds / 2 && 0 === this.totalDistance && (this.distance = 0, this.addCurrentVertex(t2, e2, r2, n2, i2, a2));
        }, ms.prototype.addHalfVertex = function(t2, e2, r2, n2, i2, a2, o2) {
          var s2 = t2.x, u2 = t2.y, l2 = 0.5 * this.scaledDistance;
          this.layoutVertexArray.emplaceBack((s2 << 1) + (n2 ? 1 : 0), (u2 << 1) + (i2 ? 1 : 0), Math.round(63 * e2) + 128, Math.round(63 * r2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1) | (63 & l2) << 2, l2 >> 6);
          var p2 = o2.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, p2), o2.primitiveLength++), i2 ? this.e2 = p2 : this.e1 = p2;
        }, ms.prototype.updateDistance = function(t2, e2) {
          this.distance += t2.dist(e2), this.scaledDistance = this.totalDistance > 0 ? (this.clipStart + (this.clipEnd - this.clipStart) * this.distance / this.totalDistance) * (ds - 1) : this.distance;
        }, vn("LineBucket", ms, { omit: ["layers", "patternFeatures"] });
        var vs = new ii({ "line-cap": new Qn(Ct.layout_line["line-cap"]), "line-join": new ti(Ct.layout_line["line-join"]), "line-miter-limit": new Qn(Ct.layout_line["line-miter-limit"]), "line-round-limit": new Qn(Ct.layout_line["line-round-limit"]), "line-sort-key": new ti(Ct.layout_line["line-sort-key"]) }), gs = { paint: new ii({ "line-opacity": new ti(Ct.paint_line["line-opacity"]), "line-color": new ti(Ct.paint_line["line-color"]), "line-translate": new Qn(Ct.paint_line["line-translate"]), "line-translate-anchor": new Qn(Ct.paint_line["line-translate-anchor"]), "line-width": new ti(Ct.paint_line["line-width"]), "line-gap-width": new ti(Ct.paint_line["line-gap-width"]), "line-offset": new ti(Ct.paint_line["line-offset"]), "line-blur": new ti(Ct.paint_line["line-blur"]), "line-dasharray": new ri(Ct.paint_line["line-dasharray"]), "line-pattern": new ei(Ct.paint_line["line-pattern"]), "line-gradient": new ni(Ct.paint_line["line-gradient"]) }), layout: vs }, xs = new (function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.possiblyEvaluate = function(e3, r2) {
            return r2 = new Kn(Math.floor(r2.zoom), { now: r2.now, fadeDuration: r2.fadeDuration, zoomHistory: r2.zoomHistory, transition: r2.transition }), t2.prototype.possiblyEvaluate.call(this, e3, r2);
          }, e2.prototype.evaluate = function(e3, r2, n2, i2) {
            return r2 = p({}, r2, { zoom: Math.floor(r2.zoom) }), t2.prototype.evaluate.call(this, e3, r2, n2, i2);
          }, e2;
        }(ti))(gs.paint.properties["line-width"].specification);
        xs.useIntegerZoom = true;
        var bs = function(t2) {
          function e2(e3) {
            t2.call(this, e3, gs);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype._handleSpecialPaintPropertyUpdate = function(t3) {
            "line-gradient" === t3 && this._updateGradient();
          }, e2.prototype._updateGradient = function() {
            var t3 = this._transitionablePaint._values["line-gradient"].value.expression;
            this.gradient = eo(t3, "lineProgress"), this.gradientTexture = null;
          }, e2.prototype.recalculate = function(e3, r2) {
            t2.prototype.recalculate.call(this, e3, r2), this.paint._values["line-floorwidth"] = xs.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e3);
          }, e2.prototype.createBucket = function(t3) {
            return new ms(t3);
          }, e2.prototype.queryRadius = function(t3) {
            var e3 = t3, r2 = _s(Oa("line-width", this, e3), Oa("line-gap-width", this, e3)), n2 = Oa("line-offset", this, e3);
            return r2 / 2 + Math.abs(n2) + Da(this.paint.get("line-translate"));
          }, e2.prototype.queryIntersectsFeature = function(t3, e3, r2, n2, a2, o2, s2) {
            var u2 = Ra(t3, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o2.angle, s2), l2 = s2 / 2 * _s(this.paint.get("line-width").evaluate(e3, r2), this.paint.get("line-gap-width").evaluate(e3, r2)), p2 = this.paint.get("line-offset").evaluate(e3, r2);
            return p2 && (n2 = function(t4, e4) {
              for (var r3 = [], n3 = new i(0, 0), a3 = 0; a3 < t4.length; a3++) {
                for (var o3 = t4[a3], s3 = [], u3 = 0; u3 < o3.length; u3++) {
                  var l3 = o3[u3 - 1], p3 = o3[u3], c2 = o3[u3 + 1], h2 = 0 === u3 ? n3 : p3.sub(l3)._unit()._perp(), f2 = u3 === o3.length - 1 ? n3 : c2.sub(p3)._unit()._perp(), y2 = h2._add(f2)._unit(), d2 = y2.x * f2.x + y2.y * f2.y;
                  y2._mult(1 / d2), s3.push(y2._mult(e4)._add(p3));
                }
                r3.push(s3);
              }
              return r3;
            }(n2, p2 * s2)), function(t4, e4, r3) {
              for (var n3 = 0; n3 < e4.length; n3++) {
                var i2 = e4[n3];
                if (t4.length >= 3) {
                  for (var a3 = 0; a3 < i2.length; a3++)
                    if (Fa(t4, i2[a3]))
                      return true;
                }
                if (Ba(t4, i2, r3))
                  return true;
              }
              return false;
            }(u2, n2, l2);
          }, e2.prototype.isTileClipped = function() {
            return true;
          }, e2;
        }(ai);
        function _s(t2, e2) {
          return e2 > 0 ? e2 + 2 * t2 : t2;
        }
        var ws = li([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), As = li([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4), Ss = (li([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4), li([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }])), ks = (li([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }, { type: "Int16", name: "radius" }, { type: "Int16", name: "signedDistanceFromAnchor" }]), li([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4)), Is = li([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4);
        li([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), li([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }]), li([{ type: "Float32", name: "offsetX" }]), li([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
        function zs(t2, e2, r2) {
          return t2.sections.forEach(function(t3) {
            t3.text = function(t4, e3, r3) {
              var n2 = e3.layout.get("text-transform").evaluate(r3, {});
              return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), Nn.applyArabicShaping && (t4 = Nn.applyArabicShaping(t4)), t4;
            }(t3.text, e2, r2);
          }), t2;
        }
        var Cs = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
        var Bs = function(t2, e2, r2, n2, i2) {
          var a2, o2, s2 = 8 * i2 - n2 - 1, u2 = (1 << s2) - 1, l2 = u2 >> 1, p2 = -7, c2 = r2 ? i2 - 1 : 0, h2 = r2 ? -1 : 1, f2 = t2[e2 + c2];
          for (c2 += h2, a2 = f2 & (1 << -p2) - 1, f2 >>= -p2, p2 += s2; p2 > 0; a2 = 256 * a2 + t2[e2 + c2], c2 += h2, p2 -= 8)
            ;
          for (o2 = a2 & (1 << -p2) - 1, a2 >>= -p2, p2 += n2; p2 > 0; o2 = 256 * o2 + t2[e2 + c2], c2 += h2, p2 -= 8)
            ;
          if (0 === a2)
            a2 = 1 - l2;
          else {
            if (a2 === u2)
              return o2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
            o2 += Math.pow(2, n2), a2 -= l2;
          }
          return (f2 ? -1 : 1) * o2 * Math.pow(2, a2 - n2);
        }, Ps = function(t2, e2, r2, n2, i2, a2) {
          var o2, s2, u2, l2 = 8 * a2 - i2 - 1, p2 = (1 << l2) - 1, c2 = p2 >> 1, h2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : a2 - 1, y2 = n2 ? 1 : -1, d2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
          for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (s2 = isNaN(e2) ? 1 : 0, o2 = p2) : (o2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (u2 = Math.pow(2, -o2)) < 1 && (o2--, u2 *= 2), (e2 += o2 + c2 >= 1 ? h2 / u2 : h2 * Math.pow(2, 1 - c2)) * u2 >= 2 && (o2++, u2 /= 2), o2 + c2 >= p2 ? (s2 = 0, o2 = p2) : o2 + c2 >= 1 ? (s2 = (e2 * u2 - 1) * Math.pow(2, i2), o2 += c2) : (s2 = e2 * Math.pow(2, c2 - 1) * Math.pow(2, i2), o2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & s2, f2 += y2, s2 /= 256, i2 -= 8)
            ;
          for (o2 = o2 << i2 | s2, l2 += i2; l2 > 0; t2[r2 + f2] = 255 & o2, f2 += y2, o2 /= 256, l2 -= 8)
            ;
          t2[r2 + f2 - y2] |= 128 * d2;
        }, Ts = Es;
        function Es(t2) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        Es.Varint = 0, Es.Fixed64 = 1, Es.Bytes = 2, Es.Fixed32 = 5;
        var Ms = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function Vs(t2) {
          return t2.type === Es.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
        }
        function Fs(t2, e2, r2) {
          return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
        }
        function Ls(t2, e2, r2) {
          var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
          r2.realloc(n2);
          for (var i2 = r2.pos - 1; i2 >= t2; i2--)
            r2.buf[i2 + n2] = r2.buf[i2];
        }
        function Os(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeVarint(t2[r2]);
        }
        function Ds(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeSVarint(t2[r2]);
        }
        function Rs(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeFloat(t2[r2]);
        }
        function Us(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeDouble(t2[r2]);
        }
        function js(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeBoolean(t2[r2]);
        }
        function qs(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeFixed32(t2[r2]);
        }
        function Ns(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeSFixed32(t2[r2]);
        }
        function Ks(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeFixed64(t2[r2]);
        }
        function Xs(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeSFixed64(t2[r2]);
        }
        function Zs(t2, e2) {
          return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
        }
        function Gs(t2, e2, r2) {
          t2[r2] = e2, t2[r2 + 1] = e2 >>> 8, t2[r2 + 2] = e2 >>> 16, t2[r2 + 3] = e2 >>> 24;
        }
        function Js(t2, e2) {
          return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
        }
        Es.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t2, e2, r2) {
          for (r2 = r2 || this.length; this.pos < r2; ) {
            var n2 = this.readVarint(), i2 = n2 >> 3, a2 = this.pos;
            this.type = 7 & n2, t2(i2, e2, this), this.pos === a2 && this.skip(n2);
          }
          return e2;
        }, readMessage: function(t2, e2) {
          return this.readFields(t2, e2, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t2 = Zs(this.buf, this.pos);
          return this.pos += 4, t2;
        }, readSFixed32: function() {
          var t2 = Js(this.buf, this.pos);
          return this.pos += 4, t2;
        }, readFixed64: function() {
          var t2 = Zs(this.buf, this.pos) + 4294967296 * Zs(this.buf, this.pos + 4);
          return this.pos += 8, t2;
        }, readSFixed64: function() {
          var t2 = Zs(this.buf, this.pos) + 4294967296 * Js(this.buf, this.pos + 4);
          return this.pos += 8, t2;
        }, readFloat: function() {
          var t2 = Bs(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t2;
        }, readDouble: function() {
          var t2 = Bs(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t2;
        }, readVarint: function(t2) {
          var e2, r2, n2 = this.buf;
          return e2 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e2 : function(t3, e3, r3) {
            var n3, i2, a2 = r3.buf;
            if (i2 = a2[r3.pos++], n3 = (112 & i2) >> 4, i2 < 128)
              return Fs(t3, n3, e3);
            if (i2 = a2[r3.pos++], n3 |= (127 & i2) << 3, i2 < 128)
              return Fs(t3, n3, e3);
            if (i2 = a2[r3.pos++], n3 |= (127 & i2) << 10, i2 < 128)
              return Fs(t3, n3, e3);
            if (i2 = a2[r3.pos++], n3 |= (127 & i2) << 17, i2 < 128)
              return Fs(t3, n3, e3);
            if (i2 = a2[r3.pos++], n3 |= (127 & i2) << 24, i2 < 128)
              return Fs(t3, n3, e3);
            if (i2 = a2[r3.pos++], n3 |= (1 & i2) << 31, i2 < 128)
              return Fs(t3, n3, e3);
            throw new Error("Expected varint not more than 10 bytes");
          }(e2 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t2 = this.readVarint();
          return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t2 = this.readVarint() + this.pos, e2 = this.pos;
          return this.pos = t2, t2 - e2 >= 12 && Ms ? function(t3, e3, r2) {
            return Ms.decode(t3.subarray(e3, r2));
          }(this.buf, e2, t2) : function(t3, e3, r2) {
            var n2 = "", i2 = e3;
            for (; i2 < r2; ) {
              var a2, o2, s2, u2 = t3[i2], l2 = null, p2 = u2 > 239 ? 4 : u2 > 223 ? 3 : u2 > 191 ? 2 : 1;
              if (i2 + p2 > r2)
                break;
              1 === p2 ? u2 < 128 && (l2 = u2) : 2 === p2 ? 128 == (192 & (a2 = t3[i2 + 1])) && (l2 = (31 & u2) << 6 | 63 & a2) <= 127 && (l2 = null) : 3 === p2 ? (a2 = t3[i2 + 1], o2 = t3[i2 + 2], 128 == (192 & a2) && 128 == (192 & o2) && ((l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & o2) <= 2047 || l2 >= 55296 && l2 <= 57343) && (l2 = null)) : 4 === p2 && (a2 = t3[i2 + 1], o2 = t3[i2 + 2], s2 = t3[i2 + 3], 128 == (192 & a2) && 128 == (192 & o2) && 128 == (192 & s2) && ((l2 = (15 & u2) << 18 | (63 & a2) << 12 | (63 & o2) << 6 | 63 & s2) <= 65535 || l2 >= 1114112) && (l2 = null)), null === l2 ? (l2 = 65533, p2 = 1) : l2 > 65535 && (l2 -= 65536, n2 += String.fromCharCode(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), n2 += String.fromCharCode(l2), i2 += p2;
            }
            return n2;
          }(this.buf, e2, t2);
        }, readBytes: function() {
          var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
          return this.pos = t2, e2;
        }, readPackedVarint: function(t2, e2) {
          if (this.type !== Es.Bytes)
            return t2.push(this.readVarint(e2));
          var r2 = Vs(this);
          for (t2 = t2 || []; this.pos < r2; )
            t2.push(this.readVarint(e2));
          return t2;
        }, readPackedSVarint: function(t2) {
          if (this.type !== Es.Bytes)
            return t2.push(this.readSVarint());
          var e2 = Vs(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readSVarint());
          return t2;
        }, readPackedBoolean: function(t2) {
          if (this.type !== Es.Bytes)
            return t2.push(this.readBoolean());
          var e2 = Vs(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readBoolean());
          return t2;
        }, readPackedFloat: function(t2) {
          if (this.type !== Es.Bytes)
            return t2.push(this.readFloat());
          var e2 = Vs(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readFloat());
          return t2;
        }, readPackedDouble: function(t2) {
          if (this.type !== Es.Bytes)
            return t2.push(this.readDouble());
          var e2 = Vs(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readDouble());
          return t2;
        }, readPackedFixed32: function(t2) {
          if (this.type !== Es.Bytes)
            return t2.push(this.readFixed32());
          var e2 = Vs(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readFixed32());
          return t2;
        }, readPackedSFixed32: function(t2) {
          if (this.type !== Es.Bytes)
            return t2.push(this.readSFixed32());
          var e2 = Vs(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readSFixed32());
          return t2;
        }, readPackedFixed64: function(t2) {
          if (this.type !== Es.Bytes)
            return t2.push(this.readFixed64());
          var e2 = Vs(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readFixed64());
          return t2;
        }, readPackedSFixed64: function(t2) {
          if (this.type !== Es.Bytes)
            return t2.push(this.readSFixed64());
          var e2 = Vs(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readSFixed64());
          return t2;
        }, skip: function(t2) {
          var e2 = 7 & t2;
          if (e2 === Es.Varint)
            for (; this.buf[this.pos++] > 127; )
              ;
          else if (e2 === Es.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (e2 === Es.Fixed32)
            this.pos += 4;
          else {
            if (e2 !== Es.Fixed64)
              throw new Error("Unimplemented type: " + e2);
            this.pos += 8;
          }
        }, writeTag: function(t2, e2) {
          this.writeVarint(t2 << 3 | e2);
        }, realloc: function(t2) {
          for (var e2 = this.length || 16; e2 < this.pos + t2; )
            e2 *= 2;
          if (e2 !== this.length) {
            var r2 = new Uint8Array(e2);
            r2.set(this.buf), this.buf = r2, this.length = e2;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t2) {
          this.realloc(4), Gs(this.buf, t2, this.pos), this.pos += 4;
        }, writeSFixed32: function(t2) {
          this.realloc(4), Gs(this.buf, t2, this.pos), this.pos += 4;
        }, writeFixed64: function(t2) {
          this.realloc(8), Gs(this.buf, -1 & t2, this.pos), Gs(this.buf, Math.floor(t2 * (1 / 4294967296)), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t2) {
          this.realloc(8), Gs(this.buf, -1 & t2, this.pos), Gs(this.buf, Math.floor(t2 * (1 / 4294967296)), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t2) {
          (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
            var r2, n2;
            t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0));
            if (t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e2.realloc(10), function(t4, e3, r3) {
              r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos] = 127 & t4;
            }(r2, 0, e2), function(t4, e3) {
              var r3 = (7 & t4) << 4;
              if (e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), !t4)
                return;
              if (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), !t4)
                return;
              if (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), !t4)
                return;
              if (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), !t4)
                return;
              if (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), !t4)
                return;
              e3.buf[e3.pos++] = 127 & t4;
            }(n2, e2);
          }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
        }, writeSVarint: function(t2) {
          this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
        }, writeBoolean: function(t2) {
          this.writeVarint(Boolean(t2));
        }, writeString: function(t2) {
          t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
          var e2 = this.pos;
          this.pos = function(t3, e3, r3) {
            for (var n2, i2, a2 = 0; a2 < e3.length; a2++) {
              if ((n2 = e3.charCodeAt(a2)) > 55295 && n2 < 57344) {
                if (!i2) {
                  n2 > 56319 || a2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                  continue;
                }
                if (n2 < 56320) {
                  t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                  continue;
                }
                n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
              } else
                i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
              n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
            }
            return r3;
          }(this.buf, t2, this.pos);
          var r2 = this.pos - e2;
          r2 >= 128 && Ls(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
        }, writeFloat: function(t2) {
          this.realloc(4), Ps(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(t2) {
          this.realloc(8), Ps(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t2) {
          var e2 = t2.length;
          this.writeVarint(e2), this.realloc(e2);
          for (var r2 = 0; r2 < e2; r2++)
            this.buf[this.pos++] = t2[r2];
        }, writeRawMessage: function(t2, e2) {
          this.pos++;
          var r2 = this.pos;
          t2(e2, this);
          var n2 = this.pos - r2;
          n2 >= 128 && Ls(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
        }, writeMessage: function(t2, e2, r2) {
          this.writeTag(t2, Es.Bytes), this.writeRawMessage(e2, r2);
        }, writePackedVarint: function(t2, e2) {
          e2.length && this.writeMessage(t2, Os, e2);
        }, writePackedSVarint: function(t2, e2) {
          e2.length && this.writeMessage(t2, Ds, e2);
        }, writePackedBoolean: function(t2, e2) {
          e2.length && this.writeMessage(t2, js, e2);
        }, writePackedFloat: function(t2, e2) {
          e2.length && this.writeMessage(t2, Rs, e2);
        }, writePackedDouble: function(t2, e2) {
          e2.length && this.writeMessage(t2, Us, e2);
        }, writePackedFixed32: function(t2, e2) {
          e2.length && this.writeMessage(t2, qs, e2);
        }, writePackedSFixed32: function(t2, e2) {
          e2.length && this.writeMessage(t2, Ns, e2);
        }, writePackedFixed64: function(t2, e2) {
          e2.length && this.writeMessage(t2, Ks, e2);
        }, writePackedSFixed64: function(t2, e2) {
          e2.length && this.writeMessage(t2, Xs, e2);
        }, writeBytesField: function(t2, e2) {
          this.writeTag(t2, Es.Bytes), this.writeBytes(e2);
        }, writeFixed32Field: function(t2, e2) {
          this.writeTag(t2, Es.Fixed32), this.writeFixed32(e2);
        }, writeSFixed32Field: function(t2, e2) {
          this.writeTag(t2, Es.Fixed32), this.writeSFixed32(e2);
        }, writeFixed64Field: function(t2, e2) {
          this.writeTag(t2, Es.Fixed64), this.writeFixed64(e2);
        }, writeSFixed64Field: function(t2, e2) {
          this.writeTag(t2, Es.Fixed64), this.writeSFixed64(e2);
        }, writeVarintField: function(t2, e2) {
          this.writeTag(t2, Es.Varint), this.writeVarint(e2);
        }, writeSVarintField: function(t2, e2) {
          this.writeTag(t2, Es.Varint), this.writeSVarint(e2);
        }, writeStringField: function(t2, e2) {
          this.writeTag(t2, Es.Bytes), this.writeString(e2);
        }, writeFloatField: function(t2, e2) {
          this.writeTag(t2, Es.Fixed32), this.writeFloat(e2);
        }, writeDoubleField: function(t2, e2) {
          this.writeTag(t2, Es.Fixed64), this.writeDouble(e2);
        }, writeBooleanField: function(t2, e2) {
          this.writeVarintField(t2, Boolean(e2));
        } };
        function Hs(t2, e2, r2) {
          1 === t2 && r2.readMessage(Ys, e2);
        }
        function Ys(t2, e2, r2) {
          if (3 === t2) {
            var n2 = r2.readMessage($s, {}), i2 = n2.id, a2 = n2.bitmap, o2 = n2.width, s2 = n2.height, u2 = n2.left, l2 = n2.top, p2 = n2.advance;
            e2.push({ id: i2, bitmap: new Wa({ width: o2 + 6, height: s2 + 6 }, a2), metrics: { width: o2, height: s2, left: u2, top: l2, advance: p2 } });
          }
        }
        function $s(t2, e2, r2) {
          1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? e2.bitmap = r2.readBytes() : 3 === t2 ? e2.width = r2.readVarint() : 4 === t2 ? e2.height = r2.readVarint() : 5 === t2 ? e2.left = r2.readSVarint() : 6 === t2 ? e2.top = r2.readSVarint() : 7 === t2 && (e2.advance = r2.readVarint());
        }
        function Ws(t2) {
          for (var e2 = 0, r2 = 0, n2 = 0, i2 = t2; n2 < i2.length; n2 += 1) {
            var a2 = i2[n2];
            e2 += a2.w * a2.h, r2 = Math.max(r2, a2.w);
          }
          t2.sort(function(t3, e3) {
            return e3.h - t3.h;
          });
          for (var o2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }], s2 = 0, u2 = 0, l2 = 0, p2 = t2; l2 < p2.length; l2 += 1)
            for (var c2 = p2[l2], h2 = o2.length - 1; h2 >= 0; h2--) {
              var f2 = o2[h2];
              if (!(c2.w > f2.w || c2.h > f2.h)) {
                if (c2.x = f2.x, c2.y = f2.y, u2 = Math.max(u2, c2.y + c2.h), s2 = Math.max(s2, c2.x + c2.w), c2.w === f2.w && c2.h === f2.h) {
                  var y2 = o2.pop();
                  h2 < o2.length && (o2[h2] = y2);
                } else
                  c2.h === f2.h ? (f2.x += c2.w, f2.w -= c2.w) : c2.w === f2.w ? (f2.y += c2.h, f2.h -= c2.h) : (o2.push({ x: f2.x + c2.w, y: f2.y, w: f2.w - c2.w, h: c2.h }), f2.y += c2.h, f2.h -= c2.h);
                break;
              }
            }
          return { w: s2, h: u2, fill: e2 / (s2 * u2) || 0 };
        }
        var Qs = function(t2, e2) {
          var r2 = e2.pixelRatio, n2 = e2.version, i2 = e2.stretchX, a2 = e2.stretchY, o2 = e2.content;
          this.paddedRect = t2, this.pixelRatio = r2, this.stretchX = i2, this.stretchY = a2, this.content = o2, this.version = n2;
        }, tu = { tl: { configurable: true }, br: { configurable: true }, tlbr: { configurable: true }, displaySize: { configurable: true } };
        tu.tl.get = function() {
          return [this.paddedRect.x + 1, this.paddedRect.y + 1];
        }, tu.br.get = function() {
          return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
        }, tu.tlbr.get = function() {
          return this.tl.concat(this.br);
        }, tu.displaySize.get = function() {
          return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
        }, Object.defineProperties(Qs.prototype, tu);
        var eu = function(t2, e2) {
          var r2 = {}, n2 = {};
          this.haveRenderCallbacks = [];
          var i2 = [];
          this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
          var a2 = Ws(i2), o2 = a2.w, s2 = a2.h, u2 = new Qa({ width: o2 || 1, height: s2 || 1 });
          for (var l2 in t2) {
            var p2 = t2[l2], c2 = r2[l2].paddedRect;
            Qa.copy(p2.data, u2, { x: 0, y: 0 }, { x: c2.x + 1, y: c2.y + 1 }, p2.data);
          }
          for (var h2 in e2) {
            var f2 = e2[h2], y2 = n2[h2].paddedRect, d2 = y2.x + 1, m2 = y2.y + 1, v2 = f2.data.width, g2 = f2.data.height;
            Qa.copy(f2.data, u2, { x: 0, y: 0 }, { x: d2, y: m2 }, f2.data), Qa.copy(f2.data, u2, { x: 0, y: g2 - 1 }, { x: d2, y: m2 - 1 }, { width: v2, height: 1 }), Qa.copy(f2.data, u2, { x: 0, y: 0 }, { x: d2, y: m2 + g2 }, { width: v2, height: 1 }), Qa.copy(f2.data, u2, { x: v2 - 1, y: 0 }, { x: d2 - 1, y: m2 }, { width: 1, height: g2 }), Qa.copy(f2.data, u2, { x: 0, y: 0 }, { x: d2 + v2, y: m2 }, { width: 1, height: g2 });
          }
          this.image = u2, this.iconPositions = r2, this.patternPositions = n2;
        };
        eu.prototype.addImages = function(t2, e2, r2) {
          for (var n2 in t2) {
            var i2 = t2[n2], a2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
            r2.push(a2), e2[n2] = new Qs(a2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
          }
        }, eu.prototype.patchUpdatedImages = function(t2, e2) {
          for (var r2 in t2.dispatchRenderCallbacks(this.haveRenderCallbacks), t2.updatedImages)
            this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
        }, eu.prototype.patchUpdatedImage = function(t2, e2, r2) {
          if (t2 && e2 && t2.version !== e2.version) {
            t2.version = e2.version;
            var n2 = t2.tl, i2 = n2[0], a2 = n2[1];
            r2.update(e2.data, void 0, { x: i2, y: a2 });
          }
        }, vn("ImagePosition", Qs), vn("ImageAtlas", eu);
        var ru = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
        var nu = function() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        };
        nu.forText = function(t2, e2) {
          var r2 = new nu();
          return r2.scale = t2 || 1, r2.fontStack = e2, r2;
        }, nu.forImage = function(t2) {
          var e2 = new nu();
          return e2.imageName = t2, e2;
        };
        var iu = function() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        };
        function au(t2, e2, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2) {
          var m2, v2 = iu.fromFeature(t2, i2);
          c2 === ru.vertical && v2.verticalizePunctuation();
          var g2 = Nn.processBidirectionalText, x2 = Nn.processStyledBidirectionalText;
          if (g2 && 1 === v2.sections.length) {
            m2 = [];
            for (var b2 = 0, _2 = g2(v2.toString(), hu(v2, l2, a2, e2, n2, f2, y2)); b2 < _2.length; b2 += 1) {
              var w2 = _2[b2], A2 = new iu();
              A2.text = w2, A2.sections = v2.sections;
              for (var S2 = 0; S2 < w2.length; S2++)
                A2.sectionIndex.push(0);
              m2.push(A2);
            }
          } else if (x2) {
            m2 = [];
            for (var k2 = 0, I2 = x2(v2.text, v2.sectionIndex, hu(v2, l2, a2, e2, n2, f2, y2)); k2 < I2.length; k2 += 1) {
              var z2 = I2[k2], C2 = new iu();
              C2.text = z2[0], C2.sectionIndex = z2[1], C2.sections = v2.sections, m2.push(C2);
            }
          } else
            m2 = function(t3, e3) {
              for (var r3 = [], n3 = t3.text, i3 = 0, a3 = 0, o3 = e3; a3 < o3.length; a3 += 1) {
                var s3 = o3[a3];
                r3.push(t3.substring(i3, s3)), i3 = s3;
              }
              return i3 < n3.length && r3.push(t3.substring(i3, n3.length)), r3;
            }(v2, hu(v2, l2, a2, e2, n2, f2, y2));
          var B2 = [], P2 = { positionedLines: B2, text: v2.toString(), top: p2[1], bottom: p2[1], left: p2[0], right: p2[0], writingMode: c2, iconsInText: false, verticalizable: false };
          return function(t3, e3, r3, n3, i3, a3, o3, s3, u3, l3, p3, c3) {
            for (var h3 = 0, f3 = -17, y3 = 0, d3 = 0, m3 = "right" === s3 ? 1 : "left" === s3 ? 0 : 0.5, v3 = 0, g3 = 0, x3 = i3; g3 < x3.length; g3 += 1) {
              var b3 = x3[g3];
              b3.trim();
              var _3 = b3.getMaxScale(), w3 = 24 * (_3 - 1), A3 = { positionedGlyphs: [], lineOffset: 0 };
              t3.positionedLines[v3] = A3;
              var S3 = A3.positionedGlyphs, k3 = 0;
              if (b3.length()) {
                for (var I3 = 0; I3 < b3.length(); I3++) {
                  var z3 = b3.getSection(I3), C3 = b3.getSectionIndex(I3), B3 = b3.getCharCode(I3), P3 = 0, T2 = null, E2 = null, M2 = null, V2 = 24, F2 = !(u3 === ru.horizontal || !p3 && !zn(B3) || p3 && (ou[B3] || (Z2 = B3, Sn.Arabic(Z2) || Sn["Arabic Supplement"](Z2) || Sn["Arabic Extended-A"](Z2) || Sn["Arabic Presentation Forms-A"](Z2) || Sn["Arabic Presentation Forms-B"](Z2))));
                  if (z3.imageName) {
                    var L2 = n3[z3.imageName];
                    if (!L2)
                      continue;
                    M2 = z3.imageName, t3.iconsInText = t3.iconsInText || true, E2 = L2.paddedRect;
                    var O2 = L2.displaySize;
                    z3.scale = 24 * z3.scale / c3, T2 = { width: O2[0], height: O2[1], left: 1, top: -3, advance: F2 ? O2[1] : O2[0] };
                    var D2 = 24 - O2[1] * z3.scale;
                    P3 = w3 + D2, V2 = T2.advance;
                    var R2 = F2 ? O2[0] * z3.scale - 24 * _3 : O2[1] * z3.scale - 24 * _3;
                    R2 > 0 && R2 > k3 && (k3 = R2);
                  } else {
                    var U2 = r3[z3.fontStack], j2 = U2 && U2[B3];
                    if (j2 && j2.rect)
                      E2 = j2.rect, T2 = j2.metrics;
                    else {
                      var q2 = e3[z3.fontStack], N2 = q2 && q2[B3];
                      if (!N2)
                        continue;
                      T2 = N2.metrics;
                    }
                    P3 = 24 * (_3 - z3.scale);
                  }
                  F2 ? (t3.verticalizable = true, S3.push({ glyph: B3, imageName: M2, x: h3, y: f3 + P3, vertical: F2, scale: z3.scale, fontStack: z3.fontStack, sectionIndex: C3, metrics: T2, rect: E2 }), h3 += V2 * z3.scale + l3) : (S3.push({ glyph: B3, imageName: M2, x: h3, y: f3 + P3, vertical: F2, scale: z3.scale, fontStack: z3.fontStack, sectionIndex: C3, metrics: T2, rect: E2 }), h3 += T2.advance * z3.scale + l3);
                }
                if (0 !== S3.length) {
                  var K2 = h3 - l3;
                  y3 = Math.max(K2, y3), yu(S3, 0, S3.length - 1, m3, k3);
                }
                h3 = 0;
                var X2 = a3 * _3 + k3;
                A3.lineOffset = Math.max(k3, w3), f3 += X2, d3 = Math.max(X2, d3), ++v3;
              } else
                f3 += a3, ++v3;
            }
            var Z2;
            var G2 = f3 - -17, J2 = fu(o3), H2 = J2.horizontalAlign, Y2 = J2.verticalAlign;
            (function(t4, e4, r4, n4, i4, a4, o4, s4, u4) {
              var l4 = (e4 - r4) * i4, p4 = 0;
              p4 = a4 !== o4 ? -s4 * n4 - -17 : (-n4 * u4 + 0.5) * o4;
              for (var c4 = 0, h4 = t4; c4 < h4.length; c4 += 1)
                for (var f4 = h4[c4], y4 = 0, d4 = f4.positionedGlyphs; y4 < d4.length; y4 += 1) {
                  var m4 = d4[y4];
                  m4.x += l4, m4.y += p4;
                }
            })(t3.positionedLines, m3, H2, Y2, y3, d3, a3, G2, i3.length), t3.top += -Y2 * G2, t3.bottom = t3.top + G2, t3.left += -H2 * y3, t3.right = t3.left + y3;
          }(P2, e2, r2, n2, m2, o2, s2, u2, c2, l2, h2, d2), !function(t3) {
            for (var e3 = 0, r3 = t3; e3 < r3.length; e3 += 1) {
              if (0 !== r3[e3].positionedGlyphs.length)
                return false;
            }
            return true;
          }(B2) && P2;
        }
        iu.fromFeature = function(t2, e2) {
          for (var r2 = new iu(), n2 = 0; n2 < t2.sections.length; n2++) {
            var i2 = t2.sections[n2];
            i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
          }
          return r2;
        }, iu.prototype.length = function() {
          return this.text.length;
        }, iu.prototype.getSection = function(t2) {
          return this.sections[this.sectionIndex[t2]];
        }, iu.prototype.getSectionIndex = function(t2) {
          return this.sectionIndex[t2];
        }, iu.prototype.getCharCode = function(t2) {
          return this.text.charCodeAt(t2);
        }, iu.prototype.verticalizePunctuation = function() {
          this.text = function(t2) {
            for (var e2 = "", r2 = 0; r2 < t2.length; r2++) {
              var n2 = t2.charCodeAt(r2 + 1) || null, i2 = t2.charCodeAt(r2 - 1) || null;
              (!n2 || !Cn(n2) || Cs[t2[r2 + 1]]) && (!i2 || !Cn(i2) || Cs[t2[r2 - 1]]) && Cs[t2[r2]] ? e2 += Cs[t2[r2]] : e2 += t2[r2];
            }
            return e2;
          }(this.text);
        }, iu.prototype.trim = function() {
          for (var t2 = 0, e2 = 0; e2 < this.text.length && ou[this.text.charCodeAt(e2)]; e2++)
            t2++;
          for (var r2 = this.text.length, n2 = this.text.length - 1; n2 >= 0 && n2 >= t2 && ou[this.text.charCodeAt(n2)]; n2--)
            r2--;
          this.text = this.text.substring(t2, r2), this.sectionIndex = this.sectionIndex.slice(t2, r2);
        }, iu.prototype.substring = function(t2, e2) {
          var r2 = new iu();
          return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
        }, iu.prototype.toString = function() {
          return this.text;
        }, iu.prototype.getMaxScale = function() {
          var t2 = this;
          return this.sectionIndex.reduce(function(e2, r2) {
            return Math.max(e2, t2.sections[r2].scale);
          }, 0);
        }, iu.prototype.addTextSection = function(t2, e2) {
          this.text += t2.text, this.sections.push(nu.forText(t2.scale, t2.fontStack || e2));
          for (var r2 = this.sections.length - 1, n2 = 0; n2 < t2.text.length; ++n2)
            this.sectionIndex.push(r2);
        }, iu.prototype.addImageSection = function(t2) {
          var e2 = t2.image ? t2.image.name : "";
          if (0 !== e2.length) {
            var r2 = this.getNextImageSectionCharCode();
            r2 ? (this.text += String.fromCharCode(r2), this.sections.push(nu.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : _("Reached maximum number of images 6401");
          } else
            _("Can't add FormattedSection with an empty image.");
        }, iu.prototype.getNextImageSectionCharCode = function() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        };
        var ou = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, su = {};
        function uu(t2, e2, r2, n2, i2, a2) {
          if (e2.imageName) {
            var o2 = n2[e2.imageName];
            return o2 ? o2.displaySize[0] * e2.scale * 24 / a2 + i2 : 0;
          }
          var s2 = r2[e2.fontStack], u2 = s2 && s2[t2];
          return u2 ? u2.metrics.advance * e2.scale + i2 : 0;
        }
        function lu(t2, e2, r2, n2) {
          var i2 = Math.pow(t2 - e2, 2);
          return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
        }
        function pu(t2, e2, r2) {
          var n2 = 0;
          return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
        }
        function cu(t2, e2, r2, n2, i2, a2) {
          for (var o2 = null, s2 = lu(e2, r2, i2, a2), u2 = 0, l2 = n2; u2 < l2.length; u2 += 1) {
            var p2 = l2[u2], c2 = lu(e2 - p2.x, r2, i2, a2) + p2.badness;
            c2 <= s2 && (o2 = p2, s2 = c2);
          }
          return { index: t2, x: e2, priorBreak: o2, badness: s2 };
        }
        function hu(t2, e2, r2, n2, i2, a2, o2) {
          if ("point" !== a2)
            return [];
          if (!t2)
            return [];
          for (var s2, u2 = [], l2 = function(t3, e3, r3, n3, i3, a3) {
            for (var o3 = 0, s3 = 0; s3 < t3.length(); s3++) {
              var u3 = t3.getSection(s3);
              o3 += uu(t3.getCharCode(s3), u3, n3, i3, e3, a3);
            }
            return o3 / Math.max(1, Math.ceil(o3 / r3));
          }(t2, e2, r2, n2, i2, o2), p2 = t2.text.indexOf("") >= 0, c2 = 0, h2 = 0; h2 < t2.length(); h2++) {
            var f2 = t2.getSection(h2), y2 = t2.getCharCode(h2);
            if (ou[y2] || (c2 += uu(y2, f2, n2, i2, e2, o2)), h2 < t2.length() - 1) {
              var d2 = !!(!((s2 = y2) < 11904) && (Sn["Bopomofo Extended"](s2) || Sn.Bopomofo(s2) || Sn["CJK Compatibility Forms"](s2) || Sn["CJK Compatibility Ideographs"](s2) || Sn["CJK Compatibility"](s2) || Sn["CJK Radicals Supplement"](s2) || Sn["CJK Strokes"](s2) || Sn["CJK Symbols and Punctuation"](s2) || Sn["CJK Unified Ideographs Extension A"](s2) || Sn["CJK Unified Ideographs"](s2) || Sn["Enclosed CJK Letters and Months"](s2) || Sn["Halfwidth and Fullwidth Forms"](s2) || Sn.Hiragana(s2) || Sn["Ideographic Description Characters"](s2) || Sn["Kangxi Radicals"](s2) || Sn["Katakana Phonetic Extensions"](s2) || Sn.Katakana(s2) || Sn["Vertical Forms"](s2) || Sn["Yi Radicals"](s2) || Sn["Yi Syllables"](s2)));
              (su[y2] || d2 || f2.imageName) && u2.push(cu(h2 + 1, c2, l2, u2, pu(y2, t2.getCharCode(h2 + 1), d2 && p2), false));
            }
          }
          return function t3(e3) {
            return e3 ? t3(e3.priorBreak).concat(e3.index) : [];
          }(cu(t2.length(), c2, l2, u2, 0, true));
        }
        function fu(t2) {
          var e2 = 0.5, r2 = 0.5;
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              e2 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e2 = 0;
          }
          switch (t2) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r2 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r2 = 0;
          }
          return { horizontalAlign: e2, verticalAlign: r2 };
        }
        function yu(t2, e2, r2, n2, i2) {
          if (n2 || i2)
            for (var a2 = t2[r2], o2 = a2.metrics.advance * a2.scale, s2 = (t2[r2].x + o2) * n2, u2 = e2; u2 <= r2; u2++)
              t2[u2].x -= s2, t2[u2].y += i2;
        }
        function du(t2, e2, r2, n2, i2, a2) {
          var o2, s2 = t2.image;
          if (s2.content) {
            var u2 = s2.content, l2 = s2.pixelRatio || 1;
            o2 = [u2[0] / l2, u2[1] / l2, s2.displaySize[0] - u2[2] / l2, s2.displaySize[1] - u2[3] / l2];
          }
          var p2, c2, h2, f2, y2 = e2.left * a2, d2 = e2.right * a2;
          "width" === r2 || "both" === r2 ? (f2 = i2[0] + y2 - n2[3], c2 = i2[0] + d2 + n2[1]) : c2 = (f2 = i2[0] + (y2 + d2 - s2.displaySize[0]) / 2) + s2.displaySize[0];
          var m2 = e2.top * a2, v2 = e2.bottom * a2;
          return "height" === r2 || "both" === r2 ? (p2 = i2[1] + m2 - n2[0], h2 = i2[1] + v2 + n2[2]) : h2 = (p2 = i2[1] + (m2 + v2 - s2.displaySize[1]) / 2) + s2.displaySize[1], { image: s2, top: p2, right: c2, bottom: h2, left: f2, collisionPadding: o2 };
        }
        su[10] = true, su[32] = true, su[38] = true, su[40] = true, su[41] = true, su[43] = true, su[45] = true, su[47] = true, su[173] = true, su[183] = true, su[8203] = true, su[8208] = true, su[8211] = true, su[8231] = true;
        var mu = function(t2) {
          function e2(e3, r2, n2, i2) {
            t2.call(this, e3, r2), this.angle = n2, void 0 !== i2 && (this.segment = i2);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.clone = function() {
            return new e2(this.x, this.y, this.angle, this.segment);
          }, e2;
        }(i);
        vn("Anchor", mu);
        function vu(t2, e2) {
          var r2 = e2.expression;
          if ("constant" === r2.kind)
            return { kind: "constant", layoutSize: r2.evaluate(new Kn(t2 + 1)) };
          if ("source" === r2.kind)
            return { kind: "source" };
          for (var n2 = r2.zoomStops, i2 = r2.interpolationType, a2 = 0; a2 < n2.length && n2[a2] <= t2; )
            a2++;
          for (var o2 = a2 = Math.max(0, a2 - 1); o2 < n2.length && n2[o2] < t2 + 1; )
            o2++;
          o2 = Math.min(n2.length - 1, o2);
          var s2 = n2[a2], u2 = n2[o2];
          return "composite" === r2.kind ? { kind: "composite", minZoom: s2, maxZoom: u2, interpolationType: i2 } : { kind: "camera", minZoom: s2, maxZoom: u2, minSize: r2.evaluate(new Kn(s2)), maxSize: r2.evaluate(new Kn(u2)), interpolationType: i2 };
        }
        function gu(t2, e2, r2) {
          var n2 = e2.uSize, i2 = e2.uSizeT, a2 = r2.lowerSize, o2 = r2.upperSize;
          return "source" === t2.kind ? a2 / 128 : "composite" === t2.kind ? Se(a2 / 128, o2 / 128, i2) : n2;
        }
        function xu(t2, e2) {
          var r2 = 0, n2 = 0;
          if ("constant" === t2.kind)
            n2 = t2.layoutSize;
          else if ("source" !== t2.kind) {
            var i2 = t2.interpolationType, a2 = t2.minZoom, o2 = t2.maxZoom, s2 = i2 ? u(Ue.interpolationFactor(i2, e2, a2, o2), 0, 1) : 0;
            "camera" === t2.kind ? n2 = Se(t2.minSize, t2.maxSize, s2) : r2 = s2;
          }
          return { uSizeT: r2, uSize: n2 };
        }
        var bu = Object.freeze({ __proto__: null, getSizeData: vu, evaluateSizeForFeature: gu, evaluateSizeForZoom: xu, SIZE_PACK_FACTOR: 128 });
        function _u(t2, e2, r2, n2, i2) {
          if (void 0 === e2.segment)
            return true;
          for (var a2 = e2, o2 = e2.segment + 1, s2 = 0; s2 > -r2 / 2; ) {
            if (--o2 < 0)
              return false;
            s2 -= t2[o2].dist(a2), a2 = t2[o2];
          }
          s2 += t2[o2].dist(t2[o2 + 1]), o2++;
          for (var u2 = [], l2 = 0; s2 < r2 / 2; ) {
            var p2 = t2[o2 - 1], c2 = t2[o2], h2 = t2[o2 + 1];
            if (!h2)
              return false;
            var f2 = p2.angleTo(c2) - c2.angleTo(h2);
            for (f2 = Math.abs((f2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), u2.push({ distance: s2, angleDelta: f2 }), l2 += f2; s2 - u2[0].distance > n2; )
              l2 -= u2.shift().angleDelta;
            if (l2 > i2)
              return false;
            o2++, s2 += c2.dist(h2);
          }
          return true;
        }
        function wu(t2) {
          for (var e2 = 0, r2 = 0; r2 < t2.length - 1; r2++)
            e2 += t2[r2].dist(t2[r2 + 1]);
          return e2;
        }
        function Au(t2, e2, r2) {
          return t2 ? 0.6 * e2 * r2 : 0;
        }
        function Su(t2, e2) {
          return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
        }
        function ku(t2, e2, r2, n2, i2, a2) {
          for (var o2 = Au(r2, i2, a2), s2 = Su(r2, n2) * a2, u2 = 0, l2 = wu(t2) / 2, p2 = 0; p2 < t2.length - 1; p2++) {
            var c2 = t2[p2], h2 = t2[p2 + 1], f2 = c2.dist(h2);
            if (u2 + f2 > l2) {
              var y2 = (l2 - u2) / f2, d2 = Se(c2.x, h2.x, y2), m2 = Se(c2.y, h2.y, y2), v2 = new mu(d2, m2, h2.angleTo(c2), p2);
              return v2._round(), !o2 || _u(t2, v2, s2, o2, e2) ? v2 : void 0;
            }
            u2 += f2;
          }
        }
        function Iu(t2, e2, r2, n2, i2, a2, o2, s2, u2) {
          var l2 = Au(n2, a2, o2), p2 = Su(n2, i2), c2 = p2 * o2, h2 = 0 === t2[0].x || t2[0].x === u2 || 0 === t2[0].y || t2[0].y === u2;
          return e2 - c2 < e2 / 4 && (e2 = c2 + e2 / 4), function t3(e3, r3, n3, i3, a3, o3, s3, u3, l3) {
            for (var p3 = o3 / 2, c3 = wu(e3), h3 = 0, f2 = r3 - n3, y2 = [], d2 = 0; d2 < e3.length - 1; d2++) {
              for (var m2 = e3[d2], v2 = e3[d2 + 1], g2 = m2.dist(v2), x2 = v2.angleTo(m2); f2 + n3 < h3 + g2; ) {
                var b2 = ((f2 += n3) - h3) / g2, _2 = Se(m2.x, v2.x, b2), w2 = Se(m2.y, v2.y, b2);
                if (_2 >= 0 && _2 < l3 && w2 >= 0 && w2 < l3 && f2 - p3 >= 0 && f2 + p3 <= c3) {
                  var A2 = new mu(_2, w2, x2, d2);
                  A2._round(), i3 && !_u(e3, A2, o3, i3, a3) || y2.push(A2);
                }
              }
              h3 += g2;
            }
            u3 || y2.length || s3 || (y2 = t3(e3, h3 / 2, n3, i3, a3, o3, s3, true, l3));
            return y2;
          }(t2, h2 ? e2 / 2 * s2 % e2 : (p2 / 2 + 2 * a2) * o2 * s2 % e2, e2, l2, r2, c2, h2, false, u2);
        }
        function zu(t2, e2, r2, n2) {
          var a2 = [], o2 = t2.image, s2 = o2.pixelRatio, u2 = o2.paddedRect.w - 2, l2 = o2.paddedRect.h - 2, p2 = t2.right - t2.left, c2 = t2.bottom - t2.top, h2 = o2.stretchX || [[0, u2]], f2 = o2.stretchY || [[0, l2]], y2 = function(t3, e3) {
            return t3 + e3[1] - e3[0];
          }, d2 = h2.reduce(y2, 0), m2 = f2.reduce(y2, 0), v2 = u2 - d2, g2 = l2 - m2, x2 = 0, b2 = d2, _2 = 0, w2 = m2, A2 = 0, S2 = v2, k2 = 0, I2 = g2;
          if (o2.content && n2) {
            var z2 = o2.content;
            x2 = Cu(h2, 0, z2[0]), _2 = Cu(f2, 0, z2[1]), b2 = Cu(h2, z2[0], z2[2]), w2 = Cu(f2, z2[1], z2[3]), A2 = z2[0] - x2, k2 = z2[1] - _2, S2 = z2[2] - z2[0] - b2, I2 = z2[3] - z2[1] - w2;
          }
          var C2 = function(n3, a3, u3, l3) {
            var h3 = Pu(n3.stretch - x2, b2, p2, t2.left), f3 = Tu(n3.fixed - A2, S2, n3.stretch, d2), y3 = Pu(a3.stretch - _2, w2, c2, t2.top), v3 = Tu(a3.fixed - k2, I2, a3.stretch, m2), g3 = Pu(u3.stretch - x2, b2, p2, t2.left), z3 = Tu(u3.fixed - A2, S2, u3.stretch, d2), C3 = Pu(l3.stretch - _2, w2, c2, t2.top), B3 = Tu(l3.fixed - k2, I2, l3.stretch, m2), P3 = new i(h3, y3), T3 = new i(g3, y3), E3 = new i(g3, C3), M3 = new i(h3, C3), V3 = new i(f3 / s2, v3 / s2), F3 = new i(z3 / s2, B3 / s2), L3 = e2 * Math.PI / 180;
            if (L3) {
              var O2 = Math.sin(L3), D2 = Math.cos(L3), R2 = [D2, -O2, O2, D2];
              P3._matMult(R2), T3._matMult(R2), M3._matMult(R2), E3._matMult(R2);
            }
            var U2 = n3.stretch + n3.fixed, j2 = u3.stretch + u3.fixed, q2 = a3.stretch + a3.fixed, N2 = l3.stretch + l3.fixed;
            return { tl: P3, tr: T3, bl: M3, br: E3, tex: { x: o2.paddedRect.x + 1 + U2, y: o2.paddedRect.y + 1 + q2, w: j2 - U2, h: N2 - q2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: V3, pixelOffsetBR: F3, minFontScaleX: S2 / s2 / p2, minFontScaleY: I2 / s2 / c2, isSDF: r2 };
          };
          if (n2 && (o2.stretchX || o2.stretchY))
            for (var B2 = Bu(h2, v2, d2), P2 = Bu(f2, g2, m2), T2 = 0; T2 < B2.length - 1; T2++)
              for (var E2 = B2[T2], M2 = B2[T2 + 1], V2 = 0; V2 < P2.length - 1; V2++) {
                var F2 = P2[V2], L2 = P2[V2 + 1];
                a2.push(C2(E2, F2, M2, L2));
              }
          else
            a2.push(C2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: u2 + 1 }, { fixed: 0, stretch: l2 + 1 }));
          return a2;
        }
        function Cu(t2, e2, r2) {
          for (var n2 = 0, i2 = 0, a2 = t2; i2 < a2.length; i2 += 1) {
            var o2 = a2[i2];
            n2 += Math.max(e2, Math.min(r2, o2[1])) - Math.max(e2, Math.min(r2, o2[0]));
          }
          return n2;
        }
        function Bu(t2, e2, r2) {
          for (var n2 = [{ fixed: -1, stretch: 0 }], i2 = 0, a2 = t2; i2 < a2.length; i2 += 1) {
            var o2 = a2[i2], s2 = o2[0], u2 = o2[1], l2 = n2[n2.length - 1];
            n2.push({ fixed: s2 - l2.stretch, stretch: l2.stretch }), n2.push({ fixed: s2 - l2.stretch, stretch: l2.stretch + (u2 - s2) });
          }
          return n2.push({ fixed: e2 + 1, stretch: r2 }), n2;
        }
        function Pu(t2, e2, r2, n2) {
          return t2 / e2 * r2 + n2;
        }
        function Tu(t2, e2, r2, n2) {
          return t2 - e2 * r2 / n2;
        }
        var Eu = function(t2, e2, r2, n2, a2, o2, s2, u2, l2, p2, c2, h2) {
          var f2 = s2.top * u2 - l2, y2 = s2.bottom * u2 + l2, d2 = s2.left * u2 - l2, m2 = s2.right * u2 + l2, v2 = s2.collisionPadding;
          if (v2 && (d2 -= v2[0] * u2, f2 -= v2[1] * u2, m2 += v2[2] * u2, y2 += v2[3] * u2), this.boxStartIndex = t2.length, p2) {
            var g2 = y2 - f2, x2 = m2 - d2;
            g2 > 0 && (g2 = Math.max(10 * u2, g2), this._addLineCollisionCircles(t2, e2, r2, r2.segment, x2, g2, n2, a2, o2, c2));
          } else {
            if (h2) {
              var b2 = new i(d2, f2), _2 = new i(m2, f2), w2 = new i(d2, y2), A2 = new i(m2, y2), S2 = h2 * Math.PI / 180;
              b2._rotate(S2), _2._rotate(S2), w2._rotate(S2), A2._rotate(S2), d2 = Math.min(b2.x, _2.x, w2.x, A2.x), m2 = Math.max(b2.x, _2.x, w2.x, A2.x), f2 = Math.min(b2.y, _2.y, w2.y, A2.y), y2 = Math.max(b2.y, _2.y, w2.y, A2.y);
            }
            t2.emplaceBack(r2.x, r2.y, d2, f2, m2, y2, n2, a2, o2, 0, 0);
          }
          this.boxEndIndex = t2.length;
        };
        Eu.prototype._addLineCollisionCircles = function(t2, e2, r2, n2, i2, a2, o2, s2, u2, l2) {
          var p2 = a2 / 2, c2 = Math.floor(i2 / p2) || 1, h2 = 1 + 0.4 * Math.log(l2) / Math.LN2, f2 = Math.floor(c2 * h2 / 2), y2 = -a2 / 2, d2 = r2, m2 = n2 + 1, v2 = y2, g2 = -i2 / 2, x2 = g2 - i2 / 4;
          do {
            if (--m2 < 0) {
              if (v2 > g2)
                return;
              m2 = 0;
              break;
            }
            v2 -= e2[m2].dist(d2), d2 = e2[m2];
          } while (v2 > x2);
          for (var b2 = e2[m2].dist(e2[m2 + 1]), _2 = -f2; _2 < c2 + f2; _2++) {
            var w2 = _2 * p2, A2 = g2 + w2;
            if (w2 < 0 && (A2 += w2), w2 > i2 && (A2 += w2 - i2), !(A2 < v2)) {
              for (; v2 + b2 < A2; ) {
                if (v2 += b2, ++m2 + 1 >= e2.length)
                  return;
                b2 = e2[m2].dist(e2[m2 + 1]);
              }
              var S2 = A2 - v2, k2 = e2[m2], I2 = e2[m2 + 1].sub(k2)._unit()._mult(S2)._add(k2)._round(), z2 = Math.abs(A2 - y2) < p2 ? 0 : 0.8 * (A2 - y2);
              t2.emplaceBack(I2.x, I2.y, -a2 / 2, -a2 / 2, a2 / 2, a2 / 2, o2, s2, u2, a2 / 2, z2);
            }
          }
        };
        var Mu = function(t2, e2) {
          if (void 0 === t2 && (t2 = []), void 0 === e2 && (e2 = Vu), this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
            for (var r2 = (this.length >> 1) - 1; r2 >= 0; r2--)
              this._down(r2);
        };
        function Vu(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function Fu(t2, e2, r2) {
          void 0 === e2 && (e2 = 1), void 0 === r2 && (r2 = false);
          for (var n2 = 1 / 0, a2 = 1 / 0, o2 = -1 / 0, s2 = -1 / 0, u2 = t2[0], l2 = 0; l2 < u2.length; l2++) {
            var p2 = u2[l2];
            (!l2 || p2.x < n2) && (n2 = p2.x), (!l2 || p2.y < a2) && (a2 = p2.y), (!l2 || p2.x > o2) && (o2 = p2.x), (!l2 || p2.y > s2) && (s2 = p2.y);
          }
          var c2 = o2 - n2, h2 = s2 - a2, f2 = Math.min(c2, h2), y2 = f2 / 2, d2 = new Mu([], Lu);
          if (0 === f2)
            return new i(n2, a2);
          for (var m2 = n2; m2 < o2; m2 += f2)
            for (var v2 = a2; v2 < s2; v2 += f2)
              d2.push(new Ou(m2 + y2, v2 + y2, y2, t2));
          for (var g2 = function(t3) {
            for (var e3 = 0, r3 = 0, n3 = 0, i2 = t3[0], a3 = 0, o3 = i2.length, s3 = o3 - 1; a3 < o3; s3 = a3++) {
              var u3 = i2[a3], l3 = i2[s3], p3 = u3.x * l3.y - l3.x * u3.y;
              r3 += (u3.x + l3.x) * p3, n3 += (u3.y + l3.y) * p3, e3 += 3 * p3;
            }
            return new Ou(r3 / e3, n3 / e3, 0, t3);
          }(t2), x2 = d2.length; d2.length; ) {
            var b2 = d2.pop();
            (b2.d > g2.d || !g2.d) && (g2 = b2, r2 && console.log("found best %d after %d probes", Math.round(1e4 * b2.d) / 1e4, x2)), b2.max - g2.d <= e2 || (y2 = b2.h / 2, d2.push(new Ou(b2.p.x - y2, b2.p.y - y2, y2, t2)), d2.push(new Ou(b2.p.x + y2, b2.p.y - y2, y2, t2)), d2.push(new Ou(b2.p.x - y2, b2.p.y + y2, y2, t2)), d2.push(new Ou(b2.p.x + y2, b2.p.y + y2, y2, t2)), x2 += 4);
          }
          return r2 && (console.log("num probes: " + x2), console.log("best distance: " + g2.d)), g2.p;
        }
        function Lu(t2, e2) {
          return e2.max - t2.max;
        }
        function Ou(t2, e2, r2, n2) {
          this.p = new i(t2, e2), this.h = r2, this.d = function(t3, e3) {
            for (var r3 = false, n3 = 1 / 0, i2 = 0; i2 < e3.length; i2++)
              for (var a2 = e3[i2], o2 = 0, s2 = a2.length, u2 = s2 - 1; o2 < s2; u2 = o2++) {
                var l2 = a2[o2], p2 = a2[u2];
                l2.y > t3.y != p2.y > t3.y && t3.x < (p2.x - l2.x) * (t3.y - l2.y) / (p2.y - l2.y) + l2.x && (r3 = !r3), n3 = Math.min(n3, Ma(t3, l2, p2));
              }
            return (r3 ? 1 : -1) * Math.sqrt(n3);
          }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
        }
        Mu.prototype.push = function(t2) {
          this.data.push(t2), this.length++, this._up(this.length - 1);
        }, Mu.prototype.pop = function() {
          if (0 !== this.length) {
            var t2 = this.data[0], e2 = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
          }
        }, Mu.prototype.peek = function() {
          return this.data[0];
        }, Mu.prototype._up = function(t2) {
          for (var e2 = this.data, r2 = this.compare, n2 = e2[t2]; t2 > 0; ) {
            var i2 = t2 - 1 >> 1, a2 = e2[i2];
            if (r2(n2, a2) >= 0)
              break;
            e2[t2] = a2, t2 = i2;
          }
          e2[t2] = n2;
        }, Mu.prototype._down = function(t2) {
          for (var e2 = this.data, r2 = this.compare, n2 = this.length >> 1, i2 = e2[t2]; t2 < n2; ) {
            var a2 = 1 + (t2 << 1), o2 = e2[a2], s2 = a2 + 1;
            if (s2 < this.length && r2(e2[s2], o2) < 0 && (a2 = s2, o2 = e2[s2]), r2(o2, i2) >= 0)
              break;
            e2[t2] = o2, t2 = a2;
          }
          e2[t2] = i2;
        };
        var Du = Number.POSITIVE_INFINITY;
        function Ru(t2, e2) {
          return e2[1] !== Du ? function(t3, e3, r2) {
            var n2 = 0, i2 = 0;
            switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t3) {
              case "top-right":
              case "top-left":
              case "top":
                i2 = r2 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i2 = 7 - r2;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
              case "right":
                n2 = -e3;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n2 = e3;
            }
            return [n2, i2];
          }(t2, e2[0], e2[1]) : function(t3, e3) {
            var r2 = 0, n2 = 0;
            e3 < 0 && (e3 = 0);
            var i2 = e3 / Math.sqrt(2);
            switch (t3) {
              case "top-right":
              case "top-left":
                n2 = i2 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                n2 = 7 - i2;
                break;
              case "bottom":
                n2 = 7 - e3;
                break;
              case "top":
                n2 = e3 - 7;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
                r2 = -i2;
                break;
              case "top-left":
              case "bottom-left":
                r2 = i2;
                break;
              case "left":
                r2 = e3;
                break;
              case "right":
                r2 = -e3;
            }
            return [r2, n2];
          }(t2, e2[0]);
        }
        function Uu(t2) {
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function ju(t2, e2, r2, n2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2) {
          var d2 = function(t3, e3, r3, n3, a3, o3, s3, u3) {
            for (var l3 = n3.layout.get("text-rotate").evaluate(o3, {}) * Math.PI / 180, p3 = [], c3 = 0, h3 = e3.positionedLines; c3 < h3.length; c3 += 1)
              for (var f3 = h3[c3], y3 = 0, d3 = f3.positionedGlyphs; y3 < d3.length; y3 += 1) {
                var m3 = d3[y3];
                if (m3.rect) {
                  var v3 = m3.rect || {}, g3 = 4, x3 = true, b2 = 1, _2 = 0, w2 = (a3 || u3) && m3.vertical, A2 = m3.metrics.advance * m3.scale / 2;
                  if (u3 && e3.verticalizable) {
                    var S2 = 24 * (m3.scale - 1), k2 = (24 - m3.metrics.width * m3.scale) / 2;
                    _2 = f3.lineOffset / 2 - (m3.imageName ? -k2 : S2);
                  }
                  if (m3.imageName) {
                    var I2 = s3[m3.imageName];
                    x3 = I2.sdf, g3 = 1 / (b2 = I2.pixelRatio);
                  }
                  var z2 = a3 ? [m3.x + A2, m3.y] : [0, 0], C2 = a3 ? [0, 0] : [m3.x + A2 + r3[0], m3.y + r3[1] - _2], B2 = [0, 0];
                  w2 && (B2 = C2, C2 = [0, 0]);
                  var P2 = (m3.metrics.left - g3) * m3.scale - A2 + C2[0], T2 = (-m3.metrics.top - g3) * m3.scale + C2[1], E2 = P2 + v3.w * m3.scale / b2, M2 = T2 + v3.h * m3.scale / b2, V2 = new i(P2, T2), F2 = new i(E2, T2), L2 = new i(P2, M2), O2 = new i(E2, M2);
                  if (w2) {
                    var D2 = new i(-A2, A2 - -17), R2 = -Math.PI / 2, U2 = 12 - A2, j2 = m3.imageName ? U2 : 0, q2 = new i(22 - U2, -j2), N2 = new (Function.prototype.bind.apply(i, [null].concat(B2)))();
                    V2._rotateAround(R2, D2)._add(q2)._add(N2), F2._rotateAround(R2, D2)._add(q2)._add(N2), L2._rotateAround(R2, D2)._add(q2)._add(N2), O2._rotateAround(R2, D2)._add(q2)._add(N2);
                  }
                  if (l3) {
                    var K2 = Math.sin(l3), X2 = Math.cos(l3), Z2 = [X2, -K2, K2, X2];
                    V2._matMult(Z2), F2._matMult(Z2), L2._matMult(Z2), O2._matMult(Z2);
                  }
                  var G2 = new i(0, 0), J2 = new i(0, 0);
                  p3.push({ tl: V2, tr: F2, bl: L2, br: O2, tex: v3, writingMode: e3.writingMode, glyphOffset: z2, sectionIndex: m3.sectionIndex, isSDF: x3, pixelOffsetTL: G2, pixelOffsetBR: J2, minFontScaleX: 0, minFontScaleY: 0 });
                }
              }
            return p3;
          }(0, r2, u2, a2, o2, s2, n2, t2.allowVerticalPlacement), m2 = t2.textSizeData, v2 = null;
          "source" === m2.kind ? (v2 = [128 * a2.layout.get("text-size").evaluate(s2, {})])[0] > 32640 && _(t2.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".') : "composite" === m2.kind && ((v2 = [128 * y2.compositeTextSizes[0].evaluate(s2, {}), 128 * y2.compositeTextSizes[1].evaluate(s2, {})])[0] > 32640 || v2[1] > 32640) && _(t2.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".'), t2.addSymbols(t2.text, d2, v2, u2, o2, s2, p2, e2, l2.lineStartIndex, l2.lineLength, f2);
          for (var g2 = 0, x2 = c2; g2 < x2.length; g2 += 1) {
            h2[x2[g2]] = t2.text.placedSymbolArray.length - 1;
          }
          return 4 * d2.length;
        }
        function qu(t2) {
          for (var e2 in t2)
            return t2[e2];
          return null;
        }
        function Nu(t2, e2, r2, n2) {
          var i2 = t2.compareText;
          if (e2 in i2) {
            for (var a2 = i2[e2], o2 = a2.length - 1; o2 >= 0; o2--)
              if (n2.dist(a2[o2]) < r2)
                return true;
          } else
            i2[e2] = [];
          return i2[e2].push(n2), false;
        }
        var Ku = es.VectorTileFeature.types, Xu = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function Zu(t2, e2, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2) {
          var f2 = s2 ? Math.min(32640, Math.round(s2[0])) : 0, y2 = s2 ? Math.min(32640, Math.round(s2[1])) : 0;
          t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), a2, o2, (f2 << 1) + (u2 ? 1 : 0), y2, 16 * l2, 16 * p2, 256 * c2, 256 * h2);
        }
        function Gu(t2, e2, r2) {
          t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2);
        }
        function Ju(t2) {
          for (var e2 = 0, r2 = t2.sections; e2 < r2.length; e2 += 1) {
            if (Tn(r2[e2].text))
              return true;
          }
          return false;
        }
        var Hu = function(t2) {
          this.layoutVertexArray = new mi(), this.indexArray = new zi(), this.programConfigurations = t2, this.segments = new Xi(), this.dynamicLayoutVertexArray = new vi(), this.opacityVertexArray = new gi(), this.placedSymbolArray = new Fi();
        };
        Hu.prototype.upload = function(t2, e2, r2, n2) {
          r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, ws.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, As.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, Xu, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2);
        }, Hu.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }, vn("SymbolBuffers", Hu);
        var Yu = function(t2, e2, r2) {
          this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new Xi(), this.collisionVertexArray = new _i();
        };
        Yu.prototype.upload = function(t2) {
          this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Ss.members, true);
        }, Yu.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }, vn("CollisionBuffers", Yu);
        var $u = function(t2) {
          this.collisionBoxArray = t2.collisionBoxArray, this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
            return t3.id;
          }), this.index = t2.index, this.pixelRatio = t2.pixelRatio, this.sourceLayerIndex = t2.sourceLayerIndex, this.hasPattern = false, this.hasPaintOverrides = false, this.hasRTLText = false;
          var e2 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = vu(this.zoom, e2["text-size"]), this.iconSizeData = vu(this.zoom, e2["icon-size"]);
          var r2 = this.layers[0].layout, n2 = r2.get("symbol-sort-key"), i2 = r2.get("symbol-z-order");
          this.sortFeaturesByKey = "viewport-y" !== i2 && void 0 !== n2.constantOr(1);
          var a2 = "viewport-y" === i2 || "auto" === i2 && !this.sortFeaturesByKey;
          this.sortFeaturesByY = a2 && (r2.get("text-allow-overlap") || r2.get("icon-allow-overlap") || r2.get("text-ignore-placement") || r2.get("icon-ignore-placement")), "point" === r2.get("symbol-placement") && (this.writingModes = r2.get("text-writing-mode").map(function(t3) {
            return ru[t3];
          })), this.stateDependentLayerIds = this.layers.filter(function(t3) {
            return t3.isStateDependent();
          }).map(function(t3) {
            return t3.id;
          }), this.sourceID = t2.sourceID;
        };
        $u.prototype.createArrays = function() {
          var t2 = this.layers[0].layout;
          this.hasPaintOverrides = el.hasPaintOverrides(t2), this.text = new Hu(new ga(ws.members, this.layers, this.zoom, function(t3) {
            return /^text/.test(t3);
          })), this.icon = new Hu(new ga(ws.members, this.layers, this.zoom, function(t3) {
            return /^icon/.test(t3);
          })), this.textCollisionBox = new Yu(bi, ks.members, Ci), this.iconCollisionBox = new Yu(bi, ks.members, Ci), this.textCollisionCircle = new Yu(bi, Is.members, zi), this.iconCollisionCircle = new Yu(bi, Is.members, zi), this.glyphOffsetArray = new Ri(), this.lineVertexArray = new ji(), this.symbolInstances = new Oi();
        }, $u.prototype.calculateGlyphDependencies = function(t2, e2, r2, n2, i2) {
          for (var a2 = 0; a2 < t2.length; a2++)
            if (e2[t2.charCodeAt(a2)] = true, (r2 || n2) && i2) {
              var o2 = Cs[t2.charAt(a2)];
              o2 && (e2[o2.charCodeAt(0)] = true);
            }
        }, $u.prototype.populate = function(t2, e2) {
          var r2 = this.layers[0], n2 = r2.layout, i2 = n2.get("text-font"), a2 = n2.get("text-field"), o2 = n2.get("icon-image"), s2 = ("constant" !== a2.value.kind || a2.value.value instanceof te && !a2.value.value.isEmpty() || a2.value.value.toString().length > 0) && ("constant" !== i2.value.kind || i2.value.value.length > 0), u2 = ("constant" !== o2.value.kind || !!o2.value.value) && Object.keys(o2.parameters).length > 0, l2 = n2.get("symbol-sort-key");
          if (this.features = [], s2 || u2) {
            for (var p2 = e2.iconDependencies, c2 = e2.glyphDependencies, h2 = e2.availableImages, f2 = new Kn(this.zoom), y2 = 0, d2 = t2; y2 < d2.length; y2 += 1) {
              var m2 = d2[y2], v2 = m2.feature, g2 = m2.id, x2 = m2.index, b2 = m2.sourceLayerIndex;
              if (r2._featureFilter(f2, v2)) {
                var _2 = void 0;
                if (s2) {
                  var w2 = r2.getValueAndResolveTokens("text-field", v2, h2), A2 = te.factory(w2);
                  Ju(A2) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === jn() || this.hasRTLText && Nn.isParsed()) && (_2 = zs(A2, r2, v2));
                }
                var S2 = void 0;
                if (u2) {
                  var k2 = r2.getValueAndResolveTokens("icon-image", v2, h2);
                  S2 = k2 instanceof ee ? k2 : ee.fromString(k2);
                }
                if (_2 || S2) {
                  var I2 = this.sortFeaturesByKey ? l2.evaluate(v2, {}) : void 0, z2 = { id: g2, text: _2, icon: S2, index: x2, sourceLayerIndex: b2, geometry: Aa(v2), properties: v2.properties, type: Ku[v2.type], sortKey: I2 };
                  if (this.features.push(z2), S2 && (p2[S2.name] = true), _2) {
                    var C2 = i2.evaluate(v2, {}).join(","), B2 = "map" === n2.get("text-rotation-alignment") && "point" !== n2.get("symbol-placement");
                    this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(ru.vertical) >= 0;
                    for (var P2 = 0, T2 = _2.sections; P2 < T2.length; P2 += 1) {
                      var E2 = T2[P2];
                      if (E2.image)
                        p2[E2.image.name] = true;
                      else {
                        var M2 = kn(_2.toString()), V2 = E2.fontStack || C2, F2 = c2[V2] = c2[V2] || {};
                        this.calculateGlyphDependencies(E2.text, F2, B2, this.allowVerticalPlacement, M2);
                      }
                    }
                  }
                }
              }
            }
            "line" === n2.get("symbol-placement") && (this.features = function(t3) {
              var e3 = {}, r3 = {}, n3 = [], i3 = 0;
              function a3(e4) {
                n3.push(t3[e4]), i3++;
              }
              function o3(t4, e4, i4) {
                var a4 = r3[t4];
                return delete r3[t4], r3[e4] = a4, n3[a4].geometry[0].pop(), n3[a4].geometry[0] = n3[a4].geometry[0].concat(i4[0]), a4;
              }
              function s3(t4, r4, i4) {
                var a4 = e3[r4];
                return delete e3[r4], e3[t4] = a4, n3[a4].geometry[0].shift(), n3[a4].geometry[0] = i4[0].concat(n3[a4].geometry[0]), a4;
              }
              function u3(t4, e4, r4) {
                var n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                return t4 + ":" + n4.x + ":" + n4.y;
              }
              for (var l3 = 0; l3 < t3.length; l3++) {
                var p3 = t3[l3], c3 = p3.geometry, h3 = p3.text ? p3.text.toString() : null;
                if (h3) {
                  var f3 = u3(h3, c3), y3 = u3(h3, c3, true);
                  if (f3 in r3 && y3 in e3 && r3[f3] !== e3[y3]) {
                    var d3 = s3(f3, y3, c3), m3 = o3(f3, y3, n3[d3].geometry);
                    delete e3[f3], delete r3[y3], r3[u3(h3, n3[m3].geometry, true)] = m3, n3[d3].geometry = null;
                  } else
                    f3 in r3 ? o3(f3, y3, c3) : y3 in e3 ? s3(f3, y3, c3) : (a3(l3), e3[f3] = i3 - 1, r3[y3] = i3 - 1);
                } else
                  a3(l3);
              }
              return n3.filter(function(t4) {
                return t4.geometry;
              });
            }(this.features)), this.sortFeaturesByKey && this.features.sort(function(t3, e3) {
              return t3.sortKey - e3.sortKey;
            });
          }
        }, $u.prototype.update = function(t2, e2, r2) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2));
        }, $u.prototype.isEmpty = function() {
          return 0 === this.symbolInstances.length && !this.hasRTLText;
        }, $u.prototype.uploadPending = function() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }, $u.prototype.upload = function(t2) {
          this.uploaded || (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2), this.textCollisionCircle.upload(t2), this.iconCollisionCircle.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
        }, $u.prototype.destroy = function() {
          this.text.destroy(), this.icon.destroy(), this.textCollisionBox.destroy(), this.iconCollisionBox.destroy(), this.textCollisionCircle.destroy(), this.iconCollisionCircle.destroy();
        }, $u.prototype.addToLineVertexArray = function(t2, e2) {
          var r2 = this.lineVertexArray.length;
          if (void 0 !== t2.segment) {
            for (var n2 = t2.dist(e2[t2.segment + 1]), i2 = t2.dist(e2[t2.segment]), a2 = {}, o2 = t2.segment + 1; o2 < e2.length; o2++)
              a2[o2] = { x: e2[o2].x, y: e2[o2].y, tileUnitDistanceFromAnchor: n2 }, o2 < e2.length - 1 && (n2 += e2[o2 + 1].dist(e2[o2]));
            for (var s2 = t2.segment || 0; s2 >= 0; s2--)
              a2[s2] = { x: e2[s2].x, y: e2[s2].y, tileUnitDistanceFromAnchor: i2 }, s2 > 0 && (i2 += e2[s2 - 1].dist(e2[s2]));
            for (var u2 = 0; u2 < e2.length; u2++) {
              var l2 = a2[u2];
              this.lineVertexArray.emplaceBack(l2.x, l2.y, l2.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
        }, $u.prototype.addSymbols = function(t2, e2, r2, n2, i2, a2, o2, s2, u2, l2, p2) {
          var c2 = this, h2 = t2.indexArray, f2 = t2.layoutVertexArray, y2 = t2.dynamicLayoutVertexArray, d2 = t2.segments.prepareSegment(4 * e2.length, t2.layoutVertexArray, t2.indexArray, a2.sortKey), m2 = this.glyphOffsetArray.length, v2 = d2.vertexLength, g2 = this.allowVerticalPlacement && o2 === ru.vertical ? Math.PI / 2 : 0, x2 = function(t3) {
            var e3 = t3.tl, n3 = t3.tr, i3 = t3.bl, a3 = t3.br, o3 = t3.tex, u3 = t3.pixelOffsetTL, l3 = t3.pixelOffsetBR, p3 = t3.minFontScaleX, m3 = t3.minFontScaleY, v3 = d2.vertexLength, x3 = t3.glyphOffset[1];
            Zu(f2, s2.x, s2.y, e3.x, x3 + e3.y, o3.x, o3.y, r2, t3.isSDF, u3.x, u3.y, p3, m3), Zu(f2, s2.x, s2.y, n3.x, x3 + n3.y, o3.x + o3.w, o3.y, r2, t3.isSDF, l3.x, u3.y, p3, m3), Zu(f2, s2.x, s2.y, i3.x, x3 + i3.y, o3.x, o3.y + o3.h, r2, t3.isSDF, u3.x, l3.y, p3, m3), Zu(f2, s2.x, s2.y, a3.x, x3 + a3.y, o3.x + o3.w, o3.y + o3.h, r2, t3.isSDF, l3.x, l3.y, p3, m3), Gu(y2, s2, g2), h2.emplaceBack(v3, v3 + 1, v3 + 2), h2.emplaceBack(v3 + 1, v3 + 2, v3 + 3), d2.vertexLength += 4, d2.primitiveLength += 2, c2.glyphOffsetArray.emplaceBack(t3.glyphOffset[0]);
          };
          if (a2.text && a2.text.sections) {
            var b2 = a2.text.sections;
            if (this.hasPaintOverrides) {
              for (var _2, w2 = function(e3, r3) {
                void 0 === _2 || _2 === e3 && !r3 || t2.programConfigurations.populatePaintArrays(t2.layoutVertexArray.length, a2, a2.index, {}, b2[_2]), _2 = e3;
              }, A2 = 0, S2 = e2; A2 < S2.length; A2 += 1) {
                var k2 = S2[A2];
                w2(k2.sectionIndex, false), x2(k2);
              }
              w2(_2, true);
            } else {
              for (var I2 = 0, z2 = e2; I2 < z2.length; I2 += 1) {
                x2(z2[I2]);
              }
              t2.programConfigurations.populatePaintArrays(t2.layoutVertexArray.length, a2, a2.index, {}, b2[0]);
            }
          } else {
            for (var C2 = 0, B2 = e2; C2 < B2.length; C2 += 1) {
              x2(B2[C2]);
            }
            t2.programConfigurations.populatePaintArrays(t2.layoutVertexArray.length, a2, a2.index, {});
          }
          t2.placedSymbolArray.emplaceBack(s2.x, s2.y, m2, this.glyphOffsetArray.length - m2, v2, u2, l2, s2.segment, r2 ? r2[0] : 0, r2 ? r2[1] : 0, n2[0], n2[1], o2, 0, false, 0, p2);
        }, $u.prototype._addCollisionDebugVertex = function(t2, e2, r2, n2, i2, a2) {
          return e2.emplaceBack(0, 0), t2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(a2.x), Math.round(a2.y));
        }, $u.prototype.addCollisionDebugVertices = function(t2, e2, r2, n2, a2, o2, s2, u2) {
          var l2 = a2.segments.prepareSegment(4, a2.layoutVertexArray, a2.indexArray), p2 = l2.vertexLength, c2 = a2.layoutVertexArray, h2 = a2.collisionVertexArray, f2 = s2.anchorX, y2 = s2.anchorY;
          if (this._addCollisionDebugVertex(c2, h2, o2, f2, y2, new i(t2, e2)), this._addCollisionDebugVertex(c2, h2, o2, f2, y2, new i(r2, e2)), this._addCollisionDebugVertex(c2, h2, o2, f2, y2, new i(r2, n2)), this._addCollisionDebugVertex(c2, h2, o2, f2, y2, new i(t2, n2)), l2.vertexLength += 4, u2) {
            var d2 = a2.indexArray;
            d2.emplaceBack(p2, p2 + 1, p2 + 2), d2.emplaceBack(p2, p2 + 2, p2 + 3), l2.primitiveLength += 2;
          } else {
            var m2 = a2.indexArray;
            m2.emplaceBack(p2, p2 + 1), m2.emplaceBack(p2 + 1, p2 + 2), m2.emplaceBack(p2 + 2, p2 + 3), m2.emplaceBack(p2 + 3, p2), l2.primitiveLength += 4;
          }
        }, $u.prototype.addDebugCollisionBoxes = function(t2, e2, r2, n2) {
          for (var i2 = t2; i2 < e2; i2++) {
            var a2 = this.collisionBoxArray.get(i2), o2 = a2.x1, s2 = a2.y1, u2 = a2.x2, l2 = a2.y2, p2 = a2.radius > 0;
            this.addCollisionDebugVertices(o2, s2, u2, l2, p2 ? n2 ? this.textCollisionCircle : this.iconCollisionCircle : n2 ? this.textCollisionBox : this.iconCollisionBox, a2.anchorPoint, r2, p2);
          }
        }, $u.prototype.generateCollisionDebugBuffers = function() {
          for (var t2 = 0; t2 < this.symbolInstances.length; t2++) {
            var e2 = this.symbolInstances.get(t2);
            this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
          }
        }, $u.prototype._deserializeCollisionBoxesForSymbol = function(t2, e2, r2, n2, i2, a2, o2, s2, u2) {
          for (var l2 = {}, p2 = e2; p2 < r2; p2++) {
            var c2 = t2.get(p2);
            if (0 === c2.radius) {
              l2.textBox = { x1: c2.x1, y1: c2.y1, x2: c2.x2, y2: c2.y2, anchorPointX: c2.anchorPointX, anchorPointY: c2.anchorPointY }, l2.textFeatureIndex = c2.featureIndex;
              break;
            }
            l2.textCircles || (l2.textCircles = [], l2.textFeatureIndex = c2.featureIndex);
            l2.textCircles.push(c2.anchorPointX, c2.anchorPointY, c2.radius, c2.signedDistanceFromAnchor, 1);
          }
          for (var h2 = n2; h2 < i2; h2++) {
            var f2 = t2.get(h2);
            if (0 === f2.radius) {
              l2.verticalTextBox = { x1: f2.x1, y1: f2.y1, x2: f2.x2, y2: f2.y2, anchorPointX: f2.anchorPointX, anchorPointY: f2.anchorPointY }, l2.verticalTextFeatureIndex = f2.featureIndex;
              break;
            }
          }
          for (var y2 = a2; y2 < o2; y2++) {
            var d2 = t2.get(y2);
            if (0 === d2.radius) {
              l2.iconBox = { x1: d2.x1, y1: d2.y1, x2: d2.x2, y2: d2.y2, anchorPointX: d2.anchorPointX, anchorPointY: d2.anchorPointY }, l2.iconFeatureIndex = d2.featureIndex;
              break;
            }
          }
          for (var m2 = s2; m2 < u2; m2++) {
            var v2 = t2.get(m2);
            if (0 === v2.radius) {
              l2.verticalIconBox = { x1: v2.x1, y1: v2.y1, x2: v2.x2, y2: v2.y2, anchorPointX: v2.anchorPointX, anchorPointY: v2.anchorPointY }, l2.verticalIconFeatureIndex = v2.featureIndex;
              break;
            }
          }
          return l2;
        }, $u.prototype.deserializeCollisionBoxes = function(t2) {
          this.collisionArrays = [];
          for (var e2 = 0; e2 < this.symbolInstances.length; e2++) {
            var r2 = this.symbolInstances.get(e2);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
          }
        }, $u.prototype.hasTextData = function() {
          return this.text.segments.get().length > 0;
        }, $u.prototype.hasIconData = function() {
          return this.icon.segments.get().length > 0;
        }, $u.prototype.hasTextCollisionBoxData = function() {
          return this.textCollisionBox.segments.get().length > 0;
        }, $u.prototype.hasIconCollisionBoxData = function() {
          return this.iconCollisionBox.segments.get().length > 0;
        }, $u.prototype.hasTextCollisionCircleData = function() {
          return this.textCollisionCircle.segments.get().length > 0;
        }, $u.prototype.hasIconCollisionCircleData = function() {
          return this.iconCollisionCircle.segments.get().length > 0;
        }, $u.prototype.addIndicesForPlacedSymbol = function(t2, e2) {
          for (var r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs, i2 = r2.vertexStartIndex; i2 < n2; i2 += 4)
            t2.indexArray.emplaceBack(i2, i2 + 1, i2 + 2), t2.indexArray.emplaceBack(i2 + 1, i2 + 2, i2 + 3);
        }, $u.prototype.getSortedSymbolIndexes = function(t2) {
          if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes)
            return this.symbolInstanceIndexes;
          for (var e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], a2 = [], o2 = 0; o2 < this.symbolInstances.length; ++o2) {
            a2.push(o2);
            var s2 = this.symbolInstances.get(o2);
            n2.push(0 | Math.round(e2 * s2.anchorX + r2 * s2.anchorY)), i2.push(s2.featureIndex);
          }
          return a2.sort(function(t3, e3) {
            return n2[t3] - n2[e3] || i2[e3] - i2[t3];
          }), a2;
        }, $u.prototype.sortFeatures = function(t2) {
          var e2 = this;
          if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (var r2 = 0, n2 = this.symbolInstanceIndexes; r2 < n2.length; r2 += 1) {
              var i2 = n2[r2], a2 = this.symbolInstances.get(i2);
              this.featureSortOrder.push(a2.featureIndex), [a2.rightJustifiedTextSymbolIndex, a2.centerJustifiedTextSymbolIndex, a2.leftJustifiedTextSymbolIndex].forEach(function(t3, r3, n3) {
                t3 >= 0 && n3.indexOf(t3) === r3 && e2.addIndicesForPlacedSymbol(e2.text, t3);
              }), a2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, a2.verticalPlacedTextSymbolIndex), a2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a2.placedIconSymbolIndex), a2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a2.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }, vn("SymbolBucket", $u, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), $u.MAX_GLYPHS = 65535, $u.addDynamicAttributes = Gu;
        var Wu = new ii({ "symbol-placement": new Qn(Ct.layout_symbol["symbol-placement"]), "symbol-spacing": new Qn(Ct.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Qn(Ct.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new ti(Ct.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Qn(Ct.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Qn(Ct.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Qn(Ct.layout_symbol["icon-ignore-placement"]), "icon-optional": new Qn(Ct.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Qn(Ct.layout_symbol["icon-rotation-alignment"]), "icon-size": new ti(Ct.layout_symbol["icon-size"]), "icon-text-fit": new Qn(Ct.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Qn(Ct.layout_symbol["icon-text-fit-padding"]), "icon-image": new ti(Ct.layout_symbol["icon-image"]), "icon-rotate": new ti(Ct.layout_symbol["icon-rotate"]), "icon-padding": new Qn(Ct.layout_symbol["icon-padding"]), "icon-keep-upright": new Qn(Ct.layout_symbol["icon-keep-upright"]), "icon-offset": new ti(Ct.layout_symbol["icon-offset"]), "icon-anchor": new ti(Ct.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Qn(Ct.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Qn(Ct.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Qn(Ct.layout_symbol["text-rotation-alignment"]), "text-field": new ti(Ct.layout_symbol["text-field"]), "text-font": new ti(Ct.layout_symbol["text-font"]), "text-size": new ti(Ct.layout_symbol["text-size"]), "text-max-width": new ti(Ct.layout_symbol["text-max-width"]), "text-line-height": new Qn(Ct.layout_symbol["text-line-height"]), "text-letter-spacing": new ti(Ct.layout_symbol["text-letter-spacing"]), "text-justify": new ti(Ct.layout_symbol["text-justify"]), "text-radial-offset": new ti(Ct.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Qn(Ct.layout_symbol["text-variable-anchor"]), "text-anchor": new ti(Ct.layout_symbol["text-anchor"]), "text-max-angle": new Qn(Ct.layout_symbol["text-max-angle"]), "text-writing-mode": new Qn(Ct.layout_symbol["text-writing-mode"]), "text-rotate": new ti(Ct.layout_symbol["text-rotate"]), "text-padding": new Qn(Ct.layout_symbol["text-padding"]), "text-keep-upright": new Qn(Ct.layout_symbol["text-keep-upright"]), "text-transform": new ti(Ct.layout_symbol["text-transform"]), "text-offset": new ti(Ct.layout_symbol["text-offset"]), "text-allow-overlap": new Qn(Ct.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Qn(Ct.layout_symbol["text-ignore-placement"]), "text-optional": new Qn(Ct.layout_symbol["text-optional"]) }), Qu = { paint: new ii({ "icon-opacity": new ti(Ct.paint_symbol["icon-opacity"]), "icon-color": new ti(Ct.paint_symbol["icon-color"]), "icon-halo-color": new ti(Ct.paint_symbol["icon-halo-color"]), "icon-halo-width": new ti(Ct.paint_symbol["icon-halo-width"]), "icon-halo-blur": new ti(Ct.paint_symbol["icon-halo-blur"]), "icon-translate": new Qn(Ct.paint_symbol["icon-translate"]), "icon-translate-anchor": new Qn(Ct.paint_symbol["icon-translate-anchor"]), "text-opacity": new ti(Ct.paint_symbol["text-opacity"]), "text-color": new ti(Ct.paint_symbol["text-color"], { runtimeType: Ut, getOverride: function(t2) {
          return t2.textColor;
        }, hasOverride: function(t2) {
          return !!t2.textColor;
        } }), "text-halo-color": new ti(Ct.paint_symbol["text-halo-color"]), "text-halo-width": new ti(Ct.paint_symbol["text-halo-width"]), "text-halo-blur": new ti(Ct.paint_symbol["text-halo-blur"]), "text-translate": new Qn(Ct.paint_symbol["text-translate"]), "text-translate-anchor": new Qn(Ct.paint_symbol["text-translate-anchor"]) }), layout: Wu }, tl = function(t2) {
          this.type = t2.property.overrides ? t2.property.overrides.runtimeType : Lt, this.defaultValue = t2;
        };
        tl.prototype.evaluate = function(t2) {
          if (t2.formattedSection) {
            var e2 = this.defaultValue.property.overrides;
            if (e2 && e2.hasOverride(t2.formattedSection))
              return e2.getOverride(t2.formattedSection);
          }
          return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
        }, tl.prototype.eachChild = function(t2) {
          this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
        }, tl.prototype.possibleOutputs = function() {
          return [void 0];
        }, tl.prototype.serialize = function() {
          return null;
        }, vn("FormatSectionOverride", tl, { omit: ["defaultValue"] });
        var el = function(t2) {
          function e2(e3) {
            t2.call(this, e3, Qu);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.recalculate = function(e3, r2) {
            if (t2.prototype.recalculate.call(this, e3, r2), "auto" === this.layout.get("icon-rotation-alignment") && ("point" !== this.layout.get("symbol-placement") ? this.layout._values["icon-rotation-alignment"] = "map" : this.layout._values["icon-rotation-alignment"] = "viewport"), "auto" === this.layout.get("text-rotation-alignment") && ("point" !== this.layout.get("symbol-placement") ? this.layout._values["text-rotation-alignment"] = "map" : this.layout._values["text-rotation-alignment"] = "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
              var n2 = this.layout.get("text-writing-mode");
              if (n2) {
                for (var i2 = [], a2 = 0, o2 = n2; a2 < o2.length; a2 += 1) {
                  var s2 = o2[a2];
                  i2.indexOf(s2) < 0 && i2.push(s2);
                }
                this.layout._values["text-writing-mode"] = i2;
              } else
                this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }, e2.prototype.getValueAndResolveTokens = function(t3, e3, r2) {
            var n2 = this.layout.get(t3).evaluate(e3, {}, r2), i2 = this._unevaluatedLayout._values[t3];
            return i2.isDataDriven() || Sr(i2.value) || !n2 ? n2 : function(t4, e4) {
              return e4.replace(/{([^{}]+)}/g, function(e5, r3) {
                return r3 in t4 ? String(t4[r3]) : "";
              });
            }(e3.properties, n2);
          }, e2.prototype.createBucket = function(t3) {
            return new $u(t3);
          }, e2.prototype.queryRadius = function() {
            return 0;
          }, e2.prototype.queryIntersectsFeature = function() {
            return false;
          }, e2.prototype._setPaintOverrides = function() {
            for (var t3 = 0, r2 = Qu.paint.overridableProperties; t3 < r2.length; t3 += 1) {
              var n2 = r2[t3];
              if (e2.hasPaintOverride(this.layout, n2)) {
                var i2 = this.paint.get(n2), a2 = new tl(i2), o2 = new Ar(a2, i2.property.specification), s2 = null;
                s2 = "constant" === i2.value.kind || "source" === i2.value.kind ? new Ir("source", o2) : new zr("composite", o2, i2.value.zoomStops, i2.value._interpolationType), this.paint._values[n2] = new $n(i2.property, s2, i2.parameters);
              }
            }
          }, e2.prototype._handleOverridablePaintPropertyUpdate = function(t3, r2, n2) {
            return !(!this.layout || r2.isDataDriven() || n2.isDataDriven()) && e2.hasPaintOverride(this.layout, t3);
          }, e2.hasPaintOverride = function(t3, e3) {
            var r2 = t3.get("text-field"), n2 = Qu.paint.properties[e3], i2 = false, a2 = function(t4) {
              for (var e4 = 0, r3 = t4; e4 < r3.length; e4 += 1) {
                var a3 = r3[e4];
                if (n2.overrides && n2.overrides.hasOverride(a3))
                  return void (i2 = true);
              }
            };
            if ("constant" === r2.value.kind && r2.value.value instanceof te)
              a2(r2.value.value.sections);
            else if ("source" === r2.value.kind) {
              var o2 = function(t4) {
                if (!i2)
                  if (t4 instanceof ae && ne(t4.value) === Kt) {
                    var e4 = t4.value;
                    a2(e4.sections);
                  } else
                    t4 instanceof le ? a2(t4.sections) : t4.eachChild(o2);
              }, s2 = r2.value;
              s2._styleExpression && o2(s2._styleExpression.expression);
            }
            return i2;
          }, e2.hasPaintOverrides = function(t3) {
            for (var r2 = 0, n2 = Qu.paint.overridableProperties; r2 < n2.length; r2 += 1) {
              var i2 = n2[r2];
              if (e2.hasPaintOverride(t3, i2))
                return true;
            }
            return false;
          }, e2;
        }(ai), rl = { paint: new ii({ "background-color": new Qn(Ct.paint_background["background-color"]), "background-pattern": new ri(Ct.paint_background["background-pattern"]), "background-opacity": new Qn(Ct.paint_background["background-opacity"]) }) }, nl = function(t2) {
          function e2(e3) {
            t2.call(this, e3, rl);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2;
        }(ai), il = { paint: new ii({ "raster-opacity": new Qn(Ct.paint_raster["raster-opacity"]), "raster-hue-rotate": new Qn(Ct.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Qn(Ct.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Qn(Ct.paint_raster["raster-brightness-max"]), "raster-saturation": new Qn(Ct.paint_raster["raster-saturation"]), "raster-contrast": new Qn(Ct.paint_raster["raster-contrast"]), "raster-resampling": new Qn(Ct.paint_raster["raster-resampling"]), "raster-fade-duration": new Qn(Ct.paint_raster["raster-fade-duration"]) }) }, al = function(t2) {
          function e2(e3) {
            t2.call(this, e3, il);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2;
        }(ai);
        var ol = function(t2) {
          function e2(e3) {
            t2.call(this, e3, {}), this.implementation = e3;
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.is3D = function() {
            return "3d" === this.implementation.renderingMode;
          }, e2.prototype.hasOffscreenPass = function() {
            return void 0 !== this.implementation.prerender;
          }, e2.prototype.recalculate = function() {
          }, e2.prototype.updateTransitions = function() {
          }, e2.prototype.hasTransition = function() {
          }, e2.prototype.serialize = function() {
          }, e2.prototype.onAdd = function(t3) {
            this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
          }, e2.prototype.onRemove = function(t3) {
            this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
          }, e2;
        }(ai), sl = { circle: Za, heatmap: ro, hillshade: io, fill: Xo, "fill-extrusion": ls, line: bs, symbol: el, background: nl, raster: al };
        var ul = self.HTMLImageElement, ll = self.HTMLCanvasElement, pl = self.HTMLVideoElement, cl = self.ImageData, hl = self.ImageBitmap, fl = function(t2, e2, r2, n2) {
          this.context = t2, this.format = r2, this.texture = t2.gl.createTexture(), this.update(e2, n2);
        };
        fl.prototype.update = function(t2, e2, r2) {
          var n2 = t2.width, i2 = t2.height, a2 = !(this.size && this.size[0] === n2 && this.size[1] === i2 || r2), o2 = this.context, s2 = o2.gl;
          if (this.useMipmap = Boolean(e2 && e2.useMipmap), s2.bindTexture(s2.TEXTURE_2D, this.texture), o2.pixelStoreUnpackFlipY.set(false), o2.pixelStoreUnpack.set(1), o2.pixelStoreUnpackPremultiplyAlpha.set(this.format === s2.RGBA && (!e2 || false !== e2.premultiply)), a2)
            this.size = [n2, i2], t2 instanceof ul || t2 instanceof ll || t2 instanceof pl || t2 instanceof cl || hl && t2 instanceof hl ? s2.texImage2D(s2.TEXTURE_2D, 0, this.format, this.format, s2.UNSIGNED_BYTE, t2) : s2.texImage2D(s2.TEXTURE_2D, 0, this.format, n2, i2, 0, this.format, s2.UNSIGNED_BYTE, t2.data);
          else {
            var u2 = r2 || { x: 0, y: 0 }, l2 = u2.x, p2 = u2.y;
            t2 instanceof ul || t2 instanceof ll || t2 instanceof pl || t2 instanceof cl || hl && t2 instanceof hl ? s2.texSubImage2D(s2.TEXTURE_2D, 0, l2, p2, s2.RGBA, s2.UNSIGNED_BYTE, t2) : s2.texSubImage2D(s2.TEXTURE_2D, 0, l2, p2, n2, i2, s2.RGBA, s2.UNSIGNED_BYTE, t2.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && s2.generateMipmap(s2.TEXTURE_2D);
        }, fl.prototype.bind = function(t2, e2, r2) {
          var n2 = this.context.gl;
          n2.bindTexture(n2.TEXTURE_2D, this.texture), r2 !== n2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r2 = n2.LINEAR), t2 !== this.filter && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MAG_FILTER, t2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MIN_FILTER, r2 || t2), this.filter = t2), e2 !== this.wrap && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_S, e2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_T, e2), this.wrap = e2);
        }, fl.prototype.isSizePowerOfTwo = function() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }, fl.prototype.destroy = function() {
          this.context.gl.deleteTexture(this.texture), this.texture = null;
        };
        var yl = function(t2) {
          var e2 = this;
          this._callback = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = function() {
            e2._triggered = false, e2._callback();
          });
        };
        yl.prototype.trigger = function() {
          var t2 = this;
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(function() {
            t2._triggered = false, t2._callback();
          }, 0));
        }, yl.prototype.remove = function() {
          delete this._channel, this._callback = function() {
          };
        };
        var dl = function(t2, e2, r2) {
          this.target = t2, this.parent = e2, this.mapId = r2, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, d(["receive", "process"], this), this.invoker = new yl(this.process), this.target.addEventListener("message", this.receive, false), this.globalScope = S() ? t2 : self;
        };
        function ml(t2, e2, r2) {
          var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
          return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
        }
        dl.prototype.send = function(t2, e2, r2, n2, i2) {
          var a2 = this;
          void 0 === i2 && (i2 = false);
          var o2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          r2 && (this.callbacks[o2] = r2);
          var s2 = z(this.globalScope) ? void 0 : [];
          return this.target.postMessage({ id: o2, type: t2, hasCallback: !!r2, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: _n(e2, s2) }, s2), { cancel: function() {
            r2 && delete a2.callbacks[o2], a2.target.postMessage({ id: o2, type: "<cancel>", targetMapId: n2, sourceMapId: a2.mapId });
          } };
        }, dl.prototype.receive = function(t2) {
          var e2 = t2.data, r2 = e2.id;
          if (r2 && (!e2.targetMapId || this.mapId === e2.targetMapId))
            if ("<cancel>" === e2.type) {
              delete this.tasks[r2];
              var n2 = this.cancelCallbacks[r2];
              delete this.cancelCallbacks[r2], n2 && n2();
            } else
              S() || e2.mustQueue ? (this.tasks[r2] = e2, this.taskQueue.push(r2), this.invoker.trigger()) : this.processTask(r2, e2);
        }, dl.prototype.process = function() {
          if (this.taskQueue.length) {
            var t2 = this.taskQueue.shift(), e2 = this.tasks[t2];
            delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), e2 && this.processTask(t2, e2);
          }
        }, dl.prototype.processTask = function(t2, e2) {
          var r2 = this;
          if ("<response>" === e2.type) {
            var n2 = this.callbacks[t2];
            delete this.callbacks[t2], n2 && (e2.error ? n2(wn(e2.error)) : n2(null, wn(e2.data)));
          } else {
            var i2 = false, a2 = z(this.globalScope) ? void 0 : [], o2 = e2.hasCallback ? function(e3, n3) {
              i2 = true, delete r2.cancelCallbacks[t2], r2.target.postMessage({ id: t2, type: "<response>", sourceMapId: r2.mapId, error: e3 ? _n(e3) : null, data: _n(n3, a2) }, a2);
            } : function(t3) {
              i2 = true;
            }, s2 = null, u2 = wn(e2.data);
            if (this.parent[e2.type])
              s2 = this.parent[e2.type](e2.sourceMapId, u2, o2);
            else if (this.parent.getWorkerSource) {
              var l2 = e2.type.split(".");
              s2 = this.parent.getWorkerSource(e2.sourceMapId, l2[0], u2.source)[l2[1]](u2, o2);
            } else
              o2(new Error("Could not find function " + e2.type));
            !i2 && s2 && s2.cancel && (this.cancelCallbacks[t2] = s2.cancel);
          }
        }, dl.prototype.remove = function() {
          this.invoker.remove(), this.target.removeEventListener("message", this.receive, false);
        };
        var vl = function(t2, e2) {
          t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : 4 === t2.length ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
        };
        vl.prototype.setNorthEast = function(t2) {
          return this._ne = t2 instanceof gl ? new gl(t2.lng, t2.lat) : gl.convert(t2), this;
        }, vl.prototype.setSouthWest = function(t2) {
          return this._sw = t2 instanceof gl ? new gl(t2.lng, t2.lat) : gl.convert(t2), this;
        }, vl.prototype.extend = function(t2) {
          var e2, r2, n2 = this._sw, i2 = this._ne;
          if (t2 instanceof gl)
            e2 = t2, r2 = t2;
          else {
            if (!(t2 instanceof vl))
              return Array.isArray(t2) ? t2.every(Array.isArray) ? this.extend(vl.convert(t2)) : this.extend(gl.convert(t2)) : this;
            if (e2 = t2._sw, r2 = t2._ne, !e2 || !r2)
              return this;
          }
          return n2 || i2 ? (n2.lng = Math.min(e2.lng, n2.lng), n2.lat = Math.min(e2.lat, n2.lat), i2.lng = Math.max(r2.lng, i2.lng), i2.lat = Math.max(r2.lat, i2.lat)) : (this._sw = new gl(e2.lng, e2.lat), this._ne = new gl(r2.lng, r2.lat)), this;
        }, vl.prototype.getCenter = function() {
          return new gl((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }, vl.prototype.getSouthWest = function() {
          return this._sw;
        }, vl.prototype.getNorthEast = function() {
          return this._ne;
        }, vl.prototype.getNorthWest = function() {
          return new gl(this.getWest(), this.getNorth());
        }, vl.prototype.getSouthEast = function() {
          return new gl(this.getEast(), this.getSouth());
        }, vl.prototype.getWest = function() {
          return this._sw.lng;
        }, vl.prototype.getSouth = function() {
          return this._sw.lat;
        }, vl.prototype.getEast = function() {
          return this._ne.lng;
        }, vl.prototype.getNorth = function() {
          return this._ne.lat;
        }, vl.prototype.toArray = function() {
          return [this._sw.toArray(), this._ne.toArray()];
        }, vl.prototype.toString = function() {
          return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")";
        }, vl.prototype.isEmpty = function() {
          return !(this._sw && this._ne);
        }, vl.prototype.contains = function(t2) {
          var e2 = gl.convert(t2), r2 = e2.lng, n2 = e2.lat, i2 = this._sw.lat <= n2 && n2 <= this._ne.lat, a2 = this._sw.lng <= r2 && r2 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (a2 = this._sw.lng >= r2 && r2 >= this._ne.lng), i2 && a2;
        }, vl.convert = function(t2) {
          return !t2 || t2 instanceof vl ? t2 : new vl(t2);
        };
        var gl = function(t2, e2) {
          if (isNaN(t2) || isNaN(e2))
            throw new Error("Invalid LngLat object: (" + t2 + ", " + e2 + ")");
          if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        };
        gl.prototype.wrap = function() {
          return new gl(l(this.lng, -180, 180), this.lat);
        }, gl.prototype.toArray = function() {
          return [this.lng, this.lat];
        }, gl.prototype.toString = function() {
          return "LngLat(" + this.lng + ", " + this.lat + ")";
        }, gl.prototype.toBounds = function(t2) {
          void 0 === t2 && (t2 = 0);
          var e2 = 360 * t2 / 40075017, r2 = e2 / Math.cos(Math.PI / 180 * this.lat);
          return new vl(new gl(this.lng - r2, this.lat - e2), new gl(this.lng + r2, this.lat + e2));
        }, gl.convert = function(t2) {
          if (t2 instanceof gl)
            return t2;
          if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length))
            return new gl(Number(t2[0]), Number(t2[1]));
          if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2)
            return new gl(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        };
        var xl = 2 * Math.PI * 6378137;
        function bl(t2) {
          return xl * Math.cos(t2 * Math.PI / 180);
        }
        function _l(t2) {
          return (180 + t2) / 360;
        }
        function wl(t2) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
        }
        function Al(t2, e2) {
          return t2 / bl(e2);
        }
        function Sl(t2) {
          var e2 = 180 - 360 * t2;
          return 360 / Math.PI * Math.atan(Math.exp(e2 * Math.PI / 180)) - 90;
        }
        var kl = function(t2, e2, r2) {
          void 0 === r2 && (r2 = 0), this.x = +t2, this.y = +e2, this.z = +r2;
        };
        kl.fromLngLat = function(t2, e2) {
          void 0 === e2 && (e2 = 0);
          var r2 = gl.convert(t2);
          return new kl(_l(r2.lng), wl(r2.lat), Al(e2, r2.lat));
        }, kl.prototype.toLngLat = function() {
          return new gl(360 * this.x - 180, Sl(this.y));
        }, kl.prototype.toAltitude = function() {
          return t2 = this.z, e2 = this.y, t2 * bl(Sl(e2));
          var t2, e2;
        }, kl.prototype.meterInMercatorCoordinateUnits = function() {
          return 1 / xl * (t2 = Sl(this.y), 1 / Math.cos(t2 * Math.PI / 180));
          var t2;
        };
        var Il = function(t2, e2, r2) {
          this.z = t2, this.x = e2, this.y = r2, this.key = Bl(0, t2, t2, e2, r2);
        };
        Il.prototype.equals = function(t2) {
          return this.z === t2.z && this.x === t2.x && this.y === t2.y;
        }, Il.prototype.url = function(t2, e2) {
          var r2, n2, i2, a2, o2, s2 = (r2 = this.x, n2 = this.y, i2 = this.z, a2 = ml(256 * r2, 256 * (n2 = Math.pow(2, i2) - n2 - 1), i2), o2 = ml(256 * (r2 + 1), 256 * (n2 + 1), i2), a2[0] + "," + a2[1] + "," + o2[0] + "," + o2[1]), u2 = function(t3, e3, r3) {
            for (var n3, i3 = "", a3 = t3; a3 > 0; a3--)
              i3 += (e3 & (n3 = 1 << a3 - 1) ? 1 : 0) + (r3 & n3 ? 2 : 0);
            return i3;
          }(this.z, this.x, this.y);
          return t2[(this.x + this.y) % t2.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String("tms" === e2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", u2).replace("{bbox-epsg-3857}", s2);
        }, Il.prototype.getTilePoint = function(t2) {
          var e2 = Math.pow(2, this.z);
          return new i(8192 * (t2.x * e2 - this.x), 8192 * (t2.y * e2 - this.y));
        }, Il.prototype.toString = function() {
          return this.z + "/" + this.x + "/" + this.y;
        };
        var zl = function(t2, e2) {
          this.wrap = t2, this.canonical = e2, this.key = Bl(t2, e2.z, e2.z, e2.x, e2.y);
        }, Cl = function(t2, e2, r2, n2, i2) {
          this.overscaledZ = t2, this.wrap = e2, this.canonical = new Il(r2, +n2, +i2), this.key = Bl(e2, t2, r2, n2, i2);
        };
        function Bl(t2, e2, r2, n2, i2) {
          (t2 *= 2) < 0 && (t2 = -1 * t2 - 1);
          var a2 = 1 << r2;
          return (a2 * a2 * t2 + a2 * i2 + n2).toString(36) + r2.toString(36) + e2.toString(36);
        }
        Cl.prototype.equals = function(t2) {
          return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
        }, Cl.prototype.scaledTo = function(t2) {
          var e2 = this.canonical.z - t2;
          return t2 > this.canonical.z ? new Cl(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Cl(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
        }, Cl.prototype.calculateScaledKey = function(t2, e2) {
          var r2 = this.canonical.z - t2;
          return t2 > this.canonical.z ? Bl(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y) : Bl(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
        }, Cl.prototype.isChildOf = function(t2) {
          if (t2.wrap !== this.wrap)
            return false;
          var e2 = this.canonical.z - t2.canonical.z;
          return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
        }, Cl.prototype.children = function(t2) {
          if (this.overscaledZ >= t2)
            return [new Cl(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          var e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
          return [new Cl(e2, this.wrap, e2, r2, n2), new Cl(e2, this.wrap, e2, r2 + 1, n2), new Cl(e2, this.wrap, e2, r2, n2 + 1), new Cl(e2, this.wrap, e2, r2 + 1, n2 + 1)];
        }, Cl.prototype.isLessThan = function(t2) {
          return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
        }, Cl.prototype.wrapped = function() {
          return new Cl(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }, Cl.prototype.unwrapTo = function(t2) {
          return new Cl(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
        }, Cl.prototype.overscaleFactor = function() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }, Cl.prototype.toUnwrapped = function() {
          return new zl(this.wrap, this.canonical);
        }, Cl.prototype.toString = function() {
          return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y;
        }, Cl.prototype.getTilePoint = function(t2) {
          return this.canonical.getTilePoint(new kl(t2.x - this.wrap, t2.y));
        }, vn("CanonicalTileID", Il), vn("OverscaledTileID", Cl, { omit: ["posMatrix"] });
        var Pl = function(t2, e2, r2) {
          if (this.uid = t2, e2.height !== e2.width)
            throw new RangeError("DEM tiles must be square");
          if (r2 && "mapbox" !== r2 && "terrarium" !== r2)
            return _('"' + r2 + '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".');
          this.stride = e2.height;
          var n2 = this.dim = e2.height - 2;
          this.data = new Uint32Array(e2.data.buffer), this.encoding = r2 || "mapbox";
          for (var i2 = 0; i2 < n2; i2++)
            this.data[this._idx(-1, i2)] = this.data[this._idx(0, i2)], this.data[this._idx(n2, i2)] = this.data[this._idx(n2 - 1, i2)], this.data[this._idx(i2, -1)] = this.data[this._idx(i2, 0)], this.data[this._idx(i2, n2)] = this.data[this._idx(i2, n2 - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(n2, -1)] = this.data[this._idx(n2 - 1, 0)], this.data[this._idx(-1, n2)] = this.data[this._idx(0, n2 - 1)], this.data[this._idx(n2, n2)] = this.data[this._idx(n2 - 1, n2 - 1)];
        };
        Pl.prototype.get = function(t2, e2) {
          var r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t2, e2);
          return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(r2[n2], r2[n2 + 1], r2[n2 + 2]);
        }, Pl.prototype.getUnpackVector = function() {
          return "terrarium" === this.encoding ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
        }, Pl.prototype._idx = function(t2, e2) {
          if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (e2 + 1) * this.stride + (t2 + 1);
        }, Pl.prototype._unpackMapbox = function(t2, e2, r2) {
          return (256 * t2 * 256 + 256 * e2 + r2) / 10 - 1e4;
        }, Pl.prototype._unpackTerrarium = function(t2, e2, r2) {
          return 256 * t2 + e2 + r2 / 256 - 32768;
        }, Pl.prototype.getPixels = function() {
          return new Qa({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }, Pl.prototype.backfillBorder = function(t2, e2, r2) {
          if (this.dim !== t2.dim)
            throw new Error("dem dimension mismatch");
          var n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, a2 = r2 * this.dim, o2 = r2 * this.dim + this.dim;
          switch (e2) {
            case -1:
              n2 = i2 - 1;
              break;
            case 1:
              i2 = n2 + 1;
          }
          switch (r2) {
            case -1:
              a2 = o2 - 1;
              break;
            case 1:
              o2 = a2 + 1;
          }
          for (var s2 = -e2 * this.dim, u2 = -r2 * this.dim, l2 = a2; l2 < o2; l2++)
            for (var p2 = n2; p2 < i2; p2++)
              this.data[this._idx(p2, l2)] = t2.data[this._idx(p2 + s2, l2 + u2)];
        }, vn("DEMData", Pl);
        var Tl = function(t2) {
          this._stringToNumber = {}, this._numberToString = [];
          for (var e2 = 0; e2 < t2.length; e2++) {
            var r2 = t2[e2];
            this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
          }
        };
        Tl.prototype.encode = function(t2) {
          return this._stringToNumber[t2];
        }, Tl.prototype.decode = function(t2) {
          return this._numberToString[t2];
        };
        var El = function(t2, e2, r2, n2, i2) {
          this.type = "Feature", this._vectorTileFeature = t2, t2._z = e2, t2._x = r2, t2._y = n2, this.properties = t2.properties, this.id = i2;
        }, Ml = { geometry: { configurable: true } };
        Ml.geometry.get = function() {
          return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }, Ml.geometry.set = function(t2) {
          this._geometry = t2;
        }, El.prototype.toJSON = function() {
          var t2 = { geometry: this.geometry };
          for (var e2 in this)
            "_geometry" !== e2 && "_vectorTileFeature" !== e2 && (t2[e2] = this[e2]);
          return t2;
        }, Object.defineProperties(El.prototype, Ml);
        var Vl = function() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        };
        Vl.prototype.updateState = function(t2, e2, r2) {
          var n2 = String(e2);
          if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][n2] = this.stateChanges[t2][n2] || {}, p(this.stateChanges[t2][n2], r2), null === this.deletedStates[t2])
            for (var i2 in this.deletedStates[t2] = {}, this.state[t2])
              i2 !== n2 && (this.deletedStates[t2][i2] = null);
          else if (this.deletedStates[t2] && null === this.deletedStates[t2][n2])
            for (var a2 in this.deletedStates[t2][n2] = {}, this.state[t2][n2])
              r2[a2] || (this.deletedStates[t2][n2][a2] = null);
          else
            for (var o2 in r2) {
              this.deletedStates[t2] && this.deletedStates[t2][n2] && null === this.deletedStates[t2][n2][o2] && delete this.deletedStates[t2][n2][o2];
            }
        }, Vl.prototype.removeFeatureState = function(t2, e2, r2) {
          if (!(null === this.deletedStates[t2])) {
            var n2 = String(e2);
            if (this.deletedStates[t2] = this.deletedStates[t2] || {}, r2 && void 0 !== e2)
              null !== this.deletedStates[t2][n2] && (this.deletedStates[t2][n2] = this.deletedStates[t2][n2] || {}, this.deletedStates[t2][n2][r2] = null);
            else if (void 0 !== e2) {
              if (this.stateChanges[t2] && this.stateChanges[t2][n2])
                for (r2 in this.deletedStates[t2][n2] = {}, this.stateChanges[t2][n2])
                  this.deletedStates[t2][n2][r2] = null;
              else
                this.deletedStates[t2][n2] = null;
            } else
              this.deletedStates[t2] = null;
          }
        }, Vl.prototype.getState = function(t2, e2) {
          var r2 = String(e2), n2 = this.state[t2] || {}, i2 = this.stateChanges[t2] || {}, a2 = p({}, n2[r2], i2[r2]);
          if (null === this.deletedStates[t2])
            return {};
          if (this.deletedStates[t2]) {
            var o2 = this.deletedStates[t2][e2];
            if (null === o2)
              return {};
            for (var s2 in o2)
              delete a2[s2];
          }
          return a2;
        }, Vl.prototype.initializeTileState = function(t2, e2) {
          t2.setFeatureState(this.state, e2);
        }, Vl.prototype.coalesceChanges = function(t2, e2) {
          var r2 = {};
          for (var n2 in this.stateChanges) {
            this.state[n2] = this.state[n2] || {};
            var i2 = {};
            for (var a2 in this.stateChanges[n2])
              this.state[n2][a2] || (this.state[n2][a2] = {}), p(this.state[n2][a2], this.stateChanges[n2][a2]), i2[a2] = this.state[n2][a2];
            r2[n2] = i2;
          }
          for (var o2 in this.deletedStates) {
            this.state[o2] = this.state[o2] || {};
            var s2 = {};
            if (null === this.deletedStates[o2])
              for (var u2 in this.state[o2])
                s2[u2] = {}, this.state[o2][u2] = {};
            else
              for (var l2 in this.deletedStates[o2]) {
                if (null === this.deletedStates[o2][l2])
                  this.state[o2][l2] = {};
                else
                  for (var c2 = 0, h2 = Object.keys(this.deletedStates[o2][l2]); c2 < h2.length; c2 += 1) {
                    var f2 = h2[c2];
                    delete this.state[o2][l2][f2];
                  }
                s2[l2] = this.state[o2][l2];
              }
            r2[o2] = r2[o2] || {}, p(r2[o2], s2);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r2).length)
            for (var y2 in t2) {
              t2[y2].setFeatureState(r2, e2);
            }
        };
        var Fl = function(t2, e2) {
          this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new hn(8192, 16, 0), this.grid3D = new hn(8192, 16, 0), this.featureIndexArray = new Ni(), this.promoteId = e2;
        };
        function Ll(t2) {
          for (var e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0, a2 = 0, o2 = t2; a2 < o2.length; a2 += 1) {
            var s2 = o2[a2];
            e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
          }
          return { minX: e2, minY: r2, maxX: n2, maxY: i2 };
        }
        function Ol(t2, e2) {
          return e2 - t2;
        }
        Fl.prototype.insert = function(t2, e2, r2, n2, i2, a2) {
          var o2 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(r2, n2, i2);
          for (var s2 = a2 ? this.grid3D : this.grid, u2 = 0; u2 < e2.length; u2++) {
            for (var l2 = e2[u2], p2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], c2 = 0; c2 < l2.length; c2++) {
              var h2 = l2[c2];
              p2[0] = Math.min(p2[0], h2.x), p2[1] = Math.min(p2[1], h2.y), p2[2] = Math.max(p2[2], h2.x), p2[3] = Math.max(p2[3], h2.y);
            }
            p2[0] < 8192 && p2[1] < 8192 && p2[2] >= 0 && p2[3] >= 0 && s2.insert(o2, p2[0], p2[1], p2[2], p2[3]);
          }
        }, Fl.prototype.loadVTLayers = function() {
          return this.vtLayers || (this.vtLayers = new es.VectorTile(new Ts(this.rawTileData)).layers, this.sourceLayerCoder = new Tl(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }, Fl.prototype.query = function(t2, e2, r2) {
          var n2 = this;
          this.loadVTLayers();
          for (var a2 = t2.params || {}, o2 = 8192 / t2.tileSize / t2.scale, s2 = Dr(a2.filter), u2 = t2.queryGeometry, l2 = t2.queryPadding * o2, p2 = Ll(u2), c2 = this.grid.query(p2.minX - l2, p2.minY - l2, p2.maxX + l2, p2.maxY + l2), h2 = Ll(t2.cameraQueryGeometry), f2 = this.grid3D.query(h2.minX - l2, h2.minY - l2, h2.maxX + l2, h2.maxY + l2, function(e3, r3, n3, a3) {
            return function(t3, e4, r4, n4, a4) {
              for (var o3 = 0, s3 = t3; o3 < s3.length; o3 += 1) {
                var u3 = s3[o3];
                if (e4 <= u3.x && r4 <= u3.y && n4 >= u3.x && a4 >= u3.y)
                  return true;
              }
              var l3 = [new i(e4, r4), new i(e4, a4), new i(n4, a4), new i(n4, r4)];
              if (t3.length > 2)
                for (var p3 = 0, c3 = l3; p3 < c3.length; p3 += 1) {
                  if (Fa(t3, c3[p3]))
                    return true;
                }
              for (var h3 = 0; h3 < t3.length - 1; h3++) {
                if (La(t3[h3], t3[h3 + 1], l3))
                  return true;
              }
              return false;
            }(t2.cameraQueryGeometry, e3 - l2, r3 - l2, n3 + l2, a3 + l2);
          }), y2 = 0, d2 = f2; y2 < d2.length; y2 += 1) {
            var m2 = d2[y2];
            c2.push(m2);
          }
          c2.sort(Ol);
          for (var v2, g2 = {}, x2 = function(i2) {
            var l3 = c2[i2];
            if (l3 !== v2) {
              v2 = l3;
              var p3 = n2.featureIndexArray.get(l3), h3 = null;
              n2.loadMatchingFeature(g2, p3.bucketIndex, p3.sourceLayerIndex, p3.featureIndex, s2, a2.layers, e2, function(e3, i3, a3) {
                h3 || (h3 = Aa(e3));
                var s3 = {};
                return void 0 !== a3 && (s3 = r2.getState(i3.sourceLayer || "_geojsonTileLayer", a3)), i3.queryIntersectsFeature(u2, e3, s3, h3, n2.z, t2.transform, o2, t2.pixelPosMatrix);
              });
            }
          }, b2 = 0; b2 < c2.length; b2++)
            x2(b2);
          return g2;
        }, Fl.prototype.loadMatchingFeature = function(t2, e2, r2, n2, i2, a2, o2, s2) {
          var u2 = this.bucketLayerIDs[e2];
          if (!a2 || function(t3, e3) {
            for (var r3 = 0; r3 < t3.length; r3++)
              if (e3.indexOf(t3[r3]) >= 0)
                return true;
            return false;
          }(a2, u2)) {
            var l2 = this.sourceLayerCoder.decode(r2), p2 = this.vtLayers[l2].feature(n2);
            if (i2(new Kn(this.tileID.overscaledZ), p2))
              for (var c2 = this.getId(p2, l2), h2 = 0; h2 < u2.length; h2++) {
                var f2 = u2[h2];
                if (!(a2 && a2.indexOf(f2) < 0)) {
                  var y2 = o2[f2];
                  if (y2) {
                    var d2 = !s2 || s2(p2, y2, c2);
                    if (d2) {
                      var m2 = new El(p2, this.z, this.x, this.y, c2);
                      m2.layer = y2.serialize();
                      var v2 = t2[f2];
                      void 0 === v2 && (v2 = t2[f2] = []), v2.push({ featureIndex: n2, feature: m2, intersectionZ: d2 });
                    }
                  }
                }
              }
          }
        }, Fl.prototype.lookupSymbolFeatures = function(t2, e2, r2, n2, i2, a2) {
          var o2 = {};
          this.loadVTLayers();
          for (var s2 = Dr(n2), u2 = 0, l2 = t2; u2 < l2.length; u2 += 1) {
            var p2 = l2[u2];
            this.loadMatchingFeature(o2, e2, r2, p2, s2, i2, a2);
          }
          return o2;
        }, Fl.prototype.hasLayer = function(t2) {
          for (var e2 = 0, r2 = this.bucketLayerIDs; e2 < r2.length; e2 += 1)
            for (var n2 = 0, i2 = r2[e2]; n2 < i2.length; n2 += 1) {
              if (t2 === i2[n2])
                return true;
            }
          return false;
        }, Fl.prototype.getId = function(t2, e2) {
          var r2 = t2.id;
          if (this.promoteId) {
            var n2 = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2];
            "boolean" == typeof (r2 = t2.properties[n2]) && (r2 = Number(r2));
          }
          return r2;
        }, vn("FeatureIndex", Fl, { omit: ["rawTileData", "sourceLayerCoder"] });
        var Dl = function(t2, e2) {
          this.tileID = t2, this.uid = h(), this.uses = 0, this.tileSize = e2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";
        };
        Dl.prototype.registerFadeDuration = function(t2) {
          var e2 = t2 + this.timeAdded;
          e2 < L.now() || this.fadeEndTime && e2 < this.fadeEndTime || (this.fadeEndTime = e2);
        }, Dl.prototype.wasRequested = function() {
          return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
        }, Dl.prototype.loadVectorData = function(t2, e2, r2) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t2) {
            for (var n2 in t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(t3, e3) {
              var r3 = {};
              if (!e3)
                return r3;
              for (var n3 = function() {
                var t4 = a3[i3], n4 = t4.layerIds.map(function(t5) {
                  return e3.getLayer(t5);
                }).filter(Boolean);
                if (0 !== n4.length) {
                  t4.layers = n4, t4.stateDependentLayerIds && (t4.stateDependentLayers = t4.stateDependentLayerIds.map(function(t5) {
                    return n4.filter(function(e4) {
                      return e4.id === t5;
                    })[0];
                  }));
                  for (var o3 = 0, s3 = n4; o3 < s3.length; o3 += 1) {
                    var u3 = s3[o3];
                    r3[u3.id] = t4;
                  }
                }
              }, i3 = 0, a3 = t3; i3 < a3.length; i3 += 1)
                n3();
              return r3;
            }(t2.buckets, e2.style), this.hasSymbolBuckets = false, this.buckets) {
              var i2 = this.buckets[n2];
              if (i2 instanceof $u) {
                if (this.hasSymbolBuckets = true, !r2)
                  break;
                i2.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets)
              for (var a2 in this.buckets) {
                var o2 = this.buckets[a2];
                if (o2 instanceof $u && o2.hasRTLText) {
                  this.hasRTLText = true, Nn.isLoading() || Nn.isLoaded() || "deferred" !== jn() || qn();
                  break;
                }
              }
            for (var s2 in this.queryPadding = 0, this.buckets) {
              var u2 = this.buckets[s2];
              this.queryPadding = Math.max(this.queryPadding, e2.style.getLayer(s2).queryRadius(u2));
            }
            t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage);
          } else
            this.collisionBoxArray = new Mi();
        }, Dl.prototype.unloadVectorData = function() {
          for (var t2 in this.buckets)
            this.buckets[t2].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }, Dl.prototype.getBucket = function(t2) {
          return this.buckets[t2.id];
        }, Dl.prototype.upload = function(t2) {
          for (var e2 in this.buckets) {
            var r2 = this.buckets[e2];
            r2.uploadPending() && r2.upload(t2);
          }
          var n2 = t2.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new fl(t2, this.imageAtlas.image, n2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new fl(t2, this.glyphAtlasImage, n2.ALPHA), this.glyphAtlasImage = null);
        }, Dl.prototype.prepare = function(t2) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
        }, Dl.prototype.queryRenderedFeatures = function(t2, e2, r2, n2, i2, a2, o2, s2, u2) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: r2, cameraQueryGeometry: n2, scale: i2, tileSize: this.tileSize, pixelPosMatrix: u2, transform: o2, params: a2, queryPadding: this.queryPadding * s2 }, t2, e2) : {};
        }, Dl.prototype.querySourceFeatures = function(t2, e2) {
          var r2 = this.latestFeatureIndex;
          if (r2 && r2.rawTileData) {
            var n2 = r2.loadVTLayers(), i2 = e2 ? e2.sourceLayer : "", a2 = n2._geojsonTileLayer || n2[i2];
            if (a2)
              for (var o2 = Dr(e2 && e2.filter), s2 = this.tileID.canonical, u2 = s2.z, l2 = s2.x, p2 = s2.y, c2 = { z: u2, x: l2, y: p2 }, h2 = 0; h2 < a2.length; h2++) {
                var f2 = a2.feature(h2);
                if (o2(new Kn(this.tileID.overscaledZ), f2)) {
                  var y2 = r2.getId(f2, i2), d2 = new El(f2, u2, l2, p2, y2);
                  d2.tile = c2, t2.push(d2);
                }
              }
          }
        }, Dl.prototype.hasData = function() {
          return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
        }, Dl.prototype.patternsLoaded = function() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }, Dl.prototype.setExpiryData = function(t2) {
          var e2 = this.expirationTime;
          if (t2.cacheControl) {
            var r2 = k(t2.cacheControl);
            r2["max-age"] && (this.expirationTime = Date.now() + 1e3 * r2["max-age"]);
          } else
            t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
          if (this.expirationTime) {
            var n2 = Date.now(), i2 = false;
            if (this.expirationTime > n2)
              i2 = false;
            else if (e2)
              if (this.expirationTime < e2)
                i2 = true;
              else {
                var a2 = this.expirationTime - e2;
                a2 ? this.expirationTime = n2 + Math.max(a2, 3e4) : i2 = true;
              }
            else
              i2 = true;
            i2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }, Dl.prototype.getExpiryTimeout = function() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }, Dl.prototype.setFeatureState = function(t2, e2) {
          if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(t2).length) {
            var r2 = this.latestFeatureIndex.loadVTLayers();
            for (var n2 in this.buckets) {
              var i2 = this.buckets[n2], a2 = i2.layers[0].sourceLayer || "_geojsonTileLayer", o2 = r2[a2], s2 = t2[a2];
              o2 && s2 && 0 !== Object.keys(s2).length && (i2.update(s2, o2, this.imageAtlas && this.imageAtlas.patternPositions || {}), e2 && e2.style && (this.queryPadding = Math.max(this.queryPadding, e2.style.getLayer(n2).queryRadius(i2))));
            }
          }
        }, Dl.prototype.holdingForFade = function() {
          return void 0 !== this.symbolFadeHoldUntil;
        }, Dl.prototype.symbolFadeFinished = function() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < L.now();
        }, Dl.prototype.clearFadeHold = function() {
          this.symbolFadeHoldUntil = void 0;
        }, Dl.prototype.setHoldDuration = function(t2) {
          this.symbolFadeHoldUntil = L.now() + t2;
        }, Dl.prototype.setDependencies = function(t2, e2) {
          for (var r2 = {}, n2 = 0, i2 = e2; n2 < i2.length; n2 += 1) {
            r2[i2[n2]] = true;
          }
          this.dependencies[t2] = r2;
        }, Dl.prototype.hasDependency = function(t2, e2) {
          for (var r2 = 0, n2 = t2; r2 < n2.length; r2 += 1) {
            var i2 = n2[r2], a2 = this.dependencies[i2];
            if (a2)
              for (var o2 = 0, s2 = e2; o2 < s2.length; o2 += 1) {
                if (a2[s2[o2]])
                  return true;
              }
          }
          return false;
        };
        var Rl = self.performance, Ul = function(t2) {
          this._marks = { start: [t2.url, "start"].join("#"), end: [t2.url, "end"].join("#"), measure: t2.url.toString() }, Rl.mark(this._marks.start);
        };
        Ul.prototype.finish = function() {
          Rl.mark(this._marks.end);
          var t2 = Rl.getEntriesByName(this._marks.measure);
          return 0 === t2.length && (Rl.measure(this._marks.measure, this._marks.start, this._marks.end), t2 = Rl.getEntriesByName(this._marks.measure), Rl.clearMarks(this._marks.start), Rl.clearMarks(this._marks.end), Rl.clearMeasures(this._marks.measure)), t2;
        }, t.Actor = dl, t.AlphaImage = Wa, t.CanonicalTileID = Il, t.CollisionBoxArray = Mi, t.Color = $t, t.DEMData = Pl, t.DataConstantProperty = Qn, t.DictionaryCoder = Tl, t.EXTENT = 8192, t.ErrorEvent = It, t.EvaluationParameters = Kn, t.Event = kt, t.Evented = zt, t.FeatureIndex = Fl, t.FillBucket = qo, t.FillExtrusionBucket = as, t.ImageAtlas = eu, t.ImagePosition = Qs, t.LineBucket = ms, t.LngLat = gl, t.LngLatBounds = vl, t.MercatorCoordinate = kl, t.ONE_EM = 24, t.OverscaledTileID = Cl, t.Point = i, t.Point$1 = i, t.ProgramConfiguration = va, t.Properties = ii, t.Protobuf = Ts, t.RGBAImage = Qa, t.RequestManager = N, t.RequestPerformance = Ul, t.ResourceType = yt, t.SegmentVector = Xi, t.SourceFeatureState = Vl, t.StructArrayLayout1ui2 = Bi, t.StructArrayLayout2i4 = ci, t.StructArrayLayout2ui4 = Ci, t.StructArrayLayout3ui6 = zi, t.StructArrayLayout4i8 = hi, t.SymbolBucket = $u, t.Texture = fl, t.Tile = Dl, t.Transitionable = Gn, t.Uniform1f = ia, t.Uniform1i = na, t.Uniform2f = aa, t.Uniform3f = oa, t.Uniform4f = sa, t.UniformColor = ua, t.UniformMatrix4f = pa, t.UnwrappedTileID = zl, t.ValidationError = Bt, t.WritingMode = ru, t.ZoomHistory = An, t.addDynamicAttributes = Gu, t.asyncAll = function(t2, e2, r2) {
          if (!t2.length)
            return r2(null, []);
          var n2 = t2.length, i2 = new Array(t2.length), a2 = null;
          t2.forEach(function(t3, o2) {
            e2(t3, function(t4, e3) {
              t4 && (a2 = t4), i2[o2] = e3, 0 == --n2 && r2(a2, i2);
            });
          });
        }, t.bezier = o, t.bindAll = d, t.browser = L, t.cacheEntryPossiblyAdded = function(t2) {
          ++ht > ot && (t2.getActor().send("enforceCacheSizeLimit", at), ht = 0);
        }, t.clamp = u, t.clearTileCache = function(t2) {
          var e2 = self.caches.delete("mapbox-tiles");
          t2 && e2.catch(t2).then(function() {
            return t2();
          });
        }, t.clone = function(t2) {
          var e2 = new qa(16);
          return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
        }, t.clone$1 = x, t.config = O, t.create = function() {
          var t2 = new qa(16);
          return qa != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
        }, t.create$1 = function() {
          var t2 = new qa(9);
          return qa != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
        }, t.create$2 = function() {
          var t2 = new qa(4);
          return qa != Float32Array && (t2[1] = 0, t2[2] = 0), t2[0] = 1, t2[3] = 1, t2;
        }, t.createCommonjsModule = e, t.createExpression = kr, t.createLayout = li, t.createStyleLayer = function(t2) {
          return "custom" === t2.type ? new ol(t2) : new sl[t2.type](t2);
        }, t.deepEqual = function t2(e2, r2) {
          if (Array.isArray(e2)) {
            if (!Array.isArray(r2) || e2.length !== r2.length)
              return false;
            for (var n2 = 0; n2 < e2.length; n2++)
              if (!t2(e2[n2], r2[n2]))
                return false;
            return true;
          }
          if ("object" == typeof e2 && null !== e2 && null !== r2) {
            if ("object" != typeof r2)
              return false;
            if (Object.keys(e2).length !== Object.keys(r2).length)
              return false;
            for (var i2 in e2)
              if (!t2(e2[i2], r2[i2]))
                return false;
            return true;
          }
          return e2 === r2;
        }, t.ease = s, t.emitValidationErrors = cn, t.endsWith = m, t.enforceCacheSizeLimit = function(t2) {
          st(), W && W.then(function(e2) {
            e2.keys().then(function(r2) {
              for (var n2 = 0; n2 < r2.length - t2; n2++)
                e2.delete(r2[n2]);
            });
          });
        }, t.evaluateSizeForFeature = gu, t.evaluateSizeForZoom = xu, t.evaluateVariableOffset = Ru, t.evented = Un, t.extend = p, t.featureFilter = Dr, t.filterObject = g, t.fromRotation = function(t2, e2) {
          var r2 = Math.sin(e2), n2 = Math.cos(e2);
          return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
        }, t.getAnchorAlignment = fu, t.getAnchorJustification = Uu, t.getArrayBuffer = xt, t.getImage = wt, t.getJSON = function(t2, e2) {
          return gt(p(t2, { type: "json" }), e2);
        }, t.getRTLTextPluginStatus = jn, t.getReferrer = mt, t.getVideo = function(t2, e2) {
          var r2, n2, i2 = self.document.createElement("video");
          i2.muted = true, i2.onloadstart = function() {
            e2(null, i2);
          };
          for (var a2 = 0; a2 < t2.length; a2++) {
            var o2 = self.document.createElement("source");
            r2 = t2[a2], n2 = void 0, (n2 = self.document.createElement("a")).href = r2, (n2.protocol !== self.document.location.protocol || n2.host !== self.document.location.host) && (i2.crossOrigin = "Anonymous"), o2.src = t2[a2], i2.appendChild(o2);
          }
          return { cancel: function() {
          } };
        }, t.identity = function(t2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }, t.invert = function(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], a2 = e2[3], o2 = e2[4], s2 = e2[5], u2 = e2[6], l2 = e2[7], p2 = e2[8], c2 = e2[9], h2 = e2[10], f2 = e2[11], y2 = e2[12], d2 = e2[13], m2 = e2[14], v2 = e2[15], g2 = r2 * s2 - n2 * o2, x2 = r2 * u2 - i2 * o2, b2 = r2 * l2 - a2 * o2, _2 = n2 * u2 - i2 * s2, w2 = n2 * l2 - a2 * s2, A2 = i2 * l2 - a2 * u2, S2 = p2 * d2 - c2 * y2, k2 = p2 * m2 - h2 * y2, I2 = p2 * v2 - f2 * y2, z2 = c2 * m2 - h2 * d2, C2 = c2 * v2 - f2 * d2, B2 = h2 * v2 - f2 * m2, P2 = g2 * B2 - x2 * C2 + b2 * z2 + _2 * I2 - w2 * k2 + A2 * S2;
          return P2 ? (P2 = 1 / P2, t2[0] = (s2 * B2 - u2 * C2 + l2 * z2) * P2, t2[1] = (i2 * C2 - n2 * B2 - a2 * z2) * P2, t2[2] = (d2 * A2 - m2 * w2 + v2 * _2) * P2, t2[3] = (h2 * w2 - c2 * A2 - f2 * _2) * P2, t2[4] = (u2 * I2 - o2 * B2 - l2 * k2) * P2, t2[5] = (r2 * B2 - i2 * I2 + a2 * k2) * P2, t2[6] = (m2 * b2 - y2 * A2 - v2 * x2) * P2, t2[7] = (p2 * A2 - h2 * b2 + f2 * x2) * P2, t2[8] = (o2 * C2 - s2 * I2 + l2 * S2) * P2, t2[9] = (n2 * I2 - r2 * C2 - a2 * S2) * P2, t2[10] = (y2 * w2 - d2 * b2 + v2 * g2) * P2, t2[11] = (c2 * b2 - p2 * w2 - f2 * g2) * P2, t2[12] = (s2 * k2 - o2 * z2 - u2 * S2) * P2, t2[13] = (r2 * z2 - n2 * k2 + i2 * S2) * P2, t2[14] = (d2 * x2 - y2 * _2 - m2 * g2) * P2, t2[15] = (p2 * _2 - c2 * x2 + h2 * g2) * P2, t2) : null;
        }, t.isChar = Sn, t.isGoongURL = K, t.keysDifference = function(t2, e2) {
          var r2 = [];
          for (var n2 in t2)
            n2 in e2 || r2.push(n2);
          return r2;
        }, t.makeRequest = gt, t.mapObject = v, t.mercatorXfromLng = _l, t.mercatorYfromLat = wl, t.mercatorZfromAltitude = Al, t.multiply = function(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], a2 = e2[2], o2 = e2[3], s2 = e2[4], u2 = e2[5], l2 = e2[6], p2 = e2[7], c2 = e2[8], h2 = e2[9], f2 = e2[10], y2 = e2[11], d2 = e2[12], m2 = e2[13], v2 = e2[14], g2 = e2[15], x2 = r2[0], b2 = r2[1], _2 = r2[2], w2 = r2[3];
          return t2[0] = x2 * n2 + b2 * s2 + _2 * c2 + w2 * d2, t2[1] = x2 * i2 + b2 * u2 + _2 * h2 + w2 * m2, t2[2] = x2 * a2 + b2 * l2 + _2 * f2 + w2 * v2, t2[3] = x2 * o2 + b2 * p2 + _2 * y2 + w2 * g2, x2 = r2[4], b2 = r2[5], _2 = r2[6], w2 = r2[7], t2[4] = x2 * n2 + b2 * s2 + _2 * c2 + w2 * d2, t2[5] = x2 * i2 + b2 * u2 + _2 * h2 + w2 * m2, t2[6] = x2 * a2 + b2 * l2 + _2 * f2 + w2 * v2, t2[7] = x2 * o2 + b2 * p2 + _2 * y2 + w2 * g2, x2 = r2[8], b2 = r2[9], _2 = r2[10], w2 = r2[11], t2[8] = x2 * n2 + b2 * s2 + _2 * c2 + w2 * d2, t2[9] = x2 * i2 + b2 * u2 + _2 * h2 + w2 * m2, t2[10] = x2 * a2 + b2 * l2 + _2 * f2 + w2 * v2, t2[11] = x2 * o2 + b2 * p2 + _2 * y2 + w2 * g2, x2 = r2[12], b2 = r2[13], _2 = r2[14], w2 = r2[15], t2[12] = x2 * n2 + b2 * s2 + _2 * c2 + w2 * d2, t2[13] = x2 * i2 + b2 * u2 + _2 * h2 + w2 * m2, t2[14] = x2 * a2 + b2 * l2 + _2 * f2 + w2 * v2, t2[15] = x2 * o2 + b2 * p2 + _2 * y2 + w2 * g2, t2;
        }, t.mvt = es, t.number = Se, t.offscreenCanvasSupported = ft, t.ortho = function(t2, e2, r2, n2, i2, a2, o2) {
          var s2 = 1 / (e2 - r2), u2 = 1 / (n2 - i2), l2 = 1 / (a2 - o2);
          return t2[0] = -2 * s2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * u2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * l2, t2[11] = 0, t2[12] = (e2 + r2) * s2, t2[13] = (i2 + n2) * u2, t2[14] = (o2 + a2) * l2, t2[15] = 1, t2;
        }, t.parseGlyphPBF = function(t2) {
          return new Ts(t2).readFields(Hs, []);
        }, t.pbf = Ts, t.performSymbolLayout = function(t2, e2, r2, n2, a2, o2) {
          t2.createArrays();
          var s2 = 512 * t2.overscaling;
          t2.tilePixelRatio = 8192 / s2, t2.compareText = {}, t2.iconsNeedLinear = false;
          var u2 = t2.layers[0].layout, l2 = t2.layers[0]._unevaluatedLayout._values, p2 = {};
          if ("composite" === t2.textSizeData.kind) {
            var c2 = t2.textSizeData, h2 = c2.minZoom, f2 = c2.maxZoom;
            p2.compositeTextSizes = [l2["text-size"].possiblyEvaluate(new Kn(h2)), l2["text-size"].possiblyEvaluate(new Kn(f2))];
          }
          if ("composite" === t2.iconSizeData.kind) {
            var y2 = t2.iconSizeData, d2 = y2.minZoom, m2 = y2.maxZoom;
            p2.compositeIconSizes = [l2["icon-size"].possiblyEvaluate(new Kn(d2)), l2["icon-size"].possiblyEvaluate(new Kn(m2))];
          }
          p2.layoutTextSize = l2["text-size"].possiblyEvaluate(new Kn(t2.zoom + 1)), p2.layoutIconSize = l2["icon-size"].possiblyEvaluate(new Kn(t2.zoom + 1)), p2.textMaxSize = l2["text-size"].possiblyEvaluate(new Kn(18));
          for (var v2 = 24 * u2.get("text-line-height"), g2 = "map" === u2.get("text-rotation-alignment") && "point" !== u2.get("symbol-placement"), x2 = u2.get("text-keep-upright"), b2 = u2.get("text-size"), w2 = function() {
            var o3 = S2[A2], s3 = u2.get("text-font").evaluate(o3, {}).join(","), l3 = b2.evaluate(o3, {}), c3 = p2.layoutTextSize.evaluate(o3, {}), h3 = p2.layoutIconSize.evaluate(o3, {}), f3 = { horizontal: {}, vertical: void 0 }, y3 = o3.text, d3 = [0, 0];
            if (y3) {
              var m3 = y3.toString(), w3 = 24 * u2.get("text-letter-spacing").evaluate(o3, {}), k2 = function(t3) {
                for (var e3 = 0, r3 = t3; e3 < r3.length; e3 += 1) {
                  if (!In(r3[e3].charCodeAt(0)))
                    return false;
                }
                return true;
              }(m3) ? w3 : 0, I2 = u2.get("text-anchor").evaluate(o3, {}), z2 = u2.get("text-variable-anchor");
              if (!z2) {
                var C2 = u2.get("text-radial-offset").evaluate(o3, {});
                d3 = C2 ? Ru(I2, [24 * C2, Du]) : u2.get("text-offset").evaluate(o3, {}).map(function(t3) {
                  return 24 * t3;
                });
              }
              var B2 = g2 ? "center" : u2.get("text-justify").evaluate(o3, {}), P2 = u2.get("symbol-placement"), T2 = "point" === P2 ? 24 * u2.get("text-max-width").evaluate(o3, {}) : 0, E2 = function() {
                t2.allowVerticalPlacement && kn(m3) && (f3.vertical = au(y3, e2, r2, a2, s3, T2, v2, I2, "left", k2, d3, ru.vertical, true, P2, c3, l3));
              };
              if (!g2 && z2) {
                for (var M2 = "auto" === B2 ? z2.map(function(t3) {
                  return Uu(t3);
                }) : [B2], V2 = false, F2 = 0; F2 < M2.length; F2++) {
                  var L2 = M2[F2];
                  if (!f3.horizontal[L2])
                    if (V2)
                      f3.horizontal[L2] = f3.horizontal[0];
                    else {
                      var O2 = au(y3, e2, r2, a2, s3, T2, v2, "center", L2, k2, d3, ru.horizontal, false, P2, c3, l3);
                      O2 && (f3.horizontal[L2] = O2, V2 = 1 === O2.positionedLines.length);
                    }
                }
                E2();
              } else {
                "auto" === B2 && (B2 = Uu(I2));
                var D2 = au(y3, e2, r2, a2, s3, T2, v2, I2, B2, k2, d3, ru.horizontal, false, P2, c3, l3);
                D2 && (f3.horizontal[B2] = D2), E2(), kn(m3) && g2 && x2 && (f3.vertical = au(y3, e2, r2, a2, s3, T2, v2, I2, B2, k2, d3, ru.vertical, false, P2, c3, l3));
              }
            }
            var R2 = void 0, U2 = false;
            if (o3.icon && o3.icon.name) {
              var j2 = n2[o3.icon.name];
              j2 && (R2 = function(t3, e3, r3) {
                var n3 = fu(r3), i2 = n3.horizontalAlign, a3 = n3.verticalAlign, o4 = e3[0], s4 = e3[1], u3 = o4 - t3.displaySize[0] * i2, l4 = u3 + t3.displaySize[0], p3 = s4 - t3.displaySize[1] * a3;
                return { image: t3, top: p3, bottom: p3 + t3.displaySize[1], left: u3, right: l4 };
              }(a2[o3.icon.name], u2.get("icon-offset").evaluate(o3, {}), u2.get("icon-anchor").evaluate(o3, {})), U2 = j2.sdf, void 0 === t2.sdfIcons ? t2.sdfIcons = j2.sdf : t2.sdfIcons !== j2.sdf && _("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (j2.pixelRatio !== t2.pixelRatio || 0 !== u2.get("icon-rotate").constantOr(1)) && (t2.iconsNeedLinear = true));
            }
            var q2 = qu(f3.horizontal) || f3.vertical;
            t2.iconsInText = !!q2 && q2.iconsInText, (q2 || R2) && function(t3, e3, r3, n3, a3, o4, s4, u3, l4, p3) {
              var c4 = o4.textMaxSize.evaluate(e3, {});
              void 0 === c4 && (c4 = s4);
              var h4, f4 = t3.layers[0].layout, y4 = f4.get("icon-offset").evaluate(e3, {}), d4 = qu(r3.horizontal), m4 = s4 / 24, v3 = t3.tilePixelRatio * m4, g3 = t3.tilePixelRatio * c4 / 24, x3 = t3.tilePixelRatio * u3, b3 = t3.tilePixelRatio * f4.get("symbol-spacing"), w4 = f4.get("text-padding") * t3.tilePixelRatio, A3 = f4.get("icon-padding") * t3.tilePixelRatio, S3 = f4.get("text-max-angle") / 180 * Math.PI, k3 = "map" === f4.get("text-rotation-alignment") && "point" !== f4.get("symbol-placement"), I3 = "map" === f4.get("icon-rotation-alignment") && "point" !== f4.get("symbol-placement"), z3 = f4.get("symbol-placement"), C3 = b3 / 2, B3 = f4.get("icon-text-fit");
              n3 && "none" !== B3 && (t3.allowVerticalPlacement && r3.vertical && (h4 = du(n3, r3.vertical, B3, f4.get("icon-text-fit-padding"), y4, m4)), d4 && (n3 = du(n3, d4, B3, f4.get("icon-text-fit-padding"), y4, m4)));
              var P3 = function(i2, s5) {
                s5.x < 0 || s5.x >= 8192 || s5.y < 0 || s5.y >= 8192 || function(t4, e4, r4, n4, i3, a4, o5, s6, u4, l5, p4, c5, h5, f5, y5, d5, m5, v4, g4, x4, b4, w5, A4) {
                  var S4, k4, I4, z4, C4, B4 = t4.addToLineVertexArray(e4, r4), P4 = 0, T4 = 0, E4 = 0, M4 = 0, V4 = -1, F4 = -1, L4 = {}, O4 = Hi(""), D4 = 0, R4 = 0;
                  void 0 === s6._unevaluatedLayout.getValue("text-radial-offset") ? (S4 = s6.layout.get("text-offset").evaluate(b4, {}).map(function(t5) {
                    return 24 * t5;
                  }), D4 = S4[0], R4 = S4[1]) : (D4 = 24 * s6.layout.get("text-radial-offset").evaluate(b4, {}), R4 = Du);
                  if (t4.allowVerticalPlacement && n4.vertical) {
                    var U4 = s6.layout.get("text-rotate").evaluate(b4, {}) + 90, j4 = n4.vertical;
                    z4 = new Eu(u4, r4, e4, l5, p4, c5, j4, h5, f5, y5, t4.overscaling, U4), o5 && (C4 = new Eu(u4, r4, e4, l5, p4, c5, o5, m5, v4, y5, t4.overscaling, U4));
                  }
                  if (i3) {
                    var q4 = s6.layout.get("icon-rotate").evaluate(b4, {}), N3 = "none" !== s6.layout.get("icon-text-fit"), K3 = zu(i3, q4, A4, N3), X3 = o5 ? zu(o5, q4, A4, N3) : void 0;
                    I4 = new Eu(u4, r4, e4, l5, p4, c5, i3, m5, v4, false, t4.overscaling, q4), P4 = 4 * K3.length;
                    var Z3 = t4.iconSizeData, G3 = null;
                    "source" === Z3.kind ? (G3 = [128 * s6.layout.get("icon-size").evaluate(b4, {})])[0] > 32640 && _(t4.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".') : "composite" === Z3.kind && ((G3 = [128 * w5.compositeIconSizes[0].evaluate(b4, {}), 128 * w5.compositeIconSizes[1].evaluate(b4, {})])[0] > 32640 || G3[1] > 32640) && _(t4.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".'), t4.addSymbols(t4.icon, K3, G3, x4, g4, b4, false, e4, B4.lineStartIndex, B4.lineLength, -1), V4 = t4.icon.placedSymbolArray.length - 1, X3 && (T4 = 4 * X3.length, t4.addSymbols(t4.icon, X3, G3, x4, g4, b4, ru.vertical, e4, B4.lineStartIndex, B4.lineLength, -1), F4 = t4.icon.placedSymbolArray.length - 1);
                  }
                  for (var J3 in n4.horizontal) {
                    var H3 = n4.horizontal[J3];
                    if (!k4) {
                      O4 = Hi(H3.text);
                      var Y3 = s6.layout.get("text-rotate").evaluate(b4, {});
                      k4 = new Eu(u4, r4, e4, l5, p4, c5, H3, h5, f5, y5, t4.overscaling, Y3);
                    }
                    var $3 = 1 === H3.positionedLines.length;
                    if (E4 += ju(t4, e4, H3, a4, s6, y5, b4, d5, B4, n4.vertical ? ru.horizontal : ru.horizontalOnly, $3 ? Object.keys(n4.horizontal) : [J3], L4, V4, w5), $3)
                      break;
                  }
                  n4.vertical && (M4 += ju(t4, e4, n4.vertical, a4, s6, y5, b4, d5, B4, ru.vertical, ["vertical"], L4, F4, w5));
                  var W3 = k4 ? k4.boxStartIndex : t4.collisionBoxArray.length, Q3 = k4 ? k4.boxEndIndex : t4.collisionBoxArray.length, tt3 = z4 ? z4.boxStartIndex : t4.collisionBoxArray.length, et3 = z4 ? z4.boxEndIndex : t4.collisionBoxArray.length, rt2 = I4 ? I4.boxStartIndex : t4.collisionBoxArray.length, nt2 = I4 ? I4.boxEndIndex : t4.collisionBoxArray.length, it2 = C4 ? C4.boxStartIndex : t4.collisionBoxArray.length, at2 = C4 ? C4.boxEndIndex : t4.collisionBoxArray.length;
                  t4.glyphOffsetArray.length >= $u.MAX_GLYPHS && _("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907");
                  t4.symbolInstances.emplaceBack(e4.x, e4.y, L4.right >= 0 ? L4.right : -1, L4.center >= 0 ? L4.center : -1, L4.left >= 0 ? L4.left : -1, L4.vertical || -1, V4, F4, O4, W3, Q3, tt3, et3, rt2, nt2, it2, at2, l5, E4, M4, P4, T4, 0, h5, D4, R4);
                }(t3, s5, i2, r3, n3, a3, h4, t3.layers[0], t3.collisionBoxArray, e3.index, e3.sourceLayerIndex, t3.index, v3, w4, k3, l4, x3, A3, I3, y4, e3, o4, p3);
              };
              if ("line" === z3)
                for (var T3 = 0, E3 = function(t4, e4, r4, n4, a4) {
                  for (var o5 = [], s5 = 0; s5 < t4.length; s5++)
                    for (var u4 = t4[s5], l5 = void 0, p4 = 0; p4 < u4.length - 1; p4++) {
                      var c5 = u4[p4], h5 = u4[p4 + 1];
                      c5.x < e4 && h5.x < e4 || (c5.x < e4 ? c5 = new i(e4, c5.y + (h5.y - c5.y) * ((e4 - c5.x) / (h5.x - c5.x)))._round() : h5.x < e4 && (h5 = new i(e4, c5.y + (h5.y - c5.y) * ((e4 - c5.x) / (h5.x - c5.x)))._round()), c5.y < r4 && h5.y < r4 || (c5.y < r4 ? c5 = new i(c5.x + (h5.x - c5.x) * ((r4 - c5.y) / (h5.y - c5.y)), r4)._round() : h5.y < r4 && (h5 = new i(c5.x + (h5.x - c5.x) * ((r4 - c5.y) / (h5.y - c5.y)), r4)._round()), c5.x >= n4 && h5.x >= n4 || (c5.x >= n4 ? c5 = new i(n4, c5.y + (h5.y - c5.y) * ((n4 - c5.x) / (h5.x - c5.x)))._round() : h5.x >= n4 && (h5 = new i(n4, c5.y + (h5.y - c5.y) * ((n4 - c5.x) / (h5.x - c5.x)))._round()), c5.y >= a4 && h5.y >= a4 || (c5.y >= a4 ? c5 = new i(c5.x + (h5.x - c5.x) * ((a4 - c5.y) / (h5.y - c5.y)), a4)._round() : h5.y >= a4 && (h5 = new i(c5.x + (h5.x - c5.x) * ((a4 - c5.y) / (h5.y - c5.y)), a4)._round()), l5 && c5.equals(l5[l5.length - 1]) || (l5 = [c5], o5.push(l5)), l5.push(h5)))));
                    }
                  return o5;
                }(e3.geometry, 0, 0, 8192, 8192); T3 < E3.length; T3 += 1)
                  for (var M3 = E3[T3], V3 = Iu(M3, b3, S3, r3.vertical || d4, n3, 24, g3, t3.overscaling, 8192), F3 = 0, L3 = V3; F3 < L3.length; F3 += 1) {
                    var O3 = L3[F3], D3 = d4;
                    D3 && Nu(t3, D3.text, C3, O3) || P3(M3, O3);
                  }
              else if ("line-center" === z3)
                for (var R3 = 0, U3 = e3.geometry; R3 < U3.length; R3 += 1) {
                  var j3 = U3[R3];
                  if (j3.length > 1) {
                    var q3 = ku(j3, S3, r3.vertical || d4, n3, 24, g3);
                    q3 && P3(j3, q3);
                  }
                }
              else if ("Polygon" === e3.type)
                for (var N2 = 0, K2 = Do(e3.geometry, 0); N2 < K2.length; N2 += 1) {
                  var X2 = K2[N2], Z2 = Fu(X2, 16);
                  P3(X2[0], new mu(Z2.x, Z2.y, 0));
                }
              else if ("LineString" === e3.type)
                for (var G2 = 0, J2 = e3.geometry; G2 < J2.length; G2 += 1) {
                  var H2 = J2[G2];
                  P3(H2, new mu(H2[0].x, H2[0].y, 0));
                }
              else if ("Point" === e3.type)
                for (var Y2 = 0, $2 = e3.geometry; Y2 < $2.length; Y2 += 1)
                  for (var W2 = $2[Y2], Q2 = 0, tt2 = W2; Q2 < tt2.length; Q2 += 1) {
                    var et2 = tt2[Q2];
                    P3([et2], new mu(et2.x, et2.y, 0));
                  }
            }(t2, o3, f3, R2, n2, p2, c3, h3, d3, U2);
          }, A2 = 0, S2 = t2.features; A2 < S2.length; A2 += 1)
            w2();
          o2 && t2.generateCollisionDebugBuffers();
        }, t.perspective = function(t2, e2, r2, n2, i2) {
          var a2, o2 = 1 / Math.tan(e2 / 2);
          return t2[0] = o2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = o2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (a2 = 1 / (n2 - i2), t2[10] = (i2 + n2) * a2, t2[14] = 2 * i2 * n2 * a2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
        }, t.pick = function(t2, e2) {
          for (var r2 = {}, n2 = 0; n2 < e2.length; n2++) {
            var i2 = e2[n2];
            i2 in t2 && (r2[i2] = t2[i2]);
          }
          return r2;
        }, t.plugin = Nn, t.polygonIntersectsPolygon = Ia, t.postMapLoadEvent = it, t.postTurnstileEvent = rt, t.potpack = Ws, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.register = vn, t.registerForPluginStateChange = function(t2) {
          return t2({ pluginStatus: Ln, pluginURL: On }), Un.on("pluginStateChange", t2), t2;
        }, t.rotate = function(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], a2 = e2[2], o2 = e2[3], s2 = Math.sin(r2), u2 = Math.cos(r2);
          return t2[0] = n2 * u2 + a2 * s2, t2[1] = i2 * u2 + o2 * s2, t2[2] = n2 * -s2 + a2 * u2, t2[3] = i2 * -s2 + o2 * u2, t2;
        }, t.rotateX = function(t2, e2, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), a2 = e2[4], o2 = e2[5], s2 = e2[6], u2 = e2[7], l2 = e2[8], p2 = e2[9], c2 = e2[10], h2 = e2[11];
          return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = a2 * i2 + l2 * n2, t2[5] = o2 * i2 + p2 * n2, t2[6] = s2 * i2 + c2 * n2, t2[7] = u2 * i2 + h2 * n2, t2[8] = l2 * i2 - a2 * n2, t2[9] = p2 * i2 - o2 * n2, t2[10] = c2 * i2 - s2 * n2, t2[11] = h2 * i2 - u2 * n2, t2;
        }, t.rotateZ = function(t2, e2, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), a2 = e2[0], o2 = e2[1], s2 = e2[2], u2 = e2[3], l2 = e2[4], p2 = e2[5], c2 = e2[6], h2 = e2[7];
          return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = a2 * i2 + l2 * n2, t2[1] = o2 * i2 + p2 * n2, t2[2] = s2 * i2 + c2 * n2, t2[3] = u2 * i2 + h2 * n2, t2[4] = l2 * i2 - a2 * n2, t2[5] = p2 * i2 - o2 * n2, t2[6] = c2 * i2 - s2 * n2, t2[7] = h2 * i2 - u2 * n2, t2;
        }, t.scale = function(t2, e2, r2) {
          var n2 = r2[0], i2 = r2[1], a2 = r2[2];
          return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * a2, t2[9] = e2[9] * a2, t2[10] = e2[10] * a2, t2[11] = e2[11] * a2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
        }, t.setCacheLimits = function(t2, e2) {
          at = t2, ot = e2;
        }, t.setRTLTextPlugin = function(t2, e2, r2) {
          if (void 0 === r2 && (r2 = false), Ln === En || Ln === Mn || Ln === Vn)
            throw new Error("setRTLTextPlugin cannot be called multiple times.");
          On = L.resolveURL(t2), Ln = En, Fn = e2, Rn(), r2 || qn();
        }, t.sphericalToCartesian = function(t2) {
          var e2 = t2[0], r2 = t2[1], n2 = t2[2];
          return r2 += 90, r2 *= Math.PI / 180, n2 *= Math.PI / 180, { x: e2 * Math.cos(r2) * Math.sin(n2), y: e2 * Math.sin(r2) * Math.sin(n2), z: e2 * Math.cos(n2) };
        }, t.styleSpec = Ct, t.symbolSize = bu, t.transformMat3 = function(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], a2 = e2[2];
          return t2[0] = n2 * r2[0] + i2 * r2[3] + a2 * r2[6], t2[1] = n2 * r2[1] + i2 * r2[4] + a2 * r2[7], t2[2] = n2 * r2[2] + i2 * r2[5] + a2 * r2[8], t2;
        }, t.transformMat4 = Xa, t.translate = function(t2, e2, r2) {
          var n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2 = r2[0], m2 = r2[1], v2 = r2[2];
          return e2 === t2 ? (t2[12] = e2[0] * d2 + e2[4] * m2 + e2[8] * v2 + e2[12], t2[13] = e2[1] * d2 + e2[5] * m2 + e2[9] * v2 + e2[13], t2[14] = e2[2] * d2 + e2[6] * m2 + e2[10] * v2 + e2[14], t2[15] = e2[3] * d2 + e2[7] * m2 + e2[11] * v2 + e2[15]) : (n2 = e2[0], i2 = e2[1], a2 = e2[2], o2 = e2[3], s2 = e2[4], u2 = e2[5], l2 = e2[6], p2 = e2[7], c2 = e2[8], h2 = e2[9], f2 = e2[10], y2 = e2[11], t2[0] = n2, t2[1] = i2, t2[2] = a2, t2[3] = o2, t2[4] = s2, t2[5] = u2, t2[6] = l2, t2[7] = p2, t2[8] = c2, t2[9] = h2, t2[10] = f2, t2[11] = y2, t2[12] = n2 * d2 + s2 * m2 + c2 * v2 + e2[12], t2[13] = i2 * d2 + u2 * m2 + h2 * v2 + e2[13], t2[14] = a2 * d2 + l2 * m2 + f2 * v2 + e2[14], t2[15] = o2 * d2 + p2 * m2 + y2 * v2 + e2[15]), t2;
        }, t.triggerPluginCompletionEvent = Dn, t.uniqueId = h, t.validateCustomStyleLayer = function(t2) {
          var e2 = [], r2 = t2.id;
          return void 0 === r2 && e2.push({ message: "layers." + r2 + ': missing required property "id"' }), void 0 === t2.render && e2.push({ message: "layers." + r2 + ': missing required method "render"' }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e2.push({ message: "layers." + r2 + ': property "renderingMode" must be either "2d" or "3d"' }), e2;
        }, t.validateLight = un, t.validateStyle = sn, t.values = function(t2) {
          var e2 = [];
          for (var r2 in t2)
            e2.push(t2[r2]);
          return e2;
        }, t.vectorTile = es, t.version = "1.0.9", t.warnOnce = _, t.webpSupported = D, t.window = self, t.wrap = l;
      });
      define2(["./shared"], function(e) {
        "use strict";
        function t(e2) {
          var r2 = typeof e2;
          if ("number" === r2 || "boolean" === r2 || "string" === r2 || null == e2)
            return JSON.stringify(e2);
          if (Array.isArray(e2)) {
            for (var i2 = "[", o2 = 0, n2 = e2; o2 < n2.length; o2 += 1) {
              i2 += t(n2[o2]) + ",";
            }
            return i2 + "]";
          }
          for (var a2 = Object.keys(e2).sort(), s2 = "{", l2 = 0; l2 < a2.length; l2++)
            s2 += JSON.stringify(a2[l2]) + ":" + t(e2[a2[l2]]) + ",";
          return s2 + "}";
        }
        function r(r2) {
          for (var i2 = "", o2 = 0, n2 = e.refProperties; o2 < n2.length; o2 += 1) {
            i2 += "/" + t(r2[n2[o2]]);
          }
          return i2;
        }
        var i = function(e2) {
          this.keyCache = {}, e2 && this.replace(e2);
        };
        i.prototype.replace = function(e2) {
          this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
        }, i.prototype.update = function(t2, i2) {
          for (var o2 = this, n2 = 0, a2 = t2; n2 < a2.length; n2 += 1) {
            var s2 = a2[n2];
            this._layerConfigs[s2.id] = s2;
            var l2 = this._layers[s2.id] = e.createStyleLayer(s2);
            l2._featureFilter = e.featureFilter(l2.filter), this.keyCache[s2.id] && delete this.keyCache[s2.id];
          }
          for (var u2 = 0, h2 = i2; u2 < h2.length; u2 += 1) {
            var c2 = h2[u2];
            delete this.keyCache[c2], delete this._layerConfigs[c2], delete this._layers[c2];
          }
          this.familiesBySource = {};
          for (var p2 = 0, f2 = function(e2, t3) {
            for (var i3 = {}, o3 = 0; o3 < e2.length; o3++) {
              var n3 = t3 && t3[e2[o3].id] || r(e2[o3]);
              t3 && (t3[e2[o3].id] = n3);
              var a3 = i3[n3];
              a3 || (a3 = i3[n3] = []), a3.push(e2[o3]);
            }
            var s3 = [];
            for (var l3 in i3)
              s3.push(i3[l3]);
            return s3;
          }(e.values(this._layerConfigs), this.keyCache); p2 < f2.length; p2 += 1) {
            var d2 = f2[p2].map(function(e2) {
              return o2._layers[e2.id];
            }), g2 = d2[0];
            if ("none" !== g2.visibility) {
              var m2 = g2.source || "", v2 = this.familiesBySource[m2];
              v2 || (v2 = this.familiesBySource[m2] = {});
              var y2 = g2.sourceLayer || "_geojsonTileLayer", x2 = v2[y2];
              x2 || (x2 = v2[y2] = []), x2.push(d2);
            }
          }
        };
        var o = function(t2) {
          var r2 = {}, i2 = [];
          for (var o2 in t2) {
            var n2 = t2[o2], a2 = r2[o2] = {};
            for (var s2 in n2) {
              var l2 = n2[+s2];
              if (l2 && 0 !== l2.bitmap.width && 0 !== l2.bitmap.height) {
                var u2 = { x: 0, y: 0, w: l2.bitmap.width + 2, h: l2.bitmap.height + 2 };
                i2.push(u2), a2[s2] = { rect: u2, metrics: l2.metrics };
              }
            }
          }
          var h2 = e.potpack(i2), c2 = h2.w, p2 = h2.h, f2 = new e.AlphaImage({ width: c2 || 1, height: p2 || 1 });
          for (var d2 in t2) {
            var g2 = t2[d2];
            for (var m2 in g2) {
              var v2 = g2[+m2];
              if (v2 && 0 !== v2.bitmap.width && 0 !== v2.bitmap.height) {
                var y2 = r2[d2][m2].rect;
                e.AlphaImage.copy(v2.bitmap, f2, { x: 0, y: 0 }, { x: y2.x + 1, y: y2.y + 1 }, v2.bitmap);
              }
            }
          }
          this.image = f2, this.positions = r2;
        };
        e.register("GlyphAtlas", o);
        var n = function(t2) {
          this.tileID = new e.OverscaledTileID(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId;
        };
        function a(t2, r2, i2) {
          for (var o2 = new e.EvaluationParameters(r2), n2 = 0, a2 = t2; n2 < a2.length; n2 += 1) {
            a2[n2].recalculate(o2, i2);
          }
        }
        function s(t2, r2) {
          var i2 = e.getArrayBuffer(t2.request, function(t3, i3, o2, n2) {
            t3 ? r2(t3) : i3 && r2(null, { vectorTile: new e.vectorTile.VectorTile(new e.pbf(i3)), rawData: i3, cacheControl: o2, expires: n2 });
          });
          return function() {
            i2.cancel(), r2();
          };
        }
        n.prototype.parse = function(t2, r2, i2, n2, s2) {
          var l2 = this;
          this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.CollisionBoxArray();
          var u2 = new e.DictionaryCoder(Object.keys(t2.layers).sort()), h2 = new e.FeatureIndex(this.tileID, this.promoteId);
          h2.bucketLayerIDs = [];
          var c2, p2, f2, d2, g2 = {}, m2 = { featureIndex: h2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: i2 }, v2 = r2.familiesBySource[this.source];
          for (var y2 in v2) {
            var x2 = t2.layers[y2];
            if (x2) {
              1 === x2.version && e.warnOnce('Vector tile source "' + this.source + '" layer "' + y2 + '" does not use vector tile spec v2 and therefore may have some rendering errors.');
              for (var w2 = u2.encode(y2), S2 = [], M2 = 0; M2 < x2.length; M2++) {
                var I2 = x2.feature(M2), b2 = h2.getId(I2, y2);
                S2.push({ feature: I2, id: b2, index: M2, sourceLayerIndex: w2 });
              }
              for (var P2 = 0, _2 = v2[y2]; P2 < _2.length; P2 += 1) {
                var k2 = _2[P2], T2 = k2[0];
                if (!(T2.minzoom && this.zoom < Math.floor(T2.minzoom))) {
                  if (!(T2.maxzoom && this.zoom >= T2.maxzoom)) {
                    if ("none" !== T2.visibility)
                      a(k2, this.zoom, i2), (g2[T2.id] = T2.createBucket({ index: h2.bucketLayerIDs.length, layers: k2, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: w2, sourceID: this.source })).populate(S2, m2), h2.bucketLayerIDs.push(k2.map(function(e2) {
                        return e2.id;
                      }));
                  }
                }
              }
            }
          }
          var C2 = e.mapObject(m2.glyphDependencies, function(e2) {
            return Object.keys(e2).map(Number);
          });
          Object.keys(C2).length ? n2.send("getGlyphs", { uid: this.uid, stacks: C2 }, function(e2, t3) {
            c2 || (c2 = e2, p2 = t3, z2.call(l2));
          }) : p2 = {};
          var L2 = Object.keys(m2.iconDependencies);
          L2.length ? n2.send("getImages", { icons: L2, source: this.source, tileID: this.tileID, type: "icons" }, function(e2, t3) {
            c2 || (c2 = e2, f2 = t3, z2.call(l2));
          }) : f2 = {};
          var D2 = Object.keys(m2.patternDependencies);
          function z2() {
            if (c2)
              return s2(c2);
            if (p2 && f2 && d2) {
              var t3 = new o(p2), r3 = new e.ImageAtlas(f2, d2);
              for (var n3 in g2) {
                var l3 = g2[n3];
                l3 instanceof e.SymbolBucket ? (a(l3.layers, this.zoom, i2), e.performSymbolLayout(l3, p2, t3.positions, f2, r3.iconPositions, this.showCollisionBoxes)) : l3.hasPattern && (l3 instanceof e.LineBucket || l3 instanceof e.FillBucket || l3 instanceof e.FillExtrusionBucket) && (a(l3.layers, this.zoom, i2), l3.addFeatures(m2, r3.patternPositions));
              }
              this.status = "done", s2(null, { buckets: e.values(g2).filter(function(e2) {
                return !e2.isEmpty();
              }), featureIndex: h2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, imageAtlas: r3, glyphMap: this.returnDependencies ? p2 : null, iconMap: this.returnDependencies ? f2 : null, glyphPositions: this.returnDependencies ? t3.positions : null });
            }
          }
          D2.length ? n2.send("getImages", { icons: D2, source: this.source, tileID: this.tileID, type: "patterns" }, function(e2, t3) {
            c2 || (c2 = e2, d2 = t3, z2.call(l2));
          }) : d2 = {}, z2.call(this);
        };
        var l = function(e2, t2, r2, i2) {
          this.actor = e2, this.layerIndex = t2, this.availableImages = r2, this.loadVectorData = i2 || s, this.loading = {}, this.loaded = {};
        };
        l.prototype.loadTile = function(t2, r2) {
          var i2 = this, o2 = t2.uid;
          this.loading || (this.loading = {});
          var a2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.RequestPerformance(t2.request), s2 = this.loading[o2] = new n(t2);
          s2.abort = this.loadVectorData(t2, function(t3, n2) {
            if (delete i2.loading[o2], t3 || !n2)
              return s2.status = "done", i2.loaded[o2] = s2, r2(t3);
            var l2 = n2.rawData, u2 = {};
            n2.expires && (u2.expires = n2.expires), n2.cacheControl && (u2.cacheControl = n2.cacheControl);
            var h2 = {};
            if (a2) {
              var c2 = a2.finish();
              c2 && (h2.resourceTiming = JSON.parse(JSON.stringify(c2)));
            }
            s2.vectorTile = n2.vectorTile, s2.parse(n2.vectorTile, i2.layerIndex, i2.availableImages, i2.actor, function(t4, i3) {
              if (t4 || !i3)
                return r2(t4);
              r2(null, e.extend({ rawTileData: l2.slice(0) }, i3, u2, h2));
            }), i2.loaded = i2.loaded || {}, i2.loaded[o2] = s2;
          });
        }, l.prototype.reloadTile = function(e2, t2) {
          var r2 = this, i2 = this.loaded, o2 = e2.uid, n2 = this;
          if (i2 && i2[o2]) {
            var a2 = i2[o2];
            a2.showCollisionBoxes = e2.showCollisionBoxes;
            var s2 = function(e3, i3) {
              var o3 = a2.reloadCallback;
              o3 && (delete a2.reloadCallback, a2.parse(a2.vectorTile, n2.layerIndex, r2.availableImages, n2.actor, o3)), t2(e3, i3);
            };
            "parsing" === a2.status ? a2.reloadCallback = s2 : "done" === a2.status && (a2.vectorTile ? a2.parse(a2.vectorTile, this.layerIndex, this.availableImages, this.actor, s2) : s2());
          }
        }, l.prototype.abortTile = function(e2, t2) {
          var r2 = this.loading, i2 = e2.uid;
          r2 && r2[i2] && r2[i2].abort && (r2[i2].abort(), delete r2[i2]), t2();
        }, l.prototype.removeTile = function(e2, t2) {
          var r2 = this.loaded, i2 = e2.uid;
          r2 && r2[i2] && delete r2[i2], t2();
        };
        var u = e.window.ImageBitmap, h = function() {
          this.loaded = {};
        };
        h.prototype.loadTile = function(t2, r2) {
          var i2 = t2.uid, o2 = t2.encoding, n2 = t2.rawImageData, a2 = u && n2 instanceof u ? this.getImageData(n2) : n2, s2 = new e.DEMData(i2, a2, o2);
          this.loaded = this.loaded || {}, this.loaded[i2] = s2, r2(null, s2);
        }, h.prototype.getImageData = function(t2) {
          this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t2.width, t2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t2.width, this.offscreenCanvas.height = t2.height, this.offscreenCanvasContext.drawImage(t2, 0, 0, t2.width, t2.height);
          var r2 = this.offscreenCanvasContext.getImageData(-1, -1, t2.width + 2, t2.height + 2);
          return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e.RGBAImage({ width: r2.width, height: r2.height }, r2.data);
        }, h.prototype.removeTile = function(e2) {
          var t2 = this.loaded, r2 = e2.uid;
          t2 && t2[r2] && delete t2[r2];
        };
        var c = 6378137;
        function p(e2) {
          var t2 = 0;
          if (e2 && e2.length > 0) {
            t2 += Math.abs(f(e2[0]));
            for (var r2 = 1; r2 < e2.length; r2++)
              t2 -= Math.abs(f(e2[r2]));
          }
          return t2;
        }
        function f(e2) {
          var t2, r2, i2, o2, n2, a2, s2 = 0, l2 = e2.length;
          if (l2 > 2) {
            for (a2 = 0; a2 < l2; a2++)
              a2 === l2 - 2 ? (i2 = l2 - 2, o2 = l2 - 1, n2 = 0) : a2 === l2 - 1 ? (i2 = l2 - 1, o2 = 0, n2 = 1) : (i2 = a2, o2 = a2 + 1, n2 = a2 + 2), t2 = e2[i2], r2 = e2[o2], s2 += (d(e2[n2][0]) - d(t2[0])) * Math.sin(d(r2[1]));
            s2 = s2 * c * c / 2;
          }
          return s2;
        }
        function d(e2) {
          return e2 * Math.PI / 180;
        }
        var g = { geometry: function e2(t2) {
          var r2, i2 = 0;
          switch (t2.type) {
            case "Polygon":
              return p(t2.coordinates);
            case "MultiPolygon":
              for (r2 = 0; r2 < t2.coordinates.length; r2++)
                i2 += p(t2.coordinates[r2]);
              return i2;
            case "Point":
            case "MultiPoint":
            case "LineString":
            case "MultiLineString":
              return 0;
            case "GeometryCollection":
              for (r2 = 0; r2 < t2.geometries.length; r2++)
                i2 += e2(t2.geometries[r2]);
              return i2;
          }
        }, ring: f }, m = function e2(t2, r2) {
          switch (t2 && t2.type || null) {
            case "FeatureCollection":
              return t2.features = t2.features.map(v(e2, r2)), t2;
            case "GeometryCollection":
              return t2.geometries = t2.geometries.map(v(e2, r2)), t2;
            case "Feature":
              return t2.geometry = e2(t2.geometry, r2), t2;
            case "Polygon":
            case "MultiPolygon":
              return function(e3, t3) {
                "Polygon" === e3.type ? e3.coordinates = y(e3.coordinates, t3) : "MultiPolygon" === e3.type && (e3.coordinates = e3.coordinates.map(v(y, t3)));
                return e3;
              }(t2, r2);
            default:
              return t2;
          }
        };
        function v(e2, t2) {
          return function(r2) {
            return e2(r2, t2);
          };
        }
        function y(e2, t2) {
          t2 = !!t2, e2[0] = x(e2[0], t2);
          for (var r2 = 1; r2 < e2.length; r2++)
            e2[r2] = x(e2[r2], !t2);
          return e2;
        }
        function x(e2, t2) {
          return function(e3) {
            return g.ring(e3) >= 0;
          }(e2) === t2 ? e2 : e2.reverse();
        }
        var w = e.vectorTile.VectorTileFeature.prototype.toGeoJSON, S = function(t2) {
          this._feature = t2, this.extent = e.EXTENT, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
        };
        S.prototype.loadGeometry = function() {
          if (1 === this._feature.type) {
            for (var t2 = [], r2 = 0, i2 = this._feature.geometry; r2 < i2.length; r2 += 1) {
              var o2 = i2[r2];
              t2.push([new e.Point$1(o2[0], o2[1])]);
            }
            return t2;
          }
          for (var n2 = [], a2 = 0, s2 = this._feature.geometry; a2 < s2.length; a2 += 1) {
            for (var l2 = [], u2 = 0, h2 = s2[a2]; u2 < h2.length; u2 += 1) {
              var c2 = h2[u2];
              l2.push(new e.Point$1(c2[0], c2[1]));
            }
            n2.push(l2);
          }
          return n2;
        }, S.prototype.toGeoJSON = function(e2, t2, r2) {
          return w.call(this, e2, t2, r2);
        };
        var M = function(t2) {
          this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t2.length, this._features = t2;
        };
        M.prototype.feature = function(e2) {
          return new S(this._features[e2]);
        };
        var I = e.vectorTile.VectorTileFeature, b = P;
        function P(e2, t2) {
          this.options = t2 || {}, this.features = e2, this.length = e2.length;
        }
        function _(e2, t2) {
          this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
        }
        P.prototype.feature = function(e2) {
          return new _(this.features[e2], this.options.extent);
        }, _.prototype.loadGeometry = function() {
          var t2 = this.rawGeometry;
          this.geometry = [];
          for (var r2 = 0; r2 < t2.length; r2++) {
            for (var i2 = t2[r2], o2 = [], n2 = 0; n2 < i2.length; n2++)
              o2.push(new e.Point$1(i2[n2][0], i2[n2][1]));
            this.geometry.push(o2);
          }
          return this.geometry;
        }, _.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e2 = this.geometry, t2 = 1 / 0, r2 = -1 / 0, i2 = 1 / 0, o2 = -1 / 0, n2 = 0; n2 < e2.length; n2++)
            for (var a2 = e2[n2], s2 = 0; s2 < a2.length; s2++) {
              var l2 = a2[s2];
              t2 = Math.min(t2, l2.x), r2 = Math.max(r2, l2.x), i2 = Math.min(i2, l2.y), o2 = Math.max(o2, l2.y);
            }
          return [t2, i2, r2, o2];
        }, _.prototype.toGeoJSON = I.prototype.toGeoJSON;
        var k = D, T = D, C = function(e2, t2) {
          t2 = t2 || {};
          var r2 = {};
          for (var i2 in e2)
            r2[i2] = new b(e2[i2].features, t2), r2[i2].name = i2, r2[i2].version = t2.version, r2[i2].extent = t2.extent;
          return D({ layers: r2 });
        }, L = b;
        function D(t2) {
          var r2 = new e.pbf();
          return function(e2, t3) {
            for (var r3 in e2.layers)
              t3.writeMessage(3, z, e2.layers[r3]);
          }(t2, r2), r2.finish();
        }
        function z(e2, t2) {
          var r2;
          t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
          var i2 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (r2 = 0; r2 < e2.length; r2++)
            i2.feature = e2.feature(r2), t2.writeMessage(2, O, i2);
          var o2 = i2.keys;
          for (r2 = 0; r2 < o2.length; r2++)
            t2.writeStringField(3, o2[r2]);
          var n2 = i2.values;
          for (r2 = 0; r2 < n2.length; r2++)
            t2.writeMessage(4, J, n2[r2]);
        }
        function O(e2, t2) {
          var r2 = e2.feature;
          void 0 !== r2.id && t2.writeVarintField(1, r2.id), t2.writeMessage(2, E, e2), t2.writeVarintField(3, r2.type), t2.writeMessage(4, A, r2);
        }
        function E(e2, t2) {
          var r2 = e2.feature, i2 = e2.keys, o2 = e2.values, n2 = e2.keycache, a2 = e2.valuecache;
          for (var s2 in r2.properties) {
            var l2 = r2.properties[s2], u2 = n2[s2];
            if (null !== l2) {
              void 0 === u2 && (i2.push(s2), u2 = i2.length - 1, n2[s2] = u2), t2.writeVarint(u2);
              var h2 = typeof l2;
              "string" !== h2 && "boolean" !== h2 && "number" !== h2 && (l2 = JSON.stringify(l2));
              var c2 = h2 + ":" + l2, p2 = a2[c2];
              void 0 === p2 && (o2.push(l2), p2 = o2.length - 1, a2[c2] = p2), t2.writeVarint(p2);
            }
          }
        }
        function F(e2, t2) {
          return (t2 << 3) + (7 & e2);
        }
        function N(e2) {
          return e2 << 1 ^ e2 >> 31;
        }
        function A(e2, t2) {
          for (var r2 = e2.loadGeometry(), i2 = e2.type, o2 = 0, n2 = 0, a2 = r2.length, s2 = 0; s2 < a2; s2++) {
            var l2 = r2[s2], u2 = 1;
            1 === i2 && (u2 = l2.length), t2.writeVarint(F(1, u2));
            for (var h2 = 3 === i2 ? l2.length - 1 : l2.length, c2 = 0; c2 < h2; c2++) {
              1 === c2 && 1 !== i2 && t2.writeVarint(F(2, h2 - 1));
              var p2 = l2[c2].x - o2, f2 = l2[c2].y - n2;
              t2.writeVarint(N(p2)), t2.writeVarint(N(f2)), o2 += p2, n2 += f2;
            }
            3 === i2 && t2.writeVarint(F(7, 1));
          }
        }
        function J(e2, t2) {
          var r2 = typeof e2;
          "string" === r2 ? t2.writeStringField(1, e2) : "boolean" === r2 ? t2.writeBooleanField(7, e2) : "number" === r2 && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
        }
        function Z(e2, t2, r2, i2, o2, n2) {
          if (!(o2 - i2 <= r2)) {
            var a2 = i2 + o2 >> 1;
            !function e3(t3, r3, i3, o3, n3, a3) {
              for (; n3 > o3; ) {
                if (n3 - o3 > 600) {
                  var s2 = n3 - o3 + 1, l2 = i3 - o3 + 1, u2 = Math.log(s2), h2 = 0.5 * Math.exp(2 * u2 / 3), c2 = 0.5 * Math.sqrt(u2 * h2 * (s2 - h2) / s2) * (l2 - s2 / 2 < 0 ? -1 : 1), p2 = Math.max(o3, Math.floor(i3 - l2 * h2 / s2 + c2)), f2 = Math.min(n3, Math.floor(i3 + (s2 - l2) * h2 / s2 + c2));
                  e3(t3, r3, i3, p2, f2, a3);
                }
                var d2 = r3[2 * i3 + a3], g2 = o3, m2 = n3;
                for (B(t3, r3, o3, i3), r3[2 * n3 + a3] > d2 && B(t3, r3, o3, n3); g2 < m2; ) {
                  for (B(t3, r3, g2, m2), g2++, m2--; r3[2 * g2 + a3] < d2; )
                    g2++;
                  for (; r3[2 * m2 + a3] > d2; )
                    m2--;
                }
                r3[2 * o3 + a3] === d2 ? B(t3, r3, o3, m2) : (m2++, B(t3, r3, m2, n3)), m2 <= i3 && (o3 = m2 + 1), i3 <= m2 && (n3 = m2 - 1);
              }
            }(e2, t2, a2, i2, o2, n2 % 2), Z(e2, t2, r2, i2, a2 - 1, n2 + 1), Z(e2, t2, r2, a2 + 1, o2, n2 + 1);
          }
        }
        function B(e2, t2, r2, i2) {
          G(e2, r2, i2), G(t2, 2 * r2, 2 * i2), G(t2, 2 * r2 + 1, 2 * i2 + 1);
        }
        function G(e2, t2, r2) {
          var i2 = e2[t2];
          e2[t2] = e2[r2], e2[r2] = i2;
        }
        function Y(e2, t2, r2, i2) {
          var o2 = e2 - r2, n2 = t2 - i2;
          return o2 * o2 + n2 * n2;
        }
        k.fromVectorTileJs = T, k.fromGeojsonVt = C, k.GeoJSONWrapper = L;
        var j = function(e2) {
          return e2[0];
        }, V = function(e2) {
          return e2[1];
        }, X = function(e2, t2, r2, i2, o2) {
          void 0 === t2 && (t2 = j), void 0 === r2 && (r2 = V), void 0 === i2 && (i2 = 64), void 0 === o2 && (o2 = Float64Array), this.nodeSize = i2, this.points = e2;
          for (var n2 = e2.length < 65536 ? Uint16Array : Uint32Array, a2 = this.ids = new n2(e2.length), s2 = this.coords = new o2(2 * e2.length), l2 = 0; l2 < e2.length; l2++)
            a2[l2] = l2, s2[2 * l2] = t2(e2[l2]), s2[2 * l2 + 1] = r2(e2[l2]);
          Z(a2, s2, i2, 0, a2.length - 1, 0);
        };
        X.prototype.range = function(e2, t2, r2, i2) {
          return function(e3, t3, r3, i3, o2, n2, a2) {
            for (var s2, l2, u2 = [0, e3.length - 1, 0], h2 = []; u2.length; ) {
              var c2 = u2.pop(), p2 = u2.pop(), f2 = u2.pop();
              if (p2 - f2 <= a2)
                for (var d2 = f2; d2 <= p2; d2++)
                  s2 = t3[2 * d2], l2 = t3[2 * d2 + 1], s2 >= r3 && s2 <= o2 && l2 >= i3 && l2 <= n2 && h2.push(e3[d2]);
              else {
                var g2 = Math.floor((f2 + p2) / 2);
                s2 = t3[2 * g2], l2 = t3[2 * g2 + 1], s2 >= r3 && s2 <= o2 && l2 >= i3 && l2 <= n2 && h2.push(e3[g2]);
                var m2 = (c2 + 1) % 2;
                (0 === c2 ? r3 <= s2 : i3 <= l2) && (u2.push(f2), u2.push(g2 - 1), u2.push(m2)), (0 === c2 ? o2 >= s2 : n2 >= l2) && (u2.push(g2 + 1), u2.push(p2), u2.push(m2));
              }
            }
            return h2;
          }(this.ids, this.coords, e2, t2, r2, i2, this.nodeSize);
        }, X.prototype.within = function(e2, t2, r2) {
          return function(e3, t3, r3, i2, o2, n2) {
            for (var a2 = [0, e3.length - 1, 0], s2 = [], l2 = o2 * o2; a2.length; ) {
              var u2 = a2.pop(), h2 = a2.pop(), c2 = a2.pop();
              if (h2 - c2 <= n2)
                for (var p2 = c2; p2 <= h2; p2++)
                  Y(t3[2 * p2], t3[2 * p2 + 1], r3, i2) <= l2 && s2.push(e3[p2]);
              else {
                var f2 = Math.floor((c2 + h2) / 2), d2 = t3[2 * f2], g2 = t3[2 * f2 + 1];
                Y(d2, g2, r3, i2) <= l2 && s2.push(e3[f2]);
                var m2 = (u2 + 1) % 2;
                (0 === u2 ? r3 - o2 <= d2 : i2 - o2 <= g2) && (a2.push(c2), a2.push(f2 - 1), a2.push(m2)), (0 === u2 ? r3 + o2 >= d2 : i2 + o2 >= g2) && (a2.push(f2 + 1), a2.push(h2), a2.push(m2));
              }
            }
            return s2;
          }(this.ids, this.coords, e2, t2, r2, this.nodeSize);
        };
        var W, R = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: function(e2) {
          return e2;
        } }, q = Math.fround || (W = new Float32Array(1), function(e2) {
          return W[0] = +e2, W[0];
        }), U = function(e2) {
          this.options = re(Object.create(R), e2), this.trees = new Array(this.options.maxZoom + 1);
        };
        function $(e2, t2, r2, i2, o2) {
          return { x: q(e2), y: q(t2), zoom: 1 / 0, id: r2, parentId: -1, numPoints: i2, properties: o2 };
        }
        function H(e2, t2) {
          var r2 = e2.geometry.coordinates, i2 = r2[0], o2 = r2[1];
          return { x: q(ee(i2)), y: q(te(o2)), zoom: 1 / 0, index: t2, parentId: -1 };
        }
        function K(e2) {
          return { type: "Feature", id: e2.id, properties: Q(e2), geometry: { type: "Point", coordinates: [(i2 = e2.x, 360 * (i2 - 0.5)), (t2 = e2.y, r2 = (180 - 360 * t2) * Math.PI / 180, 360 * Math.atan(Math.exp(r2)) / Math.PI - 90)] } };
          var t2, r2, i2;
        }
        function Q(e2) {
          var t2 = e2.numPoints, r2 = t2 >= 1e4 ? Math.round(t2 / 1e3) + "k" : t2 >= 1e3 ? Math.round(t2 / 100) / 10 + "k" : t2;
          return re(re({}, e2.properties), { cluster: true, cluster_id: e2.id, point_count: t2, point_count_abbreviated: r2 });
        }
        function ee(e2) {
          return e2 / 360 + 0.5;
        }
        function te(e2) {
          var t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
        }
        function re(e2, t2) {
          for (var r2 in t2)
            e2[r2] = t2[r2];
          return e2;
        }
        function ie(e2) {
          return e2.x;
        }
        function oe(e2) {
          return e2.y;
        }
        function ne(e2, t2, r2, i2, o2, n2) {
          var a2 = o2 - r2, s2 = n2 - i2;
          if (0 !== a2 || 0 !== s2) {
            var l2 = ((e2 - r2) * a2 + (t2 - i2) * s2) / (a2 * a2 + s2 * s2);
            l2 > 1 ? (r2 = o2, i2 = n2) : l2 > 0 && (r2 += a2 * l2, i2 += s2 * l2);
          }
          return (a2 = e2 - r2) * a2 + (s2 = t2 - i2) * s2;
        }
        function ae(e2, t2, r2, i2) {
          var o2 = { id: void 0 === e2 ? null : e2, type: t2, geometry: r2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return function(e3) {
            var t3 = e3.geometry, r3 = e3.type;
            if ("Point" === r3 || "MultiPoint" === r3 || "LineString" === r3)
              se(e3, t3);
            else if ("Polygon" === r3 || "MultiLineString" === r3)
              for (var i3 = 0; i3 < t3.length; i3++)
                se(e3, t3[i3]);
            else if ("MultiPolygon" === r3)
              for (i3 = 0; i3 < t3.length; i3++)
                for (var o3 = 0; o3 < t3[i3].length; o3++)
                  se(e3, t3[i3][o3]);
          }(o2), o2;
        }
        function se(e2, t2) {
          for (var r2 = 0; r2 < t2.length; r2 += 3)
            e2.minX = Math.min(e2.minX, t2[r2]), e2.minY = Math.min(e2.minY, t2[r2 + 1]), e2.maxX = Math.max(e2.maxX, t2[r2]), e2.maxY = Math.max(e2.maxY, t2[r2 + 1]);
        }
        function le(e2, t2, r2, i2) {
          if (t2.geometry) {
            var o2 = t2.geometry.coordinates, n2 = t2.geometry.type, a2 = Math.pow(r2.tolerance / ((1 << r2.maxZoom) * r2.extent), 2), s2 = [], l2 = t2.id;
            if (r2.promoteId ? l2 = t2.properties[r2.promoteId] : r2.generateId && (l2 = i2 || 0), "Point" === n2)
              ue(o2, s2);
            else if ("MultiPoint" === n2)
              for (var u2 = 0; u2 < o2.length; u2++)
                ue(o2[u2], s2);
            else if ("LineString" === n2)
              he(o2, s2, a2, false);
            else if ("MultiLineString" === n2) {
              if (r2.lineMetrics) {
                for (u2 = 0; u2 < o2.length; u2++)
                  s2 = [], he(o2[u2], s2, a2, false), e2.push(ae(l2, "LineString", s2, t2.properties));
                return;
              }
              ce(o2, s2, a2, false);
            } else if ("Polygon" === n2)
              ce(o2, s2, a2, true);
            else {
              if ("MultiPolygon" !== n2) {
                if ("GeometryCollection" === n2) {
                  for (u2 = 0; u2 < t2.geometry.geometries.length; u2++)
                    le(e2, { id: l2, geometry: t2.geometry.geometries[u2], properties: t2.properties }, r2, i2);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (u2 = 0; u2 < o2.length; u2++) {
                var h2 = [];
                ce(o2[u2], h2, a2, true), s2.push(h2);
              }
            }
            e2.push(ae(l2, n2, s2, t2.properties));
          }
        }
        function ue(e2, t2) {
          t2.push(pe(e2[0])), t2.push(fe(e2[1])), t2.push(0);
        }
        function he(e2, t2, r2, i2) {
          for (var o2, n2, a2 = 0, s2 = 0; s2 < e2.length; s2++) {
            var l2 = pe(e2[s2][0]), u2 = fe(e2[s2][1]);
            t2.push(l2), t2.push(u2), t2.push(0), s2 > 0 && (a2 += i2 ? (o2 * u2 - l2 * n2) / 2 : Math.sqrt(Math.pow(l2 - o2, 2) + Math.pow(u2 - n2, 2))), o2 = l2, n2 = u2;
          }
          var h2 = t2.length - 3;
          t2[2] = 1, function e3(t3, r3, i3, o3) {
            for (var n3, a3 = o3, s3 = i3 - r3 >> 1, l3 = i3 - r3, u3 = t3[r3], h3 = t3[r3 + 1], c2 = t3[i3], p2 = t3[i3 + 1], f2 = r3 + 3; f2 < i3; f2 += 3) {
              var d2 = ne(t3[f2], t3[f2 + 1], u3, h3, c2, p2);
              if (d2 > a3)
                n3 = f2, a3 = d2;
              else if (d2 === a3) {
                var g2 = Math.abs(f2 - s3);
                g2 < l3 && (n3 = f2, l3 = g2);
              }
            }
            a3 > o3 && (n3 - r3 > 3 && e3(t3, r3, n3, o3), t3[n3 + 2] = a3, i3 - n3 > 3 && e3(t3, n3, i3, o3));
          }(t2, 0, h2, r2), t2[h2 + 2] = 1, t2.size = Math.abs(a2), t2.start = 0, t2.end = t2.size;
        }
        function ce(e2, t2, r2, i2) {
          for (var o2 = 0; o2 < e2.length; o2++) {
            var n2 = [];
            he(e2[o2], n2, r2, i2), t2.push(n2);
          }
        }
        function pe(e2) {
          return e2 / 360 + 0.5;
        }
        function fe(e2) {
          var t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
        }
        function de(e2, t2, r2, i2, o2, n2, a2, s2) {
          if (i2 /= t2, n2 >= (r2 /= t2) && a2 < i2)
            return e2;
          if (a2 < r2 || n2 >= i2)
            return null;
          for (var l2 = [], u2 = 0; u2 < e2.length; u2++) {
            var h2 = e2[u2], c2 = h2.geometry, p2 = h2.type, f2 = 0 === o2 ? h2.minX : h2.minY, d2 = 0 === o2 ? h2.maxX : h2.maxY;
            if (f2 >= r2 && d2 < i2)
              l2.push(h2);
            else if (!(d2 < r2 || f2 >= i2)) {
              var g2 = [];
              if ("Point" === p2 || "MultiPoint" === p2)
                ge(c2, g2, r2, i2, o2);
              else if ("LineString" === p2)
                me(c2, g2, r2, i2, o2, false, s2.lineMetrics);
              else if ("MultiLineString" === p2)
                ye(c2, g2, r2, i2, o2, false);
              else if ("Polygon" === p2)
                ye(c2, g2, r2, i2, o2, true);
              else if ("MultiPolygon" === p2)
                for (var m2 = 0; m2 < c2.length; m2++) {
                  var v2 = [];
                  ye(c2[m2], v2, r2, i2, o2, true), v2.length && g2.push(v2);
                }
              if (g2.length) {
                if (s2.lineMetrics && "LineString" === p2) {
                  for (m2 = 0; m2 < g2.length; m2++)
                    l2.push(ae(h2.id, p2, g2[m2], h2.tags));
                  continue;
                }
                "LineString" !== p2 && "MultiLineString" !== p2 || (1 === g2.length ? (p2 = "LineString", g2 = g2[0]) : p2 = "MultiLineString"), "Point" !== p2 && "MultiPoint" !== p2 || (p2 = 3 === g2.length ? "Point" : "MultiPoint"), l2.push(ae(h2.id, p2, g2, h2.tags));
              }
            }
          }
          return l2.length ? l2 : null;
        }
        function ge(e2, t2, r2, i2, o2) {
          for (var n2 = 0; n2 < e2.length; n2 += 3) {
            var a2 = e2[n2 + o2];
            a2 >= r2 && a2 <= i2 && (t2.push(e2[n2]), t2.push(e2[n2 + 1]), t2.push(e2[n2 + 2]));
          }
        }
        function me(e2, t2, r2, i2, o2, n2, a2) {
          for (var s2, l2, u2 = ve(e2), h2 = 0 === o2 ? we : Se, c2 = e2.start, p2 = 0; p2 < e2.length - 3; p2 += 3) {
            var f2 = e2[p2], d2 = e2[p2 + 1], g2 = e2[p2 + 2], m2 = e2[p2 + 3], v2 = e2[p2 + 4], y2 = 0 === o2 ? f2 : d2, x2 = 0 === o2 ? m2 : v2, w2 = false;
            a2 && (s2 = Math.sqrt(Math.pow(f2 - m2, 2) + Math.pow(d2 - v2, 2))), y2 < r2 ? x2 > r2 && (l2 = h2(u2, f2, d2, m2, v2, r2), a2 && (u2.start = c2 + s2 * l2)) : y2 > i2 ? x2 < i2 && (l2 = h2(u2, f2, d2, m2, v2, i2), a2 && (u2.start = c2 + s2 * l2)) : xe(u2, f2, d2, g2), x2 < r2 && y2 >= r2 && (l2 = h2(u2, f2, d2, m2, v2, r2), w2 = true), x2 > i2 && y2 <= i2 && (l2 = h2(u2, f2, d2, m2, v2, i2), w2 = true), !n2 && w2 && (a2 && (u2.end = c2 + s2 * l2), t2.push(u2), u2 = ve(e2)), a2 && (c2 += s2);
          }
          var S2 = e2.length - 3;
          f2 = e2[S2], d2 = e2[S2 + 1], g2 = e2[S2 + 2], (y2 = 0 === o2 ? f2 : d2) >= r2 && y2 <= i2 && xe(u2, f2, d2, g2), S2 = u2.length - 3, n2 && S2 >= 3 && (u2[S2] !== u2[0] || u2[S2 + 1] !== u2[1]) && xe(u2, u2[0], u2[1], u2[2]), u2.length && t2.push(u2);
        }
        function ve(e2) {
          var t2 = [];
          return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
        }
        function ye(e2, t2, r2, i2, o2, n2) {
          for (var a2 = 0; a2 < e2.length; a2++)
            me(e2[a2], t2, r2, i2, o2, n2, false);
        }
        function xe(e2, t2, r2, i2) {
          e2.push(t2), e2.push(r2), e2.push(i2);
        }
        function we(e2, t2, r2, i2, o2, n2) {
          var a2 = (n2 - t2) / (i2 - t2);
          return e2.push(n2), e2.push(r2 + (o2 - r2) * a2), e2.push(1), a2;
        }
        function Se(e2, t2, r2, i2, o2, n2) {
          var a2 = (n2 - r2) / (o2 - r2);
          return e2.push(t2 + (i2 - t2) * a2), e2.push(n2), e2.push(1), a2;
        }
        function Me(e2, t2) {
          for (var r2 = [], i2 = 0; i2 < e2.length; i2++) {
            var o2, n2 = e2[i2], a2 = n2.type;
            if ("Point" === a2 || "MultiPoint" === a2 || "LineString" === a2)
              o2 = Ie(n2.geometry, t2);
            else if ("MultiLineString" === a2 || "Polygon" === a2) {
              o2 = [];
              for (var s2 = 0; s2 < n2.geometry.length; s2++)
                o2.push(Ie(n2.geometry[s2], t2));
            } else if ("MultiPolygon" === a2)
              for (o2 = [], s2 = 0; s2 < n2.geometry.length; s2++) {
                for (var l2 = [], u2 = 0; u2 < n2.geometry[s2].length; u2++)
                  l2.push(Ie(n2.geometry[s2][u2], t2));
                o2.push(l2);
              }
            r2.push(ae(n2.id, a2, o2, n2.tags));
          }
          return r2;
        }
        function Ie(e2, t2) {
          var r2 = [];
          r2.size = e2.size, void 0 !== e2.start && (r2.start = e2.start, r2.end = e2.end);
          for (var i2 = 0; i2 < e2.length; i2 += 3)
            r2.push(e2[i2] + t2, e2[i2 + 1], e2[i2 + 2]);
          return r2;
        }
        function be(e2, t2) {
          if (e2.transformed)
            return e2;
          var r2, i2, o2, n2 = 1 << e2.z, a2 = e2.x, s2 = e2.y;
          for (r2 = 0; r2 < e2.features.length; r2++) {
            var l2 = e2.features[r2], u2 = l2.geometry, h2 = l2.type;
            if (l2.geometry = [], 1 === h2)
              for (i2 = 0; i2 < u2.length; i2 += 2)
                l2.geometry.push(Pe(u2[i2], u2[i2 + 1], t2, n2, a2, s2));
            else
              for (i2 = 0; i2 < u2.length; i2++) {
                var c2 = [];
                for (o2 = 0; o2 < u2[i2].length; o2 += 2)
                  c2.push(Pe(u2[i2][o2], u2[i2][o2 + 1], t2, n2, a2, s2));
                l2.geometry.push(c2);
              }
          }
          return e2.transformed = true, e2;
        }
        function Pe(e2, t2, r2, i2, o2, n2) {
          return [Math.round(r2 * (e2 * i2 - o2)), Math.round(r2 * (t2 * i2 - n2))];
        }
        function _e(e2, t2, r2, i2, o2) {
          for (var n2 = t2 === o2.maxZoom ? 0 : o2.tolerance / ((1 << t2) * o2.extent), a2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r2, y: i2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, s2 = 0; s2 < e2.length; s2++) {
            a2.numFeatures++, ke(a2, e2[s2], n2, o2);
            var l2 = e2[s2].minX, u2 = e2[s2].minY, h2 = e2[s2].maxX, c2 = e2[s2].maxY;
            l2 < a2.minX && (a2.minX = l2), u2 < a2.minY && (a2.minY = u2), h2 > a2.maxX && (a2.maxX = h2), c2 > a2.maxY && (a2.maxY = c2);
          }
          return a2;
        }
        function ke(e2, t2, r2, i2) {
          var o2 = t2.geometry, n2 = t2.type, a2 = [];
          if ("Point" === n2 || "MultiPoint" === n2)
            for (var s2 = 0; s2 < o2.length; s2 += 3)
              a2.push(o2[s2]), a2.push(o2[s2 + 1]), e2.numPoints++, e2.numSimplified++;
          else if ("LineString" === n2)
            Te(a2, o2, e2, r2, false, false);
          else if ("MultiLineString" === n2 || "Polygon" === n2)
            for (s2 = 0; s2 < o2.length; s2++)
              Te(a2, o2[s2], e2, r2, "Polygon" === n2, 0 === s2);
          else if ("MultiPolygon" === n2)
            for (var l2 = 0; l2 < o2.length; l2++) {
              var u2 = o2[l2];
              for (s2 = 0; s2 < u2.length; s2++)
                Te(a2, u2[s2], e2, r2, true, 0 === s2);
            }
          if (a2.length) {
            var h2 = t2.tags || null;
            if ("LineString" === n2 && i2.lineMetrics) {
              for (var c2 in h2 = {}, t2.tags)
                h2[c2] = t2.tags[c2];
              h2.mapbox_clip_start = o2.start / o2.size, h2.mapbox_clip_end = o2.end / o2.size;
            }
            var p2 = { geometry: a2, type: "Polygon" === n2 || "MultiPolygon" === n2 ? 3 : "LineString" === n2 || "MultiLineString" === n2 ? 2 : 1, tags: h2 };
            null !== t2.id && (p2.id = t2.id), e2.features.push(p2);
          }
        }
        function Te(e2, t2, r2, i2, o2, n2) {
          var a2 = i2 * i2;
          if (i2 > 0 && t2.size < (o2 ? a2 : i2))
            r2.numPoints += t2.length / 3;
          else {
            for (var s2 = [], l2 = 0; l2 < t2.length; l2 += 3)
              (0 === i2 || t2[l2 + 2] > a2) && (r2.numSimplified++, s2.push(t2[l2]), s2.push(t2[l2 + 1])), r2.numPoints++;
            o2 && function(e3, t3) {
              for (var r3 = 0, i3 = 0, o3 = e3.length, n3 = o3 - 2; i3 < o3; n3 = i3, i3 += 2)
                r3 += (e3[i3] - e3[n3]) * (e3[i3 + 1] + e3[n3 + 1]);
              if (r3 > 0 === t3)
                for (i3 = 0, o3 = e3.length; i3 < o3 / 2; i3 += 2) {
                  var a3 = e3[i3], s3 = e3[i3 + 1];
                  e3[i3] = e3[o3 - 2 - i3], e3[i3 + 1] = e3[o3 - 1 - i3], e3[o3 - 2 - i3] = a3, e3[o3 - 1 - i3] = s3;
                }
            }(s2, n2), e2.push(s2);
          }
        }
        function Ce(e2, t2) {
          var r2 = (t2 = this.options = function(e3, t3) {
            for (var r3 in t3)
              e3[r3] = t3[r3];
            return e3;
          }(Object.create(this.options), t2)).debug;
          if (r2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t2.promoteId && t2.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          var i2 = function(e3, t3) {
            var r3 = [];
            if ("FeatureCollection" === e3.type)
              for (var i3 = 0; i3 < e3.features.length; i3++)
                le(r3, e3.features[i3], t3, i3);
            else
              "Feature" === e3.type ? le(r3, e3, t3) : le(r3, { geometry: e3 }, t3);
            return r3;
          }(e2, t2);
          this.tiles = {}, this.tileCoords = [], r2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (i2 = function(e3, t3) {
            var r3 = t3.buffer / t3.extent, i3 = e3, o2 = de(e3, 1, -1 - r3, r3, 0, -1, 2, t3), n2 = de(e3, 1, 1 - r3, 2 + r3, 0, -1, 2, t3);
            return (o2 || n2) && (i3 = de(e3, 1, -r3, 1 + r3, 0, -1, 2, t3) || [], o2 && (i3 = Me(o2, 1).concat(i3)), n2 && (i3 = i3.concat(Me(n2, -1)))), i3;
          }(i2, t2)).length && this.splitTile(i2, 0, 0, 0), r2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function Le(e2, t2, r2) {
          return 32 * ((1 << e2) * r2 + t2) + e2;
        }
        function De(e2, t2) {
          var r2 = e2.tileID.canonical;
          if (!this._geoJSONIndex)
            return t2(null, null);
          var i2 = this._geoJSONIndex.getTile(r2.z, r2.x, r2.y);
          if (!i2)
            return t2(null, null);
          var o2 = new M(i2.features), n2 = k(o2);
          0 === n2.byteOffset && n2.byteLength === n2.buffer.byteLength || (n2 = new Uint8Array(n2)), t2(null, { vectorTile: o2, rawData: n2.buffer });
        }
        U.prototype.load = function(e2) {
          var t2 = this.options, r2 = t2.log, i2 = t2.minZoom, o2 = t2.maxZoom, n2 = t2.nodeSize;
          r2 && console.time("total time");
          var a2 = "prepare " + e2.length + " points";
          r2 && console.time(a2), this.points = e2;
          for (var s2 = [], l2 = 0; l2 < e2.length; l2++)
            e2[l2].geometry && s2.push(H(e2[l2], l2));
          this.trees[o2 + 1] = new X(s2, ie, oe, n2, Float32Array), r2 && console.timeEnd(a2);
          for (var u2 = o2; u2 >= i2; u2--) {
            var h2 = +Date.now();
            s2 = this._cluster(s2, u2), this.trees[u2] = new X(s2, ie, oe, n2, Float32Array), r2 && console.log("z%d: %d clusters in %dms", u2, s2.length, +Date.now() - h2);
          }
          return r2 && console.timeEnd("total time"), this;
        }, U.prototype.getClusters = function(e2, t2) {
          var r2 = ((e2[0] + 180) % 360 + 360) % 360 - 180, i2 = Math.max(-90, Math.min(90, e2[1])), o2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180, n2 = Math.max(-90, Math.min(90, e2[3]));
          if (e2[2] - e2[0] >= 360)
            r2 = -180, o2 = 180;
          else if (r2 > o2) {
            var a2 = this.getClusters([r2, i2, 180, n2], t2), s2 = this.getClusters([-180, i2, o2, n2], t2);
            return a2.concat(s2);
          }
          for (var l2 = this.trees[this._limitZoom(t2)], u2 = [], h2 = 0, c2 = l2.range(ee(r2), te(n2), ee(o2), te(i2)); h2 < c2.length; h2 += 1) {
            var p2 = c2[h2], f2 = l2.points[p2];
            u2.push(f2.numPoints ? K(f2) : this.points[f2.index]);
          }
          return u2;
        }, U.prototype.getChildren = function(e2) {
          var t2 = this._getOriginId(e2), r2 = this._getOriginZoom(e2), i2 = "No cluster with the specified id.", o2 = this.trees[r2];
          if (!o2)
            throw new Error(i2);
          var n2 = o2.points[t2];
          if (!n2)
            throw new Error(i2);
          for (var a2 = this.options.radius / (this.options.extent * Math.pow(2, r2 - 1)), s2 = [], l2 = 0, u2 = o2.within(n2.x, n2.y, a2); l2 < u2.length; l2 += 1) {
            var h2 = u2[l2], c2 = o2.points[h2];
            c2.parentId === e2 && s2.push(c2.numPoints ? K(c2) : this.points[c2.index]);
          }
          if (0 === s2.length)
            throw new Error(i2);
          return s2;
        }, U.prototype.getLeaves = function(e2, t2, r2) {
          t2 = t2 || 10, r2 = r2 || 0;
          var i2 = [];
          return this._appendLeaves(i2, e2, t2, r2, 0), i2;
        }, U.prototype.getTile = function(e2, t2, r2) {
          var i2 = this.trees[this._limitZoom(e2)], o2 = Math.pow(2, e2), n2 = this.options, a2 = n2.extent, s2 = n2.radius / a2, l2 = (r2 - s2) / o2, u2 = (r2 + 1 + s2) / o2, h2 = { features: [] };
          return this._addTileFeatures(i2.range((t2 - s2) / o2, l2, (t2 + 1 + s2) / o2, u2), i2.points, t2, r2, o2, h2), 0 === t2 && this._addTileFeatures(i2.range(1 - s2 / o2, l2, 1, u2), i2.points, o2, r2, o2, h2), t2 === o2 - 1 && this._addTileFeatures(i2.range(0, l2, s2 / o2, u2), i2.points, -1, r2, o2, h2), h2.features.length ? h2 : null;
        }, U.prototype.getClusterExpansionZoom = function(e2) {
          for (var t2 = this._getOriginZoom(e2) - 1; t2 <= this.options.maxZoom; ) {
            var r2 = this.getChildren(e2);
            if (t2++, 1 !== r2.length)
              break;
            e2 = r2[0].properties.cluster_id;
          }
          return t2;
        }, U.prototype._appendLeaves = function(e2, t2, r2, i2, o2) {
          for (var n2 = 0, a2 = this.getChildren(t2); n2 < a2.length; n2 += 1) {
            var s2 = a2[n2], l2 = s2.properties;
            if (l2 && l2.cluster ? o2 + l2.point_count <= i2 ? o2 += l2.point_count : o2 = this._appendLeaves(e2, l2.cluster_id, r2, i2, o2) : o2 < i2 ? o2++ : e2.push(s2), e2.length === r2)
              break;
          }
          return o2;
        }, U.prototype._addTileFeatures = function(e2, t2, r2, i2, o2, n2) {
          for (var a2 = 0, s2 = e2; a2 < s2.length; a2 += 1) {
            var l2 = t2[s2[a2]], u2 = l2.numPoints, h2 = void 0, c2 = void 0, p2 = void 0;
            if (u2)
              h2 = Q(l2), c2 = l2.x, p2 = l2.y;
            else {
              var f2 = this.points[l2.index];
              h2 = f2.properties, c2 = ee(f2.geometry.coordinates[0]), p2 = te(f2.geometry.coordinates[1]);
            }
            var d2 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * o2 - r2)), Math.round(this.options.extent * (p2 * o2 - i2))]], tags: h2 }, g2 = void 0;
            u2 ? g2 = l2.id : this.options.generateId ? g2 = l2.index : this.points[l2.index].id && (g2 = this.points[l2.index].id), void 0 !== g2 && (d2.id = g2), n2.features.push(d2);
          }
        }, U.prototype._limitZoom = function(e2) {
          return Math.max(this.options.minZoom, Math.min(+e2, this.options.maxZoom + 1));
        }, U.prototype._cluster = function(e2, t2) {
          for (var r2 = [], i2 = this.options, o2 = i2.radius, n2 = i2.extent, a2 = i2.reduce, s2 = i2.minPoints, l2 = o2 / (n2 * Math.pow(2, t2)), u2 = 0; u2 < e2.length; u2++) {
            var h2 = e2[u2];
            if (!(h2.zoom <= t2)) {
              h2.zoom = t2;
              for (var c2 = this.trees[t2 + 1], p2 = c2.within(h2.x, h2.y, l2), f2 = h2.numPoints || 1, d2 = f2, g2 = 0, m2 = p2; g2 < m2.length; g2 += 1) {
                var v2 = m2[g2], y2 = c2.points[v2];
                y2.zoom > t2 && (d2 += y2.numPoints || 1);
              }
              if (d2 >= s2) {
                for (var x2 = h2.x * f2, w2 = h2.y * f2, S2 = a2 && f2 > 1 ? this._map(h2, true) : null, M2 = (u2 << 5) + (t2 + 1) + this.points.length, I2 = 0, b2 = p2; I2 < b2.length; I2 += 1) {
                  var P2 = b2[I2], _2 = c2.points[P2];
                  if (!(_2.zoom <= t2)) {
                    _2.zoom = t2;
                    var k2 = _2.numPoints || 1;
                    x2 += _2.x * k2, w2 += _2.y * k2, _2.parentId = M2, a2 && (S2 || (S2 = this._map(h2, true)), a2(S2, this._map(_2)));
                  }
                }
                h2.parentId = M2, r2.push($(x2 / d2, w2 / d2, M2, d2, S2));
              } else if (r2.push(h2), d2 > 1)
                for (var T2 = 0, C2 = p2; T2 < C2.length; T2 += 1) {
                  var L2 = C2[T2], D2 = c2.points[L2];
                  D2.zoom <= t2 || (D2.zoom = t2, r2.push(D2));
                }
            }
          }
          return r2;
        }, U.prototype._getOriginId = function(e2) {
          return e2 - this.points.length >> 5;
        }, U.prototype._getOriginZoom = function(e2) {
          return (e2 - this.points.length) % 32;
        }, U.prototype._map = function(e2, t2) {
          if (e2.numPoints)
            return t2 ? re({}, e2.properties) : e2.properties;
          var r2 = this.points[e2.index].properties, i2 = this.options.map(r2);
          return t2 && i2 === r2 ? re({}, i2) : i2;
        }, Ce.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, Ce.prototype.splitTile = function(e2, t2, r2, i2, o2, n2, a2) {
          for (var s2 = [e2, t2, r2, i2], l2 = this.options, u2 = l2.debug; s2.length; ) {
            i2 = s2.pop(), r2 = s2.pop(), t2 = s2.pop(), e2 = s2.pop();
            var h2 = 1 << t2, c2 = Le(t2, r2, i2), p2 = this.tiles[c2];
            if (!p2 && (u2 > 1 && console.time("creation"), p2 = this.tiles[c2] = _e(e2, t2, r2, i2, l2), this.tileCoords.push({ z: t2, x: r2, y: i2 }), u2)) {
              u2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, r2, i2, p2.numFeatures, p2.numPoints, p2.numSimplified), console.timeEnd("creation"));
              var f2 = "z" + t2;
              this.stats[f2] = (this.stats[f2] || 0) + 1, this.total++;
            }
            if (p2.source = e2, o2) {
              if (t2 === l2.maxZoom || t2 === o2)
                continue;
              var d2 = 1 << o2 - t2;
              if (r2 !== Math.floor(n2 / d2) || i2 !== Math.floor(a2 / d2))
                continue;
            } else if (t2 === l2.indexMaxZoom || p2.numPoints <= l2.indexMaxPoints)
              continue;
            if (p2.source = null, 0 !== e2.length) {
              u2 > 1 && console.time("clipping");
              var g2, m2, v2, y2, x2, w2, S2 = 0.5 * l2.buffer / l2.extent, M2 = 0.5 - S2, I2 = 0.5 + S2, b2 = 1 + S2;
              g2 = m2 = v2 = y2 = null, x2 = de(e2, h2, r2 - S2, r2 + I2, 0, p2.minX, p2.maxX, l2), w2 = de(e2, h2, r2 + M2, r2 + b2, 0, p2.minX, p2.maxX, l2), e2 = null, x2 && (g2 = de(x2, h2, i2 - S2, i2 + I2, 1, p2.minY, p2.maxY, l2), m2 = de(x2, h2, i2 + M2, i2 + b2, 1, p2.minY, p2.maxY, l2), x2 = null), w2 && (v2 = de(w2, h2, i2 - S2, i2 + I2, 1, p2.minY, p2.maxY, l2), y2 = de(w2, h2, i2 + M2, i2 + b2, 1, p2.minY, p2.maxY, l2), w2 = null), u2 > 1 && console.timeEnd("clipping"), s2.push(g2 || [], t2 + 1, 2 * r2, 2 * i2), s2.push(m2 || [], t2 + 1, 2 * r2, 2 * i2 + 1), s2.push(v2 || [], t2 + 1, 2 * r2 + 1, 2 * i2), s2.push(y2 || [], t2 + 1, 2 * r2 + 1, 2 * i2 + 1);
            }
          }
        }, Ce.prototype.getTile = function(e2, t2, r2) {
          var i2 = this.options, o2 = i2.extent, n2 = i2.debug;
          if (e2 < 0 || e2 > 24)
            return null;
          var a2 = 1 << e2, s2 = Le(e2, t2 = (t2 % a2 + a2) % a2, r2);
          if (this.tiles[s2])
            return be(this.tiles[s2], o2);
          n2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, r2);
          for (var l2, u2 = e2, h2 = t2, c2 = r2; !l2 && u2 > 0; )
            u2--, h2 = Math.floor(h2 / 2), c2 = Math.floor(c2 / 2), l2 = this.tiles[Le(u2, h2, c2)];
          return l2 && l2.source ? (n2 > 1 && console.log("found parent tile z%d-%d-%d", u2, h2, c2), n2 > 1 && console.time("drilling down"), this.splitTile(l2.source, u2, h2, c2, e2, t2, r2), n2 > 1 && console.timeEnd("drilling down"), this.tiles[s2] ? be(this.tiles[s2], o2) : null) : null;
        };
        var ze = function(t2) {
          function r2(e2, r3, i2, o2) {
            t2.call(this, e2, r3, i2, De), o2 && (this.loadGeoJSON = o2);
          }
          return t2 && (r2.__proto__ = t2), r2.prototype = Object.create(t2 && t2.prototype), r2.prototype.constructor = r2, r2.prototype.loadData = function(e2, t3) {
            this._pendingCallback && this._pendingCallback(null, { abandoned: true }), this._pendingCallback = t3, this._pendingLoadDataParams = e2, this._state && "Idle" !== this._state ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData());
          }, r2.prototype._loadData = function() {
            var t3 = this;
            if (this._pendingCallback && this._pendingLoadDataParams) {
              var r3 = this._pendingCallback, i2 = this._pendingLoadDataParams;
              delete this._pendingCallback, delete this._pendingLoadDataParams;
              var o2 = !!(i2 && i2.request && i2.request.collectResourceTiming) && new e.RequestPerformance(i2.request);
              this.loadGeoJSON(i2, function(n2, a2) {
                if (n2 || !a2)
                  return r3(n2);
                if ("object" != typeof a2)
                  return r3(new Error("Input data given to '" + i2.source + "' is not a valid GeoJSON object."));
                m(a2, true);
                try {
                  t3._geoJSONIndex = i2.cluster ? new U(function(t4) {
                    var r4 = t4.superclusterOptions, i3 = t4.clusterProperties;
                    if (!i3 || !r4)
                      return r4;
                    for (var o3 = {}, n3 = {}, a3 = { accumulated: null, zoom: 0 }, s3 = { properties: null }, l3 = Object.keys(i3), u2 = 0, h2 = l3; u2 < h2.length; u2 += 1) {
                      var c2 = h2[u2], p2 = i3[c2], f2 = p2[0], d2 = p2[1], g2 = e.createExpression(d2), m2 = e.createExpression("string" == typeof f2 ? [f2, ["accumulated"], ["get", c2]] : f2);
                      o3[c2] = g2.value, n3[c2] = m2.value;
                    }
                    return r4.map = function(e2) {
                      s3.properties = e2;
                      for (var t5 = {}, r5 = 0, i4 = l3; r5 < i4.length; r5 += 1) {
                        var n4 = i4[r5];
                        t5[n4] = o3[n4].evaluate(a3, s3);
                      }
                      return t5;
                    }, r4.reduce = function(e2, t5) {
                      s3.properties = t5;
                      for (var r5 = 0, i4 = l3; r5 < i4.length; r5 += 1) {
                        var o4 = i4[r5];
                        a3.accumulated = e2[o4], e2[o4] = n3[o4].evaluate(a3, s3);
                      }
                    }, r4;
                  }(i2)).load(a2.features) : function(e2, t4) {
                    return new Ce(e2, t4);
                  }(a2, i2.geojsonVtOptions);
                } catch (n3) {
                  return r3(n3);
                }
                t3.loaded = {};
                var s2 = {};
                if (o2) {
                  var l2 = o2.finish();
                  l2 && (s2.resourceTiming = {}, s2.resourceTiming[i2.source] = JSON.parse(JSON.stringify(l2)));
                }
                r3(null, s2);
              });
            }
          }, r2.prototype.coalesce = function() {
            "Coalescing" === this._state ? this._state = "Idle" : "NeedsLoadData" === this._state && (this._state = "Coalescing", this._loadData());
          }, r2.prototype.reloadTile = function(e2, r3) {
            var i2 = this.loaded, o2 = e2.uid;
            return i2 && i2[o2] ? t2.prototype.reloadTile.call(this, e2, r3) : this.loadTile(e2, r3);
          }, r2.prototype.loadGeoJSON = function(t3, r3) {
            if (t3.request)
              e.getJSON(t3.request, r3);
            else {
              if ("string" != typeof t3.data)
                return r3(new Error("Input data given to '" + t3.source + "' is not a valid GeoJSON object."));
              try {
                return r3(null, JSON.parse(t3.data));
              } catch (e2) {
                return r3(new Error("Input data given to '" + t3.source + "' is not a valid GeoJSON object."));
              }
            }
          }, r2.prototype.removeSource = function(e2, t3) {
            this._pendingCallback && this._pendingCallback(null, { abandoned: true }), t3();
          }, r2.prototype.getClusterExpansionZoom = function(e2, t3) {
            t3(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
          }, r2.prototype.getClusterChildren = function(e2, t3) {
            t3(null, this._geoJSONIndex.getChildren(e2.clusterId));
          }, r2.prototype.getClusterLeaves = function(e2, t3) {
            t3(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
          }, r2;
        }(l);
        var Oe = function(t2) {
          var r2 = this;
          this.self = t2, this.actor = new e.Actor(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: l, geojson: ze }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function(e2, t3) {
            if (r2.workerSourceTypes[e2])
              throw new Error('Worker source with name "' + e2 + '" already registered.');
            r2.workerSourceTypes[e2] = t3;
          }, this.self.registerRTLTextPlugin = function(t3) {
            if (e.plugin.isParsed())
              throw new Error("RTL text plugin already registered.");
            e.plugin.applyArabicShaping = t3.applyArabicShaping, e.plugin.processBidirectionalText = t3.processBidirectionalText, e.plugin.processStyledBidirectionalText = t3.processStyledBidirectionalText;
          };
        };
        return Oe.prototype.setReferrer = function(e2, t2) {
          this.referrer = t2;
        }, Oe.prototype.setImages = function(e2, t2, r2) {
          this.availableImages[e2] = t2, r2();
        }, Oe.prototype.setLayers = function(e2, t2, r2) {
          this.getLayerIndex(e2).replace(t2), r2();
        }, Oe.prototype.updateLayers = function(e2, t2, r2) {
          this.getLayerIndex(e2).update(t2.layers, t2.removedIds), r2();
        }, Oe.prototype.loadTile = function(e2, t2, r2) {
          this.getWorkerSource(e2, t2.type, t2.source).loadTile(t2, r2);
        }, Oe.prototype.loadDEMTile = function(e2, t2, r2) {
          this.getDEMWorkerSource(e2, t2.source).loadTile(t2, r2);
        }, Oe.prototype.reloadTile = function(e2, t2, r2) {
          this.getWorkerSource(e2, t2.type, t2.source).reloadTile(t2, r2);
        }, Oe.prototype.abortTile = function(e2, t2, r2) {
          this.getWorkerSource(e2, t2.type, t2.source).abortTile(t2, r2);
        }, Oe.prototype.removeTile = function(e2, t2, r2) {
          this.getWorkerSource(e2, t2.type, t2.source).removeTile(t2, r2);
        }, Oe.prototype.removeDEMTile = function(e2, t2) {
          this.getDEMWorkerSource(e2, t2.source).removeTile(t2);
        }, Oe.prototype.removeSource = function(e2, t2, r2) {
          if (this.workerSources[e2] && this.workerSources[e2][t2.type] && this.workerSources[e2][t2.type][t2.source]) {
            var i2 = this.workerSources[e2][t2.type][t2.source];
            delete this.workerSources[e2][t2.type][t2.source], void 0 !== i2.removeSource ? i2.removeSource(t2, r2) : r2();
          }
        }, Oe.prototype.loadWorkerSource = function(e2, t2, r2) {
          try {
            this.self.importScripts(t2.url), r2();
          } catch (e3) {
            r2(e3.toString());
          }
        }, Oe.prototype.syncRTLPluginState = function(t2, r2, i2) {
          try {
            e.plugin.setState(r2);
            var o2 = e.plugin.getPluginURL();
            if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != o2) {
              this.self.importScripts(o2);
              var n2 = e.plugin.isParsed();
              i2(n2 ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + o2), n2);
            }
          } catch (e2) {
            i2(e2.toString());
          }
        }, Oe.prototype.getAvailableImages = function(e2) {
          var t2 = this.availableImages[e2];
          return t2 || (t2 = []), t2;
        }, Oe.prototype.getLayerIndex = function(e2) {
          var t2 = this.layerIndexes[e2];
          return t2 || (t2 = this.layerIndexes[e2] = new i()), t2;
        }, Oe.prototype.getWorkerSource = function(e2, t2, r2) {
          var i2 = this;
          if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][r2]) {
            var o2 = { send: function(t3, r3, o3) {
              i2.actor.send(t3, r3, o3, e2);
            } };
            this.workerSources[e2][t2][r2] = new this.workerSourceTypes[t2](o2, this.getLayerIndex(e2), this.getAvailableImages(e2));
          }
          return this.workerSources[e2][t2][r2];
        }, Oe.prototype.getDEMWorkerSource = function(e2, t2) {
          return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new h()), this.demWorkerSources[e2][t2];
        }, Oe.prototype.enforceCacheSizeLimit = function(t2, r2) {
          e.enforceCacheSizeLimit(r2);
        }, "undefined" != typeof WorkerGlobalScope && void 0 !== e.window && e.window instanceof WorkerGlobalScope && (e.window.worker = new Oe(e.window)), Oe;
      });
      define2(["./shared"], function(t) {
        "use strict";
        var e = t.createCommonjsModule(function(t2) {
          function e2(t3) {
            return !i2(t3);
          }
          function i2(t3) {
            return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
              if (!("Worker" in window && "Blob" in window && "URL" in window))
                return false;
              var t4, e3, i3 = new Blob([""], { type: "text/javascript" }), o3 = URL.createObjectURL(i3);
              try {
                e3 = new Worker(o3), t4 = true;
              } catch (e4) {
                t4 = false;
              }
              e3 && e3.terminate();
              return URL.revokeObjectURL(o3), t4;
            }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
              var t4 = document.createElement("canvas");
              t4.width = t4.height = 1;
              var e3 = t4.getContext("2d");
              if (!e3)
                return false;
              var i3 = e3.getImageData(0, 0, 1, 1);
              return i3 && i3.width === t4.width;
            }() ? function(t4) {
              void 0 === o2[t4] && (o2[t4] = function(t5) {
                var i3 = function(t6) {
                  var i4 = document.createElement("canvas"), o4 = Object.create(e2.webGLContextAttributes);
                  return o4.failIfMajorPerformanceCaveat = t6, i4.probablySupportsContext ? i4.probablySupportsContext("webgl", o4) || i4.probablySupportsContext("experimental-webgl", o4) : i4.supportsContext ? i4.supportsContext("webgl", o4) || i4.supportsContext("experimental-webgl", o4) : i4.getContext("webgl", o4) || i4.getContext("experimental-webgl", o4);
                }(t5);
                if (!i3)
                  return false;
                var o3 = i3.createShader(i3.VERTEX_SHADER);
                if (!o3 || i3.isContextLost())
                  return false;
                return i3.shaderSource(o3, "void main() {}"), i3.compileShader(o3), true === i3.getShaderParameter(o3, i3.COMPILE_STATUS);
              }(t4));
              return o2[t4];
            }(t3 && t3.failIfMajorPerformanceCaveat) ? void 0 : "insufficient WebGL support" : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
          }
          t2.exports ? t2.exports = e2 : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = e2, window.mapboxgl.notSupportedReason = i2);
          var o2 = {};
          e2.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
        }), i = { create: function(e2, i2, o2) {
          var r2 = t.window.document.createElement(e2);
          return void 0 !== i2 && (r2.className = i2), o2 && o2.appendChild(r2), r2;
        }, createNS: function(e2, i2) {
          return t.window.document.createElementNS(e2, i2);
        } }, o = t.window.document.documentElement.style;
        function r(t2) {
          if (!o)
            return t2[0];
          for (var e2 = 0; e2 < t2.length; e2++)
            if (t2[e2] in o)
              return t2[e2];
          return t2[0];
        }
        var a, n = r(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]);
        i.disableDrag = function() {
          o && n && (a = o[n], o[n] = "none");
        }, i.enableDrag = function() {
          o && n && (o[n] = a);
        };
        var s = r(["transform", "WebkitTransform"]);
        i.setTransform = function(t2, e2) {
          t2.style[s] = e2;
        };
        var l = false;
        try {
          var c = Object.defineProperty({}, "passive", { get: function() {
            l = true;
          } });
          t.window.addEventListener("test", c, c), t.window.removeEventListener("test", c, c);
        } catch (t2) {
          l = false;
        }
        i.addEventListener = function(t2, e2, i2, o2) {
          void 0 === o2 && (o2 = {}), "passive" in o2 && l ? t2.addEventListener(e2, i2, o2) : t2.addEventListener(e2, i2, o2.capture);
        }, i.removeEventListener = function(t2, e2, i2, o2) {
          void 0 === o2 && (o2 = {}), "passive" in o2 && l ? t2.removeEventListener(e2, i2, o2) : t2.removeEventListener(e2, i2, o2.capture);
        };
        var u = function(e2) {
          e2.preventDefault(), e2.stopPropagation(), t.window.removeEventListener("click", u, true);
        };
        function h(t2) {
          var e2 = t2.userImage;
          if (e2 && e2.render && e2.render())
            return t2.data.replace(new Uint8Array(e2.data.buffer)), true;
          return false;
        }
        i.suppressClick = function() {
          t.window.addEventListener("click", u, true), t.window.setTimeout(function() {
            t.window.removeEventListener("click", u, true);
          }, 0);
        }, i.mousePos = function(e2, i2) {
          var o2 = e2.getBoundingClientRect(), r2 = t.window.TouchEvent && i2 instanceof t.window.TouchEvent ? i2.touches[0] : i2;
          return new t.Point(r2.clientX - o2.left - e2.clientLeft, r2.clientY - o2.top - e2.clientTop);
        }, i.touchPos = function(e2, i2) {
          for (var o2 = e2.getBoundingClientRect(), r2 = [], a2 = "touchend" === i2.type ? i2.changedTouches : i2.touches, n2 = 0; n2 < a2.length; n2++)
            r2.push(new t.Point(a2[n2].clientX - o2.left - e2.clientLeft, a2[n2].clientY - o2.top - e2.clientTop));
          return r2;
        }, i.mouseButton = function(e2) {
          return void 0 !== t.window.InstallTrigger && 2 === e2.button && e2.ctrlKey && t.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e2.button;
        }, i.remove = function(t2) {
          t2.parentNode && t2.parentNode.removeChild(t2);
        };
        var p = function(e2) {
          function i2() {
            e2.call(this), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
          }
          return e2 && (i2.__proto__ = e2), i2.prototype = Object.create(e2 && e2.prototype), i2.prototype.constructor = i2, i2.prototype.isLoaded = function() {
            return this.loaded;
          }, i2.prototype.setLoaded = function(t2) {
            if (this.loaded !== t2 && (this.loaded = t2, t2)) {
              for (var e3 = 0, i3 = this.requestors; e3 < i3.length; e3 += 1) {
                var o2 = i3[e3], r2 = o2.ids, a2 = o2.callback;
                this._notify(r2, a2);
              }
              this.requestors = [];
            }
          }, i2.prototype.getImage = function(t2) {
            return this.images[t2];
          }, i2.prototype.addImage = function(t2, e3) {
            this._validate(t2, e3) && (this.images[t2] = e3);
          }, i2.prototype._validate = function(e3, i3) {
            var o2 = true;
            return this._validateStretch(i3.stretchX, i3.data && i3.data.width) || (this.fire(new t.ErrorEvent(new Error('Image "' + e3 + '" has invalid "stretchX" value'))), o2 = false), this._validateStretch(i3.stretchY, i3.data && i3.data.height) || (this.fire(new t.ErrorEvent(new Error('Image "' + e3 + '" has invalid "stretchY" value'))), o2 = false), this._validateContent(i3.content, i3) || (this.fire(new t.ErrorEvent(new Error('Image "' + e3 + '" has invalid "content" value'))), o2 = false), o2;
          }, i2.prototype._validateStretch = function(t2, e3) {
            if (!t2)
              return true;
            for (var i3 = 0, o2 = 0, r2 = t2; o2 < r2.length; o2 += 1) {
              var a2 = r2[o2];
              if (a2[0] < i3 || a2[1] < a2[0] || e3 < a2[1])
                return false;
              i3 = a2[1];
            }
            return true;
          }, i2.prototype._validateContent = function(t2, e3) {
            return !t2 || 4 === t2.length && (!(t2[0] < 0 || e3.data.width < t2[0]) && (!(t2[1] < 0 || e3.data.height < t2[1]) && (!(t2[2] < 0 || e3.data.width < t2[2]) && (!(t2[3] < 0 || e3.data.height < t2[3]) && (!(t2[2] < t2[0]) && !(t2[3] < t2[1]))))));
          }, i2.prototype.updateImage = function(t2, e3) {
            var i3 = this.images[t2];
            e3.version = i3.version + 1, this.images[t2] = e3, this.updatedImages[t2] = true;
          }, i2.prototype.removeImage = function(t2) {
            var e3 = this.images[t2];
            delete this.images[t2], delete this.patterns[t2], e3.userImage && e3.userImage.onRemove && e3.userImage.onRemove();
          }, i2.prototype.listImages = function() {
            return Object.keys(this.images);
          }, i2.prototype.getImages = function(t2, e3) {
            var i3 = true;
            if (!this.isLoaded())
              for (var o2 = 0, r2 = t2; o2 < r2.length; o2 += 1) {
                var a2 = r2[o2];
                this.images[a2] || (i3 = false);
              }
            this.isLoaded() || i3 ? this._notify(t2, e3) : this.requestors.push({ ids: t2, callback: e3 });
          }, i2.prototype._notify = function(e3, i3) {
            for (var o2 = {}, r2 = 0, a2 = e3; r2 < a2.length; r2 += 1) {
              var n2 = a2[r2];
              this.images[n2] || this.fire(new t.Event("styleimagemissing", { id: n2 }));
              var s2 = this.images[n2];
              s2 ? o2[n2] = { data: s2.data.clone(), pixelRatio: s2.pixelRatio, sdf: s2.sdf, version: s2.version, stretchX: s2.stretchX, stretchY: s2.stretchY, content: s2.content, hasRenderCallback: Boolean(s2.userImage && s2.userImage.render) } : t.warnOnce('Image "' + n2 + '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.');
            }
            i3(null, o2);
          }, i2.prototype.getPixelSize = function() {
            var t2 = this.atlasImage;
            return { width: t2.width, height: t2.height };
          }, i2.prototype.getPattern = function(e3) {
            var i3 = this.patterns[e3], o2 = this.getImage(e3);
            if (!o2)
              return null;
            if (i3 && i3.position.version === o2.version)
              return i3.position;
            if (i3)
              i3.position.version = o2.version;
            else {
              var r2 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, a2 = new t.ImagePosition(r2, o2);
              this.patterns[e3] = { bin: r2, position: a2 };
            }
            return this._updatePatternAtlas(), this.patterns[e3].position;
          }, i2.prototype.bind = function(e3) {
            var i3 = e3.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new t.Texture(e3, this.atlasImage, i3.RGBA), this.atlasTexture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE);
          }, i2.prototype._updatePatternAtlas = function() {
            var e3 = [];
            for (var i3 in this.patterns)
              e3.push(this.patterns[i3].bin);
            var o2 = t.potpack(e3), r2 = o2.w, a2 = o2.h, n2 = this.atlasImage;
            for (var s2 in n2.resize({ width: r2 || 1, height: a2 || 1 }), this.patterns) {
              var l2 = this.patterns[s2].bin, c2 = l2.x + 1, u2 = l2.y + 1, h2 = this.images[s2].data, p2 = h2.width, d2 = h2.height;
              t.RGBAImage.copy(h2, n2, { x: 0, y: 0 }, { x: c2, y: u2 }, { width: p2, height: d2 }), t.RGBAImage.copy(h2, n2, { x: 0, y: d2 - 1 }, { x: c2, y: u2 - 1 }, { width: p2, height: 1 }), t.RGBAImage.copy(h2, n2, { x: 0, y: 0 }, { x: c2, y: u2 + d2 }, { width: p2, height: 1 }), t.RGBAImage.copy(h2, n2, { x: p2 - 1, y: 0 }, { x: c2 - 1, y: u2 }, { width: 1, height: d2 }), t.RGBAImage.copy(h2, n2, { x: 0, y: 0 }, { x: c2 + p2, y: u2 }, { width: 1, height: d2 });
            }
            this.dirty = true;
          }, i2.prototype.beginFrame = function() {
            this.callbackDispatchedThisFrame = {};
          }, i2.prototype.dispatchRenderCallbacks = function(t2) {
            for (var e3 = 0, i3 = t2; e3 < i3.length; e3 += 1) {
              var o2 = i3[e3];
              if (!this.callbackDispatchedThisFrame[o2]) {
                this.callbackDispatchedThisFrame[o2] = true;
                var r2 = this.images[o2];
                h(r2) && this.updateImage(o2, r2);
              }
            }
          }, i2;
        }(t.Evented);
        var d = m, _ = m, f = 1e20;
        function m(t2, e2, i2, o2, r2, a2) {
          this.fontSize = t2 || 24, this.buffer = void 0 === e2 ? 3 : e2, this.cutoff = o2 || 0.25, this.fontFamily = r2 || "sans-serif", this.fontWeight = a2 || "normal", this.radius = i2 || 8;
          var n2 = this.size = this.fontSize + 2 * this.buffer, s2 = n2 + 2 * this.buffer;
          this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = n2, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textAlign = "left", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(s2 * s2), this.gridInner = new Float64Array(s2 * s2), this.f = new Float64Array(s2), this.z = new Float64Array(s2 + 1), this.v = new Uint16Array(s2), this.useMetrics = void 0 !== this.ctx.measureText("A").actualBoundingBoxLeft, this.middle = Math.round(n2 / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
        }
        function g(t2, e2, i2, o2, r2, a2) {
          for (var n2 = 0; n2 < e2; n2++)
            v(t2, n2, e2, i2, o2, r2, a2);
          for (var s2 = 0; s2 < i2; s2++)
            v(t2, s2 * e2, 1, e2, o2, r2, a2);
        }
        function v(t2, e2, i2, o2, r2, a2, n2) {
          var s2, l2, c2, u2;
          for (a2[0] = 0, n2[0] = -f, n2[1] = f, s2 = 0; s2 < o2; s2++)
            r2[s2] = t2[e2 + s2 * i2];
          for (s2 = 1, l2 = 0, c2 = 0; s2 < o2; s2++) {
            do {
              u2 = a2[l2], c2 = (r2[s2] - r2[u2] + s2 * s2 - u2 * u2) / (s2 - u2) / 2;
            } while (c2 <= n2[l2] && --l2 > -1);
            a2[++l2] = s2, n2[l2] = c2, n2[l2 + 1] = f;
          }
          for (s2 = 0, l2 = 0; s2 < o2; s2++) {
            for (; n2[l2 + 1] < s2; )
              l2++;
            u2 = a2[l2], t2[e2 + s2 * i2] = r2[u2] + (s2 - u2) * (s2 - u2);
          }
        }
        m.prototype._draw = function(t2, e2) {
          var i2, o2, r2, a2, n2, s2, l2, c2, u2, h2 = this.ctx.measureText(t2), p2 = h2.width, d2 = 2 * this.buffer;
          e2 && this.useMetrics ? (n2 = Math.floor(h2.actualBoundingBoxAscent), c2 = this.buffer + Math.ceil(h2.actualBoundingBoxAscent), s2 = this.buffer, l2 = this.buffer, i2 = (o2 = Math.min(this.size, Math.ceil(h2.actualBoundingBoxRight - h2.actualBoundingBoxLeft))) + d2, r2 = (a2 = Math.min(this.size - s2, Math.ceil(h2.actualBoundingBoxAscent + h2.actualBoundingBoxDescent))) + d2, this.ctx.textBaseline = "alphabetic") : (i2 = o2 = this.size, r2 = a2 = this.size, n2 = 19 * this.fontSize / 24, s2 = l2 = 0, c2 = this.middle, this.ctx.textBaseline = "middle"), o2 && a2 && (this.ctx.clearRect(l2, s2, o2, a2), this.ctx.fillText(t2, this.buffer, c2), u2 = this.ctx.getImageData(l2, s2, o2, a2));
          var _2 = new Uint8ClampedArray(i2 * r2);
          return function(t3, e3, i3, o3, r3, a3, n3) {
            a3.fill(f, 0, e3 * i3), n3.fill(0, 0, e3 * i3);
            for (var s3 = (e3 - o3) / 2, l3 = 0; l3 < r3; l3++)
              for (var c3 = 0; c3 < o3; c3++) {
                var u3 = (l3 + s3) * e3 + c3 + s3, h3 = t3.data[4 * (l3 * o3 + c3) + 3] / 255;
                if (1 === h3)
                  a3[u3] = 0, n3[u3] = f;
                else if (0 === h3)
                  a3[u3] = f, n3[u3] = 0;
                else {
                  var p3 = Math.max(0, 0.5 - h3), d3 = Math.max(0, h3 - 0.5);
                  a3[u3] = p3 * p3, n3[u3] = d3 * d3;
                }
              }
          }(u2, i2, r2, o2, a2, this.gridOuter, this.gridInner), g(this.gridOuter, i2, r2, this.f, this.v, this.z), g(this.gridInner, i2, r2, this.f, this.v, this.z), function(t3, e3, i3, o3, r3, a3, n3) {
            for (var s3 = 0; s3 < e3 * i3; s3++) {
              var l3 = Math.sqrt(o3[s3]) - Math.sqrt(r3[s3]);
              t3[s3] = Math.round(255 - 255 * (l3 / a3 + n3));
            }
          }(_2, i2, r2, this.gridOuter, this.gridInner, this.radius, this.cutoff), { data: _2, metrics: { width: o2, height: a2, sdfWidth: i2, sdfHeight: r2, top: n2, left: 0, advance: p2 } };
        }, m.prototype.draw = function(t2) {
          return this._draw(t2, false).data;
        }, m.prototype.drawWithMetrics = function(t2) {
          return this._draw(t2, true);
        }, d.default = _;
        var y = function(t2, e2) {
          this.requestManager = t2, this.localIdeographFontFamily = e2, this.entries = {};
        };
        y.prototype.setURL = function(t2) {
          this.url = t2;
        }, y.prototype.getGlyphs = function(e2, i2) {
          var o2 = this, r2 = [];
          for (var a2 in e2)
            for (var n2 = 0, s2 = e2[a2]; n2 < s2.length; n2 += 1) {
              var l2 = s2[n2];
              r2.push({ stack: a2, id: l2 });
            }
          t.asyncAll(r2, function(t2, e3) {
            var i3 = t2.stack, r3 = t2.id, a3 = o2.entries[i3];
            a3 || (a3 = o2.entries[i3] = { glyphs: {}, requests: {} });
            var n3 = a3.glyphs[r3];
            if (void 0 === n3) {
              if (n3 = o2._tinySDF(a3, i3, r3))
                return a3.glyphs[r3] = n3, void e3(null, { stack: i3, id: r3, glyph: n3 });
              var s3 = Math.floor(r3 / 256);
              if (256 * s3 > 65535)
                e3(new Error("glyphs > 65535 not supported"));
              else {
                var l3 = a3.requests[s3];
                l3 || (l3 = a3.requests[s3] = [], y.loadGlyphRange(i3, s3, o2.url, o2.requestManager, function(t3, e4) {
                  if (e4)
                    for (var i4 in e4)
                      o2._doesCharSupportLocalGlyph(+i4) || (a3.glyphs[+i4] = e4[+i4]);
                  for (var r4 = 0, n4 = l3; r4 < n4.length; r4 += 1) {
                    (0, n4[r4])(t3, e4);
                  }
                  delete a3.requests[s3];
                })), l3.push(function(t3, o3) {
                  t3 ? e3(t3) : o3 && e3(null, { stack: i3, id: r3, glyph: o3[r3] || null });
                });
              }
            } else
              e3(null, { stack: i3, id: r3, glyph: n3 });
          }, function(t2, e3) {
            if (t2)
              i2(t2);
            else if (e3) {
              for (var o3 = {}, r3 = 0, a3 = e3; r3 < a3.length; r3 += 1) {
                var n3 = a3[r3], s3 = n3.stack, l3 = n3.id, c2 = n3.glyph;
                (o3[s3] || (o3[s3] = {}))[l3] = c2 && { id: c2.id, bitmap: c2.bitmap.clone(), metrics: c2.metrics };
              }
              i2(null, o3);
            }
          });
        }, y.prototype._doesCharSupportLocalGlyph = function(e2) {
          return !!this.localIdeographFontFamily && (t.isChar["CJK Unified Ideographs"](e2) || t.isChar["Hangul Syllables"](e2) || t.isChar.Hiragana(e2) || t.isChar.Katakana(e2));
        }, y.prototype._tinySDF = function(e2, i2, o2) {
          var r2 = this.localIdeographFontFamily;
          if (r2 && this._doesCharSupportLocalGlyph(o2)) {
            var a2 = e2.tinySDF;
            if (!a2) {
              var n2 = "400";
              /bold/i.test(i2) ? n2 = "900" : /medium/i.test(i2) ? n2 = "500" : /light/i.test(i2) && (n2 = "200"), a2 = e2.tinySDF = new y.TinySDF(24, 3, 8, 0.25, r2, n2);
            }
            return { id: o2, bitmap: new t.AlphaImage({ width: 30, height: 30 }, a2.draw(String.fromCharCode(o2))), metrics: { width: 24, height: 24, left: 0, top: -8, advance: 24 } };
          }
        }, y.loadGlyphRange = function(e2, i2, o2, r2, a2) {
          var n2 = 256 * i2, s2 = n2 + 255, l2 = r2.transformRequest(r2.normalizeGlyphsURL(o2).replace("{fontstack}", e2).replace("{range}", n2 + "-" + s2), t.ResourceType.Glyphs);
          t.getArrayBuffer(l2, function(e3, i3) {
            if (e3)
              a2(e3);
            else if (i3) {
              for (var o3 = {}, r3 = 0, n3 = t.parseGlyphPBF(i3); r3 < n3.length; r3 += 1) {
                var s3 = n3[r3];
                o3[s3.id] = s3;
              }
              a2(null, o3);
            }
          });
        }, y.TinySDF = d;
        var x = function() {
          this.specification = t.styleSpec.light.position;
        };
        x.prototype.possiblyEvaluate = function(e2, i2) {
          return t.sphericalToCartesian(e2.expression.evaluate(i2));
        }, x.prototype.interpolate = function(e2, i2, o2) {
          return { x: t.number(e2.x, i2.x, o2), y: t.number(e2.y, i2.y, o2), z: t.number(e2.z, i2.z, o2) };
        };
        var b = new t.Properties({ anchor: new t.DataConstantProperty(t.styleSpec.light.anchor), position: new x(), color: new t.DataConstantProperty(t.styleSpec.light.color), intensity: new t.DataConstantProperty(t.styleSpec.light.intensity) }), w = function(e2) {
          function i2(i3) {
            e2.call(this), this._transitionable = new t.Transitionable(b), this.setLight(i3), this._transitioning = this._transitionable.untransitioned();
          }
          return e2 && (i2.__proto__ = e2), i2.prototype = Object.create(e2 && e2.prototype), i2.prototype.constructor = i2, i2.prototype.getLight = function() {
            return this._transitionable.serialize();
          }, i2.prototype.setLight = function(e3, i3) {
            if (void 0 === i3 && (i3 = {}), !this._validate(t.validateLight, e3, i3))
              for (var o2 in e3) {
                var r2 = e3[o2];
                t.endsWith(o2, "-transition") ? this._transitionable.setTransition(o2.slice(0, -"-transition".length), r2) : this._transitionable.setValue(o2, r2);
              }
          }, i2.prototype.updateTransitions = function(t2) {
            this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
          }, i2.prototype.hasTransition = function() {
            return this._transitioning.hasTransition();
          }, i2.prototype.recalculate = function(t2) {
            this.properties = this._transitioning.possiblyEvaluate(t2);
          }, i2.prototype._validate = function(e3, i3, o2) {
            return (!o2 || false !== o2.validate) && t.emitValidationErrors(this, e3.call(t.validateStyle, t.extend({ value: i3, style: { glyphs: true, sprite: true }, styleSpec: t.styleSpec })));
          }, i2;
        }(t.Evented), E = function(t2, e2) {
          this.width = t2, this.height = e2, this.nextRow = 0, this.bytes = 4, this.data = new Uint8Array(this.width * this.height * this.bytes), this.positions = {};
        };
        E.prototype.getDash = function(t2, e2) {
          var i2 = t2.join(",") + String(e2);
          return this.positions[i2] || (this.positions[i2] = this.addDash(t2, e2)), this.positions[i2];
        }, E.prototype.addDash = function(e2, i2) {
          var o2 = i2 ? 7 : 0, r2 = 2 * o2 + 1;
          if (this.nextRow + r2 > this.height)
            return t.warnOnce("LineAtlas out of space"), null;
          for (var a2 = 0, n2 = 0; n2 < e2.length; n2++)
            a2 += e2[n2];
          for (var s2 = this.width / a2, l2 = s2 / 2, c2 = e2.length % 2 == 1, u2 = -o2; u2 <= o2; u2++)
            for (var h2 = this.nextRow + o2 + u2, p2 = this.width * h2, d2 = c2 ? -e2[e2.length - 1] : 0, _2 = e2[0], f2 = 1, m2 = 0; m2 < this.width; m2++) {
              for (; _2 < m2 / s2; )
                d2 = _2, _2 += e2[f2], c2 && f2 === e2.length - 1 && (_2 += e2[0]), f2++;
              var g2 = Math.abs(m2 - d2 * s2), v2 = Math.abs(m2 - _2 * s2), y2 = Math.min(g2, v2), x2 = f2 % 2 == 1, b2 = void 0;
              if (i2) {
                var w2 = o2 ? u2 / o2 * (l2 + 1) : 0;
                if (x2) {
                  var E2 = l2 - Math.abs(w2);
                  b2 = Math.sqrt(y2 * y2 + E2 * E2);
                } else
                  b2 = l2 - Math.sqrt(y2 * y2 + w2 * w2);
              } else
                b2 = (x2 ? 1 : -1) * y2;
              this.data[3 + 4 * (p2 + m2)] = Math.max(0, Math.min(255, b2 + 128));
            }
          var T2 = { y: (this.nextRow + o2 + 0.5) / this.height, height: 2 * o2 / this.height, width: a2 };
          return this.nextRow += r2, this.dirty = true, T2;
        }, E.prototype.bind = function(t2) {
          var e2 = t2.gl;
          this.texture ? (e2.bindTexture(e2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, this.width, this.height, e2.RGBA, e2.UNSIGNED_BYTE, this.data))) : (this.texture = e2.createTexture(), e2.bindTexture(e2.TEXTURE_2D, this.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.LINEAR), e2.texImage2D(e2.TEXTURE_2D, 0, e2.RGBA, this.width, this.height, 0, e2.RGBA, e2.UNSIGNED_BYTE, this.data));
        };
        var T = function e2(i2, o2) {
          this.workerPool = i2, this.actors = [], this.currentActor = 0, this.id = t.uniqueId();
          for (var r2 = this.workerPool.acquire(this.id), a2 = 0; a2 < r2.length; a2++) {
            var n2 = r2[a2], s2 = new e2.Actor(n2, o2, this.id);
            s2.name = "Worker " + a2, this.actors.push(s2);
          }
        };
        function I(e2, i2, o2) {
          var r2 = function(r3, a2) {
            if (r3)
              return o2(r3);
            if (a2) {
              var n2 = t.pick(t.extend(a2, e2), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
              a2.vector_layers && (n2.vectorLayers = a2.vector_layers, n2.vectorLayerIds = n2.vectorLayers.map(function(t2) {
                return t2.id;
              })), e2.url && (n2.tiles = i2.canonicalizeTileset(n2, e2.url)), o2(null, n2);
            }
          };
          return e2.url ? t.getJSON(i2.transformRequest(i2.normalizeSourceURL(e2.url), t.ResourceType.Source), r2) : t.browser.frame(function() {
            return r2(null, e2);
          });
        }
        T.prototype.broadcast = function(e2, i2, o2) {
          o2 = o2 || function() {
          }, t.asyncAll(this.actors, function(t2, o3) {
            t2.send(e2, i2, o3);
          }, o2);
        }, T.prototype.getActor = function() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }, T.prototype.remove = function() {
          this.actors.forEach(function(t2) {
            t2.remove();
          }), this.actors = [], this.workerPool.release(this.id);
        }, T.Actor = t.Actor;
        var S = function(e2, i2, o2) {
          this.bounds = t.LngLatBounds.convert(this.validateBounds(e2)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
        };
        S.prototype.validateBounds = function(t2) {
          return Array.isArray(t2) && 4 === t2.length ? [Math.max(-180, t2[0]), Math.max(-90, t2[1]), Math.min(180, t2[2]), Math.min(90, t2[3])] : [-180, -90, 180, 90];
        }, S.prototype.contains = function(e2) {
          var i2 = Math.pow(2, e2.z), o2 = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i2), r2 = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i2), a2 = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i2), n2 = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i2);
          return e2.x >= o2 && e2.x < a2 && e2.y >= r2 && e2.y < n2;
        };
        var C = function(e2) {
          function i2(i3, o2, r2, a2) {
            if (e2.call(this), this.id = i3, this.dispatcher = r2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t.extend(this, t.pick(o2, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.extend({ type: "vector" }, o2), this._collectResourceTiming = o2.collectResourceTiming, 512 !== this.tileSize)
              throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(a2);
          }
          return e2 && (i2.__proto__ = e2), i2.prototype = Object.create(e2 && e2.prototype), i2.prototype.constructor = i2, i2.prototype.load = function() {
            var e3 = this;
            this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = I(this._options, this.map._requestManager, function(i3, o2) {
              e3._tileJSONRequest = null, e3._loaded = true, i3 ? e3.fire(new t.ErrorEvent(i3)) : o2 && (t.extend(e3, o2), o2.bounds && (e3.tileBounds = new S(o2.bounds, e3.minzoom, e3.maxzoom)), t.postTurnstileEvent(o2.tiles, e3.map._requestManager._customAccessToken), t.postMapLoadEvent(o2.tiles, e3.map._getMapId(), e3.map._requestManager._skuToken, e3.map._requestManager._customAccessToken), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
            });
          }, i2.prototype.loaded = function() {
            return this._loaded;
          }, i2.prototype.hasTile = function(t2) {
            return !this.tileBounds || this.tileBounds.contains(t2.canonical);
          }, i2.prototype.onAdd = function(t2) {
            this.map = t2, this.load();
          }, i2.prototype.onRemove = function() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }, i2.prototype.serialize = function() {
            return t.extend({}, this._options);
          }, i2.prototype.loadTile = function(e3, i3) {
            var o2 = this.map._requestManager.normalizeTileURL(e3.tileID.canonical.url(this.tiles, this.scheme), this.url, null), r2 = { request: this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), uid: e3.uid, tileID: e3.tileID, zoom: e3.tileID.overscaledZ, tileSize: this.tileSize * e3.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: t.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            function a2(o3, r3) {
              return delete e3.request, e3.aborted ? i3(null) : o3 && 404 !== o3.status ? i3(o3) : (r3 && r3.resourceTiming && (e3.resourceTiming = r3.resourceTiming), this.map._refreshExpiredTiles && r3 && e3.setExpiryData(r3), e3.loadVectorData(r3, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), i3(null), void (e3.reloadCallback && (this.loadTile(e3, e3.reloadCallback), e3.reloadCallback = null)));
            }
            r2.request.collectResourceTiming = this._collectResourceTiming, e3.actor && "expired" !== e3.state ? "loading" === e3.state ? e3.reloadCallback = i3 : e3.request = e3.actor.send("reloadTile", r2, a2.bind(this)) : (e3.actor = this.dispatcher.getActor(), e3.request = e3.actor.send("loadTile", r2, a2.bind(this)));
          }, i2.prototype.abortTile = function(t2) {
            t2.request && (t2.request.cancel(), delete t2.request), t2.actor && t2.actor.send("abortTile", { uid: t2.uid, type: this.type, source: this.id }, void 0);
          }, i2.prototype.unloadTile = function(t2) {
            t2.unloadVectorData(), t2.actor && t2.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id }, void 0);
          }, i2.prototype.hasTransition = function() {
            return false;
          }, i2;
        }(t.Evented), P = function(e2) {
          function i2(i3, o2, r2, a2) {
            e2.call(this), this.id = i3, this.dispatcher = r2, this.setEventedParent(a2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t.extend({ type: "raster" }, o2), t.extend(this, t.pick(o2, ["url", "scheme", "tileSize"]));
          }
          return e2 && (i2.__proto__ = e2), i2.prototype = Object.create(e2 && e2.prototype), i2.prototype.constructor = i2, i2.prototype.load = function() {
            var e3 = this;
            this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = I(this._options, this.map._requestManager, function(i3, o2) {
              e3._tileJSONRequest = null, e3._loaded = true, i3 ? e3.fire(new t.ErrorEvent(i3)) : o2 && (t.extend(e3, o2), o2.bounds && (e3.tileBounds = new S(o2.bounds, e3.minzoom, e3.maxzoom)), t.postTurnstileEvent(o2.tiles), t.postMapLoadEvent(o2.tiles, e3.map._getMapId(), e3.map._requestManager._skuToken), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
            });
          }, i2.prototype.loaded = function() {
            return this._loaded;
          }, i2.prototype.onAdd = function(t2) {
            this.map = t2, this.load();
          }, i2.prototype.onRemove = function() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }, i2.prototype.serialize = function() {
            return t.extend({}, this._options);
          }, i2.prototype.hasTile = function(t2) {
            return !this.tileBounds || this.tileBounds.contains(t2.canonical);
          }, i2.prototype.loadTile = function(e3, i3) {
            var o2 = this, r2 = this.map._requestManager.normalizeTileURL(e3.tileID.canonical.url(this.tiles, this.scheme), this.url, this.tileSize);
            e3.request = t.getImage(this.map._requestManager.transformRequest(r2, t.ResourceType.Tile), function(r3, a2) {
              if (delete e3.request, e3.aborted)
                e3.state = "unloaded", i3(null);
              else if (r3)
                e3.state = "errored", i3(r3);
              else if (a2) {
                o2.map._refreshExpiredTiles && e3.setExpiryData(a2), delete a2.cacheControl, delete a2.expires;
                var n2 = o2.map.painter.context, s2 = n2.gl;
                e3.texture = o2.map.painter.getTileTexture(a2.width), e3.texture ? e3.texture.update(a2, { useMipmap: true }) : (e3.texture = new t.Texture(n2, a2, s2.RGBA, { useMipmap: true }), e3.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST), n2.extTextureFilterAnisotropic && s2.texParameterf(s2.TEXTURE_2D, n2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, n2.extTextureFilterAnisotropicMax)), e3.state = "loaded", t.cacheEntryPossiblyAdded(o2.dispatcher), i3(null);
              }
            });
          }, i2.prototype.abortTile = function(t2, e3) {
            t2.request && (t2.request.cancel(), delete t2.request), e3();
          }, i2.prototype.unloadTile = function(t2, e3) {
            t2.texture && this.map.painter.saveTileTexture(t2.texture), e3();
          }, i2.prototype.hasTransition = function() {
            return false;
          }, i2;
        }(t.Evented), z = function(e2) {
          function i2(i3, o2, r2, a2) {
            e2.call(this, i3, o2, r2, a2), this.type = "raster-dem", this.maxzoom = 22, this._options = t.extend({ type: "raster-dem" }, o2), this.encoding = o2.encoding || "mapbox";
          }
          return e2 && (i2.__proto__ = e2), i2.prototype = Object.create(e2 && e2.prototype), i2.prototype.constructor = i2, i2.prototype.serialize = function() {
            return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
          }, i2.prototype.loadTile = function(e3, i3) {
            var o2 = this.map._requestManager.normalizeTileURL(e3.tileID.canonical.url(this.tiles, this.scheme), this.url, this.tileSize);
            function r2(t2, o3) {
              t2 && (e3.state = "errored", i3(t2)), o3 && (e3.dem = o3, e3.needsHillshadePrepare = true, e3.state = "loaded", i3(null));
            }
            e3.request = t.getImage(this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), (function(o3, a2) {
              if (delete e3.request, e3.aborted)
                e3.state = "unloaded", i3(null);
              else if (o3)
                e3.state = "errored", i3(o3);
              else if (a2) {
                this.map._refreshExpiredTiles && e3.setExpiryData(a2), delete a2.cacheControl, delete a2.expires;
                var n2 = t.window.ImageBitmap && a2 instanceof t.window.ImageBitmap && t.offscreenCanvasSupported() ? a2 : t.browser.getImageData(a2, 1), s2 = { uid: e3.uid, coord: e3.tileID, source: this.id, rawImageData: n2, encoding: this.encoding };
                e3.actor && "expired" !== e3.state || (e3.actor = this.dispatcher.getActor(), e3.actor.send("loadDEMTile", s2, r2.bind(this)));
              }
            }).bind(this)), e3.neighboringTiles = this._getNeighboringTiles(e3.tileID);
          }, i2.prototype._getNeighboringTiles = function(e3) {
            var i3 = e3.canonical, o2 = Math.pow(2, i3.z), r2 = (i3.x - 1 + o2) % o2, a2 = 0 === i3.x ? e3.wrap - 1 : e3.wrap, n2 = (i3.x + 1 + o2) % o2, s2 = i3.x + 1 === o2 ? e3.wrap + 1 : e3.wrap, l2 = {};
            return l2[new t.OverscaledTileID(e3.overscaledZ, a2, i3.z, r2, i3.y).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, s2, i3.z, n2, i3.y).key] = { backfilled: false }, i3.y > 0 && (l2[new t.OverscaledTileID(e3.overscaledZ, a2, i3.z, r2, i3.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, e3.wrap, i3.z, i3.x, i3.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, s2, i3.z, n2, i3.y - 1).key] = { backfilled: false }), i3.y + 1 < o2 && (l2[new t.OverscaledTileID(e3.overscaledZ, a2, i3.z, r2, i3.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, e3.wrap, i3.z, i3.x, i3.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, s2, i3.z, n2, i3.y + 1).key] = { backfilled: false }), l2;
          }, i2.prototype.unloadTile = function(t2) {
            t2.demTexture && this.map.painter.saveTileTexture(t2.demTexture), t2.fbo && (t2.fbo.destroy(), delete t2.fbo), t2.dem && delete t2.dem, delete t2.neighboringTiles, t2.state = "unloaded", t2.actor && t2.actor.send("removeDEMTile", { uid: t2.uid, source: this.id });
          }, i2;
        }(P), M = function(e2) {
          function i2(i3, o2, r2, a2) {
            e2.call(this), this.id = i3, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._loaded = false, this.actor = r2.getActor(), this.setEventedParent(a2), this._data = o2.data, this._options = t.extend({}, o2), this._collectResourceTiming = o2.collectResourceTiming, this._resourceTiming = [], void 0 !== o2.maxzoom && (this.maxzoom = o2.maxzoom), o2.type && (this.type = o2.type), o2.attribution && (this.attribution = o2.attribution), this.promoteId = o2.promoteId;
            var n2 = t.EXTENT / this.tileSize;
            this.workerOptions = t.extend({ source: this.id, cluster: o2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== o2.buffer ? o2.buffer : 128) * n2, tolerance: (void 0 !== o2.tolerance ? o2.tolerance : 0.375) * n2, extent: t.EXTENT, maxZoom: this.maxzoom, lineMetrics: o2.lineMetrics || false, generateId: o2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== o2.clusterMaxZoom ? Math.min(o2.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1, extent: t.EXTENT, radius: (o2.clusterRadius || 50) * n2, log: false, generateId: o2.generateId || false }, clusterProperties: o2.clusterProperties }, o2.workerOptions);
          }
          return e2 && (i2.__proto__ = e2), i2.prototype = Object.create(e2 && e2.prototype), i2.prototype.constructor = i2, i2.prototype.load = function() {
            var e3 = this;
            this.fire(new t.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(i3) {
              if (i3)
                e3.fire(new t.ErrorEvent(i3));
              else {
                var o2 = { dataType: "source", sourceDataType: "metadata" };
                e3._collectResourceTiming && e3._resourceTiming && e3._resourceTiming.length > 0 && (o2.resourceTiming = e3._resourceTiming, e3._resourceTiming = []), e3.fire(new t.Event("data", o2));
              }
            });
          }, i2.prototype.onAdd = function(t2) {
            this.map = t2, this.load();
          }, i2.prototype.setData = function(e3) {
            var i3 = this;
            return this._data = e3, this.fire(new t.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(e4) {
              if (e4)
                i3.fire(new t.ErrorEvent(e4));
              else {
                var o2 = { dataType: "source", sourceDataType: "content" };
                i3._collectResourceTiming && i3._resourceTiming && i3._resourceTiming.length > 0 && (o2.resourceTiming = i3._resourceTiming, i3._resourceTiming = []), i3.fire(new t.Event("data", o2));
              }
            }), this;
          }, i2.prototype.getClusterExpansionZoom = function(t2, e3) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t2, source: this.id }, e3), this;
          }, i2.prototype.getClusterChildren = function(t2, e3) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: t2, source: this.id }, e3), this;
          }, i2.prototype.getClusterLeaves = function(t2, e3, i3, o2) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t2, limit: e3, offset: i3 }, o2), this;
          }, i2.prototype._updateWorkerData = function(e3) {
            var i3 = this;
            this._loaded = false;
            var o2 = t.extend({}, this.workerOptions), r2 = this._data;
            "string" == typeof r2 ? (o2.request = this.map._requestManager.transformRequest(t.browser.resolveURL(r2), t.ResourceType.Source), o2.request.collectResourceTiming = this._collectResourceTiming) : o2.data = JSON.stringify(r2), this.actor.send(this.type + ".loadData", o2, function(t2, r3) {
              i3._removed || r3 && r3.abandoned || (i3._loaded = true, r3 && r3.resourceTiming && r3.resourceTiming[i3.id] && (i3._resourceTiming = r3.resourceTiming[i3.id].slice(0)), i3.actor.send(i3.type + ".coalesce", { source: o2.source }, null), e3(t2));
            });
          }, i2.prototype.loaded = function() {
            return this._loaded;
          }, i2.prototype.loadTile = function(e3, i3) {
            var o2 = this, r2 = e3.actor ? "reloadTile" : "loadTile";
            e3.actor = this.actor;
            var a2 = { type: this.type, uid: e3.uid, tileID: e3.tileID, zoom: e3.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: t.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            e3.request = this.actor.send(r2, a2, function(t2, a3) {
              return delete e3.request, e3.unloadVectorData(), e3.aborted ? i3(null) : t2 ? i3(t2) : (e3.loadVectorData(a3, o2.map.painter, "reloadTile" === r2), i3(null));
            });
          }, i2.prototype.abortTile = function(t2) {
            t2.request && (t2.request.cancel(), delete t2.request), t2.aborted = true;
          }, i2.prototype.unloadTile = function(t2) {
            t2.unloadVectorData(), this.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id });
          }, i2.prototype.onRemove = function() {
            this._removed = true, this.actor.send("removeSource", { type: this.type, source: this.id });
          }, i2.prototype.serialize = function() {
            return t.extend({}, this._options, { type: this.type, data: this._data });
          }, i2.prototype.hasTransition = function() {
            return false;
          }, i2;
        }(t.Evented), L = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]), D = function(e2) {
          function i2(t2, i3, o2, r2) {
            e2.call(this), this.id = t2, this.dispatcher = o2, this.coordinates = i3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(r2), this.options = i3;
          }
          return e2 && (i2.__proto__ = e2), i2.prototype = Object.create(e2 && e2.prototype), i2.prototype.constructor = i2, i2.prototype.load = function(e3, i3) {
            var o2 = this;
            this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), function(r2, a2) {
              o2._loaded = true, r2 ? o2.fire(new t.ErrorEvent(r2)) : a2 && (o2.image = a2, e3 && (o2.coordinates = e3), i3 && i3(), o2._finishLoading());
            });
          }, i2.prototype.loaded = function() {
            return this._loaded;
          }, i2.prototype.updateImage = function(t2) {
            var e3 = this;
            return this.image && t2.url ? (this.options.url = t2.url, this.load(t2.coordinates, function() {
              e3.texture = null;
            }), this) : this;
          }, i2.prototype._finishLoading = function() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })));
          }, i2.prototype.onAdd = function(t2) {
            this.map = t2, this.load();
          }, i2.prototype.setCoordinates = function(e3) {
            var i3 = this;
            this.coordinates = e3;
            var o2 = e3.map(t.MercatorCoordinate.fromLngLat);
            this.tileID = function(e4) {
              for (var i4 = 1 / 0, o3 = 1 / 0, r3 = -1 / 0, a2 = -1 / 0, n2 = 0, s2 = e4; n2 < s2.length; n2 += 1) {
                var l2 = s2[n2];
                i4 = Math.min(i4, l2.x), o3 = Math.min(o3, l2.y), r3 = Math.max(r3, l2.x), a2 = Math.max(a2, l2.y);
              }
              var c2 = r3 - i4, u2 = a2 - o3, h2 = Math.max(c2, u2), p2 = Math.max(0, Math.floor(-Math.log(h2) / Math.LN2)), d2 = Math.pow(2, p2);
              return new t.CanonicalTileID(p2, Math.floor((i4 + r3) / 2 * d2), Math.floor((o3 + a2) / 2 * d2));
            }(o2), this.minzoom = this.maxzoom = this.tileID.z;
            var r2 = o2.map(function(t2) {
              return i3.tileID.getTilePoint(t2)._round();
            });
            return this._boundsArray = new t.StructArrayLayout4i8(), this._boundsArray.emplaceBack(r2[0].x, r2[0].y, 0, 0), this._boundsArray.emplaceBack(r2[1].x, r2[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(r2[3].x, r2[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(r2[2].x, r2[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })), this;
          }, i2.prototype.prepare = function() {
            if (0 !== Object.keys(this.tiles).length && this.image) {
              var e3 = this.map.painter.context, i3 = e3.gl;
              for (var o2 in this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, L.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new t.Texture(e3, this.image, i3.RGBA), this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE)), this.tiles) {
                var r2 = this.tiles[o2];
                "loaded" !== r2.state && (r2.state = "loaded", r2.texture = this.texture);
              }
            }
          }, i2.prototype.loadTile = function(t2, e3) {
            this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}, e3(null)) : (t2.state = "errored", e3(null));
          }, i2.prototype.serialize = function() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }, i2.prototype.hasTransition = function() {
            return false;
          }, i2;
        }(t.Evented);
        var A = function(e2) {
          function i2(t2, i3, o2, r2) {
            e2.call(this, t2, i3, o2, r2), this.roundZoom = true, this.type = "video", this.options = i3;
          }
          return e2 && (i2.__proto__ = e2), i2.prototype = Object.create(e2 && e2.prototype), i2.prototype.constructor = i2, i2.prototype.load = function() {
            var e3 = this;
            this._loaded = false;
            var i3 = this.options;
            this.urls = [];
            for (var o2 = 0, r2 = i3.urls; o2 < r2.length; o2 += 1) {
              var a2 = r2[o2];
              this.urls.push(this.map._requestManager.transformRequest(a2, t.ResourceType.Source).url);
            }
            t.getVideo(this.urls, function(i4, o3) {
              e3._loaded = true, i4 ? e3.fire(new t.ErrorEvent(i4)) : o3 && (e3.video = o3, e3.video.loop = true, e3.video.addEventListener("playing", function() {
                e3.map.triggerRepaint();
              }), e3.map && e3.video.play(), e3._finishLoading());
            });
          }, i2.prototype.pause = function() {
            this.video && this.video.pause();
          }, i2.prototype.play = function() {
            this.video && this.video.play();
          }, i2.prototype.seek = function(e3) {
            if (this.video) {
              var i3 = this.video.seekable;
              e3 < i3.start(0) || e3 > i3.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError("sources." + this.id, null, "Playback for this video can be set only between the " + i3.start(0) + " and " + i3.end(0) + "-second mark."))) : this.video.currentTime = e3;
            }
          }, i2.prototype.getVideo = function() {
            return this.video;
          }, i2.prototype.onAdd = function(t2) {
            this.map || (this.map = t2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }, i2.prototype.prepare = function() {
            if (!(0 === Object.keys(this.tiles).length || this.video.readyState < 2)) {
              var e3 = this.map.painter.context, i3 = e3.gl;
              for (var o2 in this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, L.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE), i3.texSubImage2D(i3.TEXTURE_2D, 0, 0, 0, i3.RGBA, i3.UNSIGNED_BYTE, this.video)) : (this.texture = new t.Texture(e3, this.video, i3.RGBA), this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE)), this.tiles) {
                var r2 = this.tiles[o2];
                "loaded" !== r2.state && (r2.state = "loaded", r2.texture = this.texture);
              }
            }
          }, i2.prototype.serialize = function() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }, i2.prototype.hasTransition = function() {
            return this.video && !this.video.paused;
          }, i2;
        }(D), R = function(e2) {
          function i2(i3, o2, r2, a2) {
            e2.call(this, i3, o2, r2, a2), o2.coordinates ? Array.isArray(o2.coordinates) && 4 === o2.coordinates.length && !o2.coordinates.some(function(t2) {
              return !Array.isArray(t2) || 2 !== t2.length || t2.some(function(t3) {
                return "number" != typeof t3;
              });
            }) || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, 'missing required property "coordinates"'))), o2.animate && "boolean" != typeof o2.animate && this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, 'optional "animate" property must be a boolean value'))), o2.canvas ? "string" == typeof o2.canvas || o2.canvas instanceof t.window.HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, 'missing required property "canvas"'))), this.options = o2, this.animate = void 0 === o2.animate || o2.animate;
          }
          return e2 && (i2.__proto__ = e2), i2.prototype = Object.create(e2 && e2.prototype), i2.prototype.constructor = i2, i2.prototype.load = function() {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof t.window.HTMLCanvasElement ? this.options.canvas : t.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = false);
            }, this._finishLoading());
          }, i2.prototype.getCanvas = function() {
            return this.canvas;
          }, i2.prototype.onAdd = function(t2) {
            this.map = t2, this.load(), this.canvas && this.animate && this.play();
          }, i2.prototype.onRemove = function() {
            this.pause();
          }, i2.prototype.prepare = function() {
            var e3 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e3 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e3 = true), !this._hasInvalidDimensions() && 0 !== Object.keys(this.tiles).length) {
              var i3 = this.map.painter.context, o2 = i3.gl;
              for (var r2 in this.boundsBuffer || (this.boundsBuffer = i3.createVertexBuffer(this._boundsArray, L.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e3 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new t.Texture(i3, this.canvas, o2.RGBA, { premultiply: true }), this.tiles) {
                var a2 = this.tiles[r2];
                "loaded" !== a2.state && (a2.state = "loaded", a2.texture = this.texture);
              }
            }
          }, i2.prototype.serialize = function() {
            return { type: "canvas", coordinates: this.coordinates };
          }, i2.prototype.hasTransition = function() {
            return this._playing;
          }, i2.prototype._hasInvalidDimensions = function() {
            for (var t2 = 0, e3 = [this.canvas.width, this.canvas.height]; t2 < e3.length; t2 += 1) {
              var i3 = e3[t2];
              if (isNaN(i3) || i3 <= 0)
                return true;
            }
            return false;
          }, i2;
        }(D), k = { vector: C, raster: P, "raster-dem": z, geojson: M, video: A, image: D, canvas: R };
        function B(e2, i2) {
          var o2 = t.identity([]);
          return t.translate(o2, o2, [1, 1, 0]), t.scale(o2, o2, [0.5 * e2.width, 0.5 * e2.height, 1]), t.multiply(o2, o2, e2.calculatePosMatrix(i2.toUnwrapped()));
        }
        function O(t2, e2, i2, o2, r2) {
          var a2 = function(t3, e3, i3) {
            if (t3)
              for (var o3 = 0, r3 = t3; o3 < r3.length; o3 += 1) {
                var a3 = e3[r3[o3]];
                if (a3 && a3.source === i3 && "fill-extrusion" === a3.type)
                  return true;
              }
            else
              for (var n3 in e3) {
                var s3 = e3[n3];
                if (s3.source === i3 && "fill-extrusion" === s3.type)
                  return true;
              }
            return false;
          }(o2 && o2.layers, e2, t2.id), n2 = r2.maxPitchScaleFactor(), s2 = t2.tilesIn(i2, n2, a2);
          s2.sort(F);
          for (var l2 = [], c2 = 0, u2 = s2; c2 < u2.length; c2 += 1) {
            var h2 = u2[c2];
            l2.push({ wrappedTileID: h2.tileID.wrapped().key, queryResults: h2.tile.queryRenderedFeatures(e2, t2._state, h2.queryGeometry, h2.cameraQueryGeometry, h2.scale, o2, r2, n2, B(t2.transform, h2.tileID)) });
          }
          var p2 = function(t3) {
            for (var e3 = {}, i3 = {}, o3 = 0, r3 = t3; o3 < r3.length; o3 += 1) {
              var a3 = r3[o3], n3 = a3.queryResults, s3 = a3.wrappedTileID, l3 = i3[s3] = i3[s3] || {};
              for (var c3 in n3)
                for (var u3 = n3[c3], h3 = l3[c3] = l3[c3] || {}, p3 = e3[c3] = e3[c3] || [], d3 = 0, _2 = u3; d3 < _2.length; d3 += 1) {
                  var f2 = _2[d3];
                  h3[f2.featureIndex] || (h3[f2.featureIndex] = true, p3.push(f2));
                }
            }
            return e3;
          }(l2);
          for (var d2 in p2)
            p2[d2].forEach(function(e3) {
              var i3 = e3.feature, o3 = t2.getFeatureState(i3.layer["source-layer"], i3.id);
              i3.source = i3.layer.source, i3.layer["source-layer"] && (i3.sourceLayer = i3.layer["source-layer"]), i3.state = o3;
            });
          return p2;
        }
        function F(t2, e2) {
          var i2 = t2.tileID, o2 = e2.tileID;
          return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
        }
        var U = function(t2, e2) {
          this.max = t2, this.onRemove = e2, this.reset();
        };
        U.prototype.reset = function() {
          for (var t2 in this.data)
            for (var e2 = 0, i2 = this.data[t2]; e2 < i2.length; e2 += 1) {
              var o2 = i2[e2];
              o2.timeout && clearTimeout(o2.timeout), this.onRemove(o2.value);
            }
          return this.data = {}, this.order = [], this;
        }, U.prototype.add = function(t2, e2, i2) {
          var o2 = this, r2 = t2.wrapped().key;
          void 0 === this.data[r2] && (this.data[r2] = []);
          var a2 = { value: e2, timeout: void 0 };
          if (void 0 !== i2 && (a2.timeout = setTimeout(function() {
            o2.remove(t2, a2);
          }, i2)), this.data[r2].push(a2), this.order.push(r2), this.order.length > this.max) {
            var n2 = this._getAndRemoveByKey(this.order[0]);
            n2 && this.onRemove(n2);
          }
          return this;
        }, U.prototype.has = function(t2) {
          return t2.wrapped().key in this.data;
        }, U.prototype.getAndRemove = function(t2) {
          return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
        }, U.prototype._getAndRemoveByKey = function(t2) {
          var e2 = this.data[t2].shift();
          return e2.timeout && clearTimeout(e2.timeout), 0 === this.data[t2].length && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
        }, U.prototype.getByKey = function(t2) {
          var e2 = this.data[t2];
          return e2 ? e2[0].value : null;
        }, U.prototype.get = function(t2) {
          return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
        }, U.prototype.remove = function(t2, e2) {
          if (!this.has(t2))
            return this;
          var i2 = t2.wrapped().key, o2 = void 0 === e2 ? 0 : this.data[i2].indexOf(e2), r2 = this.data[i2][o2];
          return this.data[i2].splice(o2, 1), r2.timeout && clearTimeout(r2.timeout), 0 === this.data[i2].length && delete this.data[i2], this.onRemove(r2.value), this.order.splice(this.order.indexOf(i2), 1), this;
        }, U.prototype.setMaxSize = function(t2) {
          for (this.max = t2; this.order.length > this.max; ) {
            var e2 = this._getAndRemoveByKey(this.order[0]);
            e2 && this.onRemove(e2);
          }
          return this;
        }, U.prototype.filter = function(t2) {
          var e2 = [];
          for (var i2 in this.data)
            for (var o2 = 0, r2 = this.data[i2]; o2 < r2.length; o2 += 1) {
              var a2 = r2[o2];
              t2(a2.value) || e2.push(a2);
            }
          for (var n2 = 0, s2 = e2; n2 < s2.length; n2 += 1) {
            var l2 = s2[n2];
            this.remove(l2.value.tileID, l2);
          }
        };
        var N = function(t2, e2, i2) {
          this.context = t2;
          var o2 = t2.gl;
          this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), t2.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
        };
        N.prototype.bind = function() {
          this.context.bindElementBuffer.set(this.buffer);
        }, N.prototype.updateData = function(t2) {
          var e2 = this.context.gl;
          this.context.unbindVAO(), this.bind(), e2.bufferSubData(e2.ELEMENT_ARRAY_BUFFER, 0, t2.arrayBuffer);
        }, N.prototype.destroy = function() {
          var t2 = this.context.gl;
          this.buffer && (t2.deleteBuffer(this.buffer), delete this.buffer);
        };
        var Z = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }, q = function(t2, e2, i2, o2) {
          this.length = e2.length, this.attributes = i2, this.itemSize = e2.bytesPerElement, this.dynamicDraw = o2, this.context = t2;
          var r2 = t2.gl;
          this.buffer = r2.createBuffer(), t2.bindVertexBuffer.set(this.buffer), r2.bufferData(r2.ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? r2.DYNAMIC_DRAW : r2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
        };
        q.prototype.bind = function() {
          this.context.bindVertexBuffer.set(this.buffer);
        }, q.prototype.updateData = function(t2) {
          var e2 = this.context.gl;
          this.bind(), e2.bufferSubData(e2.ARRAY_BUFFER, 0, t2.arrayBuffer);
        }, q.prototype.enableAttributes = function(t2, e2) {
          for (var i2 = 0; i2 < this.attributes.length; i2++) {
            var o2 = this.attributes[i2], r2 = e2.attributes[o2.name];
            void 0 !== r2 && t2.enableVertexAttribArray(r2);
          }
        }, q.prototype.setVertexAttribPointers = function(t2, e2, i2) {
          for (var o2 = 0; o2 < this.attributes.length; o2++) {
            var r2 = this.attributes[o2], a2 = e2.attributes[r2.name];
            void 0 !== a2 && t2.vertexAttribPointer(a2, r2.components, t2[Z[r2.type]], false, this.itemSize, r2.offset + this.itemSize * (i2 || 0));
          }
        }, q.prototype.destroy = function() {
          var t2 = this.context.gl;
          this.buffer && (t2.deleteBuffer(this.buffer), delete this.buffer);
        };
        var j = function(t2) {
          this.gl = t2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        };
        j.prototype.get = function() {
          return this.current;
        }, j.prototype.set = function(t2) {
        }, j.prototype.getDefault = function() {
          return this.default;
        }, j.prototype.setDefault = function() {
          this.set(this.default);
        };
        var V = function(e2) {
          function i2() {
            e2.apply(this, arguments);
          }
          return e2 && (i2.__proto__ = e2), i2.prototype = Object.create(e2 && e2.prototype), i2.prototype.constructor = i2, i2.prototype.getDefault = function() {
            return t.Color.transparent;
          }, i2.prototype.set = function(t2) {
            var e3 = this.current;
            (t2.r !== e3.r || t2.g !== e3.g || t2.b !== e3.b || t2.a !== e3.a || this.dirty) && (this.gl.clearColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
          }, i2;
        }(j), G = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return 1;
          }, e2.prototype.set = function(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.clearDepth(t3), this.current = t3, this.dirty = false);
          }, e2;
        }(j), W = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return 0;
          }, e2.prototype.set = function(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.clearStencil(t3), this.current = t3, this.dirty = false);
          }, e2;
        }(j), X = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return [true, true, true, true];
          }, e2.prototype.set = function(t3) {
            var e3 = this.current;
            (t3[0] !== e3[0] || t3[1] !== e3[1] || t3[2] !== e3[2] || t3[3] !== e3[3] || this.dirty) && (this.gl.colorMask(t3[0], t3[1], t3[2], t3[3]), this.current = t3, this.dirty = false);
          }, e2;
        }(j), H = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return true;
          }, e2.prototype.set = function(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.depthMask(t3), this.current = t3, this.dirty = false);
          }, e2;
        }(j), K = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return 255;
          }, e2.prototype.set = function(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.stencilMask(t3), this.current = t3, this.dirty = false);
          }, e2;
        }(j), Y = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }, e2.prototype.set = function(t3) {
            var e3 = this.current;
            (t3.func !== e3.func || t3.ref !== e3.ref || t3.mask !== e3.mask || this.dirty) && (this.gl.stencilFunc(t3.func, t3.ref, t3.mask), this.current = t3, this.dirty = false);
          }, e2;
        }(j), J = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            var t3 = this.gl;
            return [t3.KEEP, t3.KEEP, t3.KEEP];
          }, e2.prototype.set = function(t3) {
            var e3 = this.current;
            (t3[0] !== e3[0] || t3[1] !== e3[1] || t3[2] !== e3[2] || this.dirty) && (this.gl.stencilOp(t3[0], t3[1], t3[2]), this.current = t3, this.dirty = false);
          }, e2;
        }(j), Q = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return false;
          }, e2.prototype.set = function(t3) {
            if (t3 !== this.current || this.dirty) {
              var e3 = this.gl;
              t3 ? e3.enable(e3.STENCIL_TEST) : e3.disable(e3.STENCIL_TEST), this.current = t3, this.dirty = false;
            }
          }, e2;
        }(j), $ = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return [0, 1];
          }, e2.prototype.set = function(t3) {
            var e3 = this.current;
            (t3[0] !== e3[0] || t3[1] !== e3[1] || this.dirty) && (this.gl.depthRange(t3[0], t3[1]), this.current = t3, this.dirty = false);
          }, e2;
        }(j), tt = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return false;
          }, e2.prototype.set = function(t3) {
            if (t3 !== this.current || this.dirty) {
              var e3 = this.gl;
              t3 ? e3.enable(e3.DEPTH_TEST) : e3.disable(e3.DEPTH_TEST), this.current = t3, this.dirty = false;
            }
          }, e2;
        }(j), et = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return this.gl.LESS;
          }, e2.prototype.set = function(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.depthFunc(t3), this.current = t3, this.dirty = false);
          }, e2;
        }(j), it = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return false;
          }, e2.prototype.set = function(t3) {
            if (t3 !== this.current || this.dirty) {
              var e3 = this.gl;
              t3 ? e3.enable(e3.BLEND) : e3.disable(e3.BLEND), this.current = t3, this.dirty = false;
            }
          }, e2;
        }(j), ot = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            var t3 = this.gl;
            return [t3.ONE, t3.ZERO];
          }, e2.prototype.set = function(t3) {
            var e3 = this.current;
            (t3[0] !== e3[0] || t3[1] !== e3[1] || this.dirty) && (this.gl.blendFunc(t3[0], t3[1]), this.current = t3, this.dirty = false);
          }, e2;
        }(j), rt = function(e2) {
          function i2() {
            e2.apply(this, arguments);
          }
          return e2 && (i2.__proto__ = e2), i2.prototype = Object.create(e2 && e2.prototype), i2.prototype.constructor = i2, i2.prototype.getDefault = function() {
            return t.Color.transparent;
          }, i2.prototype.set = function(t2) {
            var e3 = this.current;
            (t2.r !== e3.r || t2.g !== e3.g || t2.b !== e3.b || t2.a !== e3.a || this.dirty) && (this.gl.blendColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
          }, i2;
        }(j), at = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return this.gl.FUNC_ADD;
          }, e2.prototype.set = function(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.blendEquation(t3), this.current = t3, this.dirty = false);
          }, e2;
        }(j), nt = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return false;
          }, e2.prototype.set = function(t3) {
            if (t3 !== this.current || this.dirty) {
              var e3 = this.gl;
              t3 ? e3.enable(e3.CULL_FACE) : e3.disable(e3.CULL_FACE), this.current = t3, this.dirty = false;
            }
          }, e2;
        }(j), st = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return this.gl.BACK;
          }, e2.prototype.set = function(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.cullFace(t3), this.current = t3, this.dirty = false);
          }, e2;
        }(j), lt = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return this.gl.CCW;
          }, e2.prototype.set = function(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.frontFace(t3), this.current = t3, this.dirty = false);
          }, e2;
        }(j), ct = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2.prototype.set = function(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.useProgram(t3), this.current = t3, this.dirty = false);
          }, e2;
        }(j), ut = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return this.gl.TEXTURE0;
          }, e2.prototype.set = function(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.activeTexture(t3), this.current = t3, this.dirty = false);
          }, e2;
        }(j), ht = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            var t3 = this.gl;
            return [0, 0, t3.drawingBufferWidth, t3.drawingBufferHeight];
          }, e2.prototype.set = function(t3) {
            var e3 = this.current;
            (t3[0] !== e3[0] || t3[1] !== e3[1] || t3[2] !== e3[2] || t3[3] !== e3[3] || this.dirty) && (this.gl.viewport(t3[0], t3[1], t3[2], t3[3]), this.current = t3, this.dirty = false);
          }, e2;
        }(j), pt = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2.prototype.set = function(t3) {
            if (t3 !== this.current || this.dirty) {
              var e3 = this.gl;
              e3.bindFramebuffer(e3.FRAMEBUFFER, t3), this.current = t3, this.dirty = false;
            }
          }, e2;
        }(j), dt = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2.prototype.set = function(t3) {
            if (t3 !== this.current || this.dirty) {
              var e3 = this.gl;
              e3.bindRenderbuffer(e3.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
            }
          }, e2;
        }(j), _t = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2.prototype.set = function(t3) {
            if (t3 !== this.current || this.dirty) {
              var e3 = this.gl;
              e3.bindTexture(e3.TEXTURE_2D, t3), this.current = t3, this.dirty = false;
            }
          }, e2;
        }(j), ft = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2.prototype.set = function(t3) {
            if (t3 !== this.current || this.dirty) {
              var e3 = this.gl;
              e3.bindBuffer(e3.ARRAY_BUFFER, t3), this.current = t3, this.dirty = false;
            }
          }, e2;
        }(j), mt = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2.prototype.set = function(t3) {
            var e3 = this.gl;
            e3.bindBuffer(e3.ELEMENT_ARRAY_BUFFER, t3), this.current = t3, this.dirty = false;
          }, e2;
        }(j), gt = function(t2) {
          function e2(e3) {
            t2.call(this, e3), this.vao = e3.extVertexArrayObject;
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2.prototype.set = function(t3) {
            this.vao && (t3 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t3), this.current = t3, this.dirty = false);
          }, e2;
        }(j), vt = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return 4;
          }, e2.prototype.set = function(t3) {
            if (t3 !== this.current || this.dirty) {
              var e3 = this.gl;
              e3.pixelStorei(e3.UNPACK_ALIGNMENT, t3), this.current = t3, this.dirty = false;
            }
          }, e2;
        }(j), yt = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return false;
          }, e2.prototype.set = function(t3) {
            if (t3 !== this.current || this.dirty) {
              var e3 = this.gl;
              e3.pixelStorei(e3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t3), this.current = t3, this.dirty = false;
            }
          }, e2;
        }(j), xt = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return false;
          }, e2.prototype.set = function(t3) {
            if (t3 !== this.current || this.dirty) {
              var e3 = this.gl;
              e3.pixelStorei(e3.UNPACK_FLIP_Y_WEBGL, t3), this.current = t3, this.dirty = false;
            }
          }, e2;
        }(j), bt = function(t2) {
          function e2(e3, i2) {
            t2.call(this, e3), this.context = e3, this.parent = i2;
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2;
        }(j), wt = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.setDirty = function() {
            this.dirty = true;
          }, e2.prototype.set = function(t3) {
            if (t3 !== this.current || this.dirty) {
              this.context.bindFramebuffer.set(this.parent);
              var e3 = this.gl;
              e3.framebufferTexture2D(e3.FRAMEBUFFER, e3.COLOR_ATTACHMENT0, e3.TEXTURE_2D, t3, 0), this.current = t3, this.dirty = false;
            }
          }, e2;
        }(bt), Et = function(t2) {
          function e2() {
            t2.apply(this, arguments);
          }
          return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.set = function(t3) {
            if (t3 !== this.current || this.dirty) {
              this.context.bindFramebuffer.set(this.parent);
              var e3 = this.gl;
              e3.framebufferRenderbuffer(e3.FRAMEBUFFER, e3.DEPTH_ATTACHMENT, e3.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
            }
          }, e2;
        }(bt), Tt = function(t2, e2, i2) {
          this.context = t2, this.width = e2, this.height = i2;
          var o2 = t2.gl, r2 = this.framebuffer = o2.createFramebuffer();
          this.colorAttachment = new wt(t2, r2), this.depthAttachment = new Et(t2, r2);
        };
        Tt.prototype.destroy = function() {
          var t2 = this.context.gl, e2 = this.colorAttachment.get();
          e2 && t2.deleteTexture(e2);
          var i2 = this.depthAttachment.get();
          i2 && t2.deleteRenderbuffer(i2), t2.deleteFramebuffer(this.framebuffer);
        };
        var It = function(t2, e2, i2) {
          this.func = t2, this.mask = e2, this.range = i2;
        };
        It.ReadOnly = false, It.ReadWrite = true, It.disabled = new It(519, It.ReadOnly, [0, 1]);
        var St = function(t2, e2, i2, o2, r2, a2) {
          this.test = t2, this.ref = e2, this.mask = i2, this.fail = o2, this.depthFail = r2, this.pass = a2;
        };
        St.disabled = new St({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680);
        var Ct = function(t2, e2, i2) {
          this.blendFunction = t2, this.blendColor = e2, this.mask = i2;
        };
        Ct.disabled = new Ct(Ct.Replace = [1, 0], t.Color.transparent, [false, false, false, false]), Ct.unblended = new Ct(Ct.Replace, t.Color.transparent, [true, true, true, true]), Ct.alphaBlended = new Ct([1, 771], t.Color.transparent, [true, true, true, true]);
        var Pt = function(t2, e2, i2) {
          this.enable = t2, this.mode = e2, this.frontFace = i2;
        };
        Pt.disabled = new Pt(false, 1029, 2305), Pt.backCCW = new Pt(true, 1029, 2305);
        var zt = function(t2) {
          this.gl = t2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new V(this), this.clearDepth = new G(this), this.clearStencil = new W(this), this.colorMask = new X(this), this.depthMask = new H(this), this.stencilMask = new K(this), this.stencilFunc = new Y(this), this.stencilOp = new J(this), this.stencilTest = new Q(this), this.depthRange = new $(this), this.depthTest = new tt(this), this.depthFunc = new et(this), this.blend = new it(this), this.blendFunc = new ot(this), this.blendColor = new rt(this), this.blendEquation = new at(this), this.cullFace = new nt(this), this.cullFaceSide = new st(this), this.frontFace = new lt(this), this.program = new ct(this), this.activeTexture = new ut(this), this.viewport = new ht(this), this.bindFramebuffer = new pt(this), this.bindRenderbuffer = new dt(this), this.bindTexture = new _t(this), this.bindVertexBuffer = new ft(this), this.bindElementBuffer = new mt(this), this.bindVertexArrayOES = this.extVertexArrayObject && new gt(this), this.pixelStoreUnpack = new vt(this), this.pixelStoreUnpackPremultiplyAlpha = new yt(this), this.pixelStoreUnpackFlipY = new xt(this), this.extTextureFilterAnisotropic = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t2.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && t2.getExtension("OES_texture_half_float_linear"), this.extTimerQuery = t2.getExtension("EXT_disjoint_timer_query");
        };
        zt.prototype.setDefault = function() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }, zt.prototype.setDirty = function() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }, zt.prototype.createIndexBuffer = function(t2, e2) {
          return new N(this, t2, e2);
        }, zt.prototype.createVertexBuffer = function(t2, e2, i2) {
          return new q(this, t2, e2, i2);
        }, zt.prototype.createRenderbuffer = function(t2, e2, i2) {
          var o2 = this.gl, r2 = o2.createRenderbuffer();
          return this.bindRenderbuffer.set(r2), o2.renderbufferStorage(o2.RENDERBUFFER, t2, e2, i2), this.bindRenderbuffer.set(null), r2;
        }, zt.prototype.createFramebuffer = function(t2, e2) {
          return new Tt(this, t2, e2);
        }, zt.prototype.clear = function(t2) {
          var e2 = t2.color, i2 = t2.depth, o2 = this.gl, r2 = 0;
          e2 && (r2 |= o2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), void 0 !== i2 && (r2 |= o2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i2), this.depthMask.set(true)), o2.clear(r2);
        }, zt.prototype.setCullFace = function(t2) {
          false === t2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t2.mode), this.frontFace.set(t2.frontFace));
        }, zt.prototype.setDepthMode = function(t2) {
          t2.func !== this.gl.ALWAYS || t2.mask ? (this.depthTest.set(true), this.depthFunc.set(t2.func), this.depthMask.set(t2.mask), this.depthRange.set(t2.range)) : this.depthTest.set(false);
        }, zt.prototype.setStencilMode = function(t2) {
          t2.test.func !== this.gl.ALWAYS || t2.mask ? (this.stencilTest.set(true), this.stencilMask.set(t2.mask), this.stencilOp.set([t2.fail, t2.depthFail, t2.pass]), this.stencilFunc.set({ func: t2.test.func, ref: t2.ref, mask: t2.test.mask })) : this.stencilTest.set(false);
        }, zt.prototype.setColorMode = function(e2) {
          t.deepEqual(e2.blendFunction, Ct.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e2.blendFunction), this.blendColor.set(e2.blendColor)), this.colorMask.set(e2.mask);
        }, zt.prototype.unbindVAO = function() {
          this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
        };
        var Mt = function(e2) {
          function i2(i3, o2, r2) {
            var a2 = this;
            e2.call(this), this.id = i3, this.dispatcher = r2, this.on("data", function(t2) {
              "source" === t2.dataType && "metadata" === t2.sourceDataType && (a2._sourceLoaded = true), a2._sourceLoaded && !a2._paused && "source" === t2.dataType && "content" === t2.sourceDataType && (a2.reload(), a2.transform && a2.update(a2.transform));
            }), this.on("error", function() {
              a2._sourceErrored = true;
            }), this._source = function(e3, i4, o3, r3) {
              var a3 = new k[i4.type](e3, i4, o3, r3);
              if (a3.id !== e3)
                throw new Error("Expected Source id to be " + e3 + " instead of " + a3.id);
              return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], a3), a3;
            }(i3, o2, r2, this), this._tiles = {}, this._cache = new U(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new t.SourceFeatureState();
          }
          return e2 && (i2.__proto__ = e2), i2.prototype = Object.create(e2 && e2.prototype), i2.prototype.constructor = i2, i2.prototype.onAdd = function(t2) {
            this.map = t2, this._maxTileCacheSize = t2 ? t2._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t2);
          }, i2.prototype.onRemove = function(t2) {
            this._source && this._source.onRemove && this._source.onRemove(t2);
          }, i2.prototype.loaded = function() {
            if (this._sourceErrored)
              return true;
            if (!this._sourceLoaded)
              return false;
            if (!this._source.loaded())
              return false;
            for (var t2 in this._tiles) {
              var e3 = this._tiles[t2];
              if ("loaded" !== e3.state && "errored" !== e3.state)
                return false;
            }
            return true;
          }, i2.prototype.getSource = function() {
            return this._source;
          }, i2.prototype.pause = function() {
            this._paused = true;
          }, i2.prototype.resume = function() {
            if (this._paused) {
              var t2 = this._shouldReloadOnResume;
              this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform);
            }
          }, i2.prototype._loadTile = function(t2, e3) {
            return this._source.loadTile(t2, e3);
          }, i2.prototype._unloadTile = function(t2) {
            if (this._source.unloadTile)
              return this._source.unloadTile(t2, function() {
              });
          }, i2.prototype._abortTile = function(t2) {
            if (this._source.abortTile)
              return this._source.abortTile(t2, function() {
              });
          }, i2.prototype.serialize = function() {
            return this._source.serialize();
          }, i2.prototype.prepare = function(t2) {
            for (var e3 in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) {
              var i3 = this._tiles[e3];
              i3.upload(t2), i3.prepare(this.map.style.imageManager);
            }
          }, i2.prototype.getIds = function() {
            return Object.values(this._tiles).map(function(t2) {
              return t2.tileID;
            }).sort(Lt).map(function(t2) {
              return t2.key;
            });
          }, i2.prototype.getRenderableIds = function(e3) {
            var i3 = this, o2 = [];
            for (var r2 in this._tiles)
              this._isIdRenderable(r2, e3) && o2.push(this._tiles[r2]);
            return e3 ? o2.sort(function(e4, o3) {
              var r3 = e4.tileID, a2 = o3.tileID, n2 = new t.Point(r3.canonical.x, r3.canonical.y)._rotate(i3.transform.angle), s2 = new t.Point(a2.canonical.x, a2.canonical.y)._rotate(i3.transform.angle);
              return r3.overscaledZ - a2.overscaledZ || s2.y - n2.y || s2.x - n2.x;
            }).map(function(t2) {
              return t2.tileID.key;
            }) : o2.map(function(t2) {
              return t2.tileID;
            }).sort(Lt).map(function(t2) {
              return t2.key;
            });
          }, i2.prototype.hasRenderableParent = function(t2) {
            var e3 = this.findLoadedParent(t2, 0);
            return !!e3 && this._isIdRenderable(e3.tileID.key);
          }, i2.prototype._isIdRenderable = function(t2, e3) {
            return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e3 || !this._tiles[t2].holdingForFade());
          }, i2.prototype.reload = function() {
            if (this._paused)
              this._shouldReloadOnResume = true;
            else
              for (var t2 in this._cache.reset(), this._tiles)
                "errored" !== this._tiles[t2].state && this._reloadTile(t2, "reloading");
          }, i2.prototype._reloadTile = function(t2, e3) {
            var i3 = this._tiles[t2];
            i3 && ("loading" !== i3.state && (i3.state = e3), this._loadTile(i3, this._tileLoaded.bind(this, i3, t2, e3)));
          }, i2.prototype._tileLoaded = function(e3, i3, o2, r2) {
            if (r2)
              return e3.state = "errored", void (404 !== r2.status ? this._source.fire(new t.ErrorEvent(r2, { tile: e3 })) : this.update(this.transform));
            e3.timeAdded = t.browser.now(), "expired" === o2 && (e3.refreshedUponExpiration = true), this._setTileReloadTimer(i3, e3), "raster-dem" === this.getSource().type && e3.dem && this._backfillDEM(e3), this._state.initializeTileState(e3, this.map ? this.map.painter : null), this._source.fire(new t.Event("data", { dataType: "source", tile: e3, coord: e3.tileID }));
          }, i2.prototype._backfillDEM = function(t2) {
            for (var e3 = this.getRenderableIds(), i3 = 0; i3 < e3.length; i3++) {
              var o2 = e3[i3];
              if (t2.neighboringTiles && t2.neighboringTiles[o2]) {
                var r2 = this.getTileByID(o2);
                a2(t2, r2), a2(r2, t2);
              }
            }
            function a2(t3, e4) {
              t3.needsHillshadePrepare = true;
              var i4 = e4.tileID.canonical.x - t3.tileID.canonical.x, o3 = e4.tileID.canonical.y - t3.tileID.canonical.y, r3 = Math.pow(2, t3.tileID.canonical.z), a3 = e4.tileID.key;
              0 === i4 && 0 === o3 || Math.abs(o3) > 1 || (Math.abs(i4) > 1 && (1 === Math.abs(i4 + r3) ? i4 += r3 : 1 === Math.abs(i4 - r3) && (i4 -= r3)), e4.dem && t3.dem && (t3.dem.backfillBorder(e4.dem, i4, o3), t3.neighboringTiles && t3.neighboringTiles[a3] && (t3.neighboringTiles[a3].backfilled = true)));
            }
          }, i2.prototype.getTile = function(t2) {
            return this.getTileByID(t2.key);
          }, i2.prototype.getTileByID = function(t2) {
            return this._tiles[t2];
          }, i2.prototype._retainLoadedChildren = function(t2, e3, i3, o2) {
            for (var r2 in this._tiles) {
              var a2 = this._tiles[r2];
              if (!(o2[r2] || !a2.hasData() || a2.tileID.overscaledZ <= e3 || a2.tileID.overscaledZ > i3)) {
                for (var n2 = a2.tileID; a2 && a2.tileID.overscaledZ > e3 + 1; ) {
                  var s2 = a2.tileID.scaledTo(a2.tileID.overscaledZ - 1);
                  (a2 = this._tiles[s2.key]) && a2.hasData() && (n2 = s2);
                }
                for (var l2 = n2; l2.overscaledZ > e3; )
                  if (t2[(l2 = l2.scaledTo(l2.overscaledZ - 1)).key]) {
                    o2[n2.key] = n2;
                    break;
                  }
              }
            }
          }, i2.prototype.findLoadedParent = function(t2, e3) {
            if (t2.key in this._loadedParentTiles) {
              var i3 = this._loadedParentTiles[t2.key];
              return i3 && i3.tileID.overscaledZ >= e3 ? i3 : null;
            }
            for (var o2 = t2.overscaledZ - 1; o2 >= e3; o2--) {
              var r2 = t2.scaledTo(o2), a2 = this._getLoadedTile(r2);
              if (a2)
                return a2;
            }
          }, i2.prototype._getLoadedTile = function(t2) {
            var e3 = this._tiles[t2.key];
            return e3 && e3.hasData() ? e3 : this._cache.getByKey(t2.wrapped().key);
          }, i2.prototype.updateCacheSize = function(t2) {
            var e3 = (Math.ceil(t2.width / this._source.tileSize) + 1) * (Math.ceil(t2.height / this._source.tileSize) + 1), i3 = Math.floor(5 * e3), o2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, i3) : i3;
            this._cache.setMaxSize(o2);
          }, i2.prototype.handleWrapJump = function(t2) {
            var e3 = (t2 - (void 0 === this._prevLng ? t2 : this._prevLng)) / 360, i3 = Math.round(e3);
            if (this._prevLng = t2, i3) {
              var o2 = {};
              for (var r2 in this._tiles) {
                var a2 = this._tiles[r2];
                a2.tileID = a2.tileID.unwrapTo(a2.tileID.wrap + i3), o2[a2.tileID.key] = a2;
              }
              for (var n2 in this._tiles = o2, this._timers)
                clearTimeout(this._timers[n2]), delete this._timers[n2];
              for (var s2 in this._tiles) {
                var l2 = this._tiles[s2];
                this._setTileReloadTimer(s2, l2);
              }
            }
          }, i2.prototype.update = function(e3) {
            var o2 = this;
            if (this.transform = e3, this._sourceLoaded && !this._paused) {
              var r2;
              this.updateCacheSize(e3), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? r2 = e3.getVisibleUnwrappedCoordinates(this._source.tileID).map(function(e4) {
                return new t.OverscaledTileID(e4.canonical.z, e4.wrap, e4.canonical.z, e4.canonical.x, e4.canonical.y);
              }) : (r2 = e3.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }), this._source.hasTile && (r2 = r2.filter(function(t2) {
                return o2._source.hasTile(t2);
              }))) : r2 = [];
              var a2 = e3.coveringZoomLevel(this._source), n2 = Math.max(a2 - i2.maxOverzooming, this._source.minzoom), s2 = Math.max(a2 + i2.maxUnderzooming, this._source.minzoom), l2 = this._updateRetainedTiles(r2, a2);
              if (Dt(this._source.type)) {
                for (var c2 = {}, u2 = {}, h2 = 0, p2 = Object.keys(l2); h2 < p2.length; h2 += 1) {
                  var d2 = p2[h2], _2 = l2[d2], f2 = this._tiles[d2];
                  if (f2 && !(f2.fadeEndTime && f2.fadeEndTime <= t.browser.now())) {
                    var m2 = this.findLoadedParent(_2, n2);
                    m2 && (this._addTile(m2.tileID), c2[m2.tileID.key] = m2.tileID), u2[d2] = _2;
                  }
                }
                for (var g2 in this._retainLoadedChildren(u2, a2, s2, l2), c2)
                  l2[g2] || (this._coveredTiles[g2] = true, l2[g2] = c2[g2]);
              }
              for (var v2 in l2)
                this._tiles[v2].clearFadeHold();
              for (var y2 = 0, x2 = t.keysDifference(this._tiles, l2); y2 < x2.length; y2 += 1) {
                var b2 = x2[y2], w2 = this._tiles[b2];
                w2.hasSymbolBuckets && !w2.holdingForFade() ? w2.setHoldDuration(this.map._fadeDuration) : w2.hasSymbolBuckets && !w2.symbolFadeFinished() || this._removeTile(b2);
              }
              this._updateLoadedParentTileCache();
            }
          }, i2.prototype.releaseSymbolFadeTiles = function() {
            for (var t2 in this._tiles)
              this._tiles[t2].holdingForFade() && this._removeTile(t2);
          }, i2.prototype._updateRetainedTiles = function(t2, e3) {
            for (var o2 = {}, r2 = {}, a2 = Math.max(e3 - i2.maxOverzooming, this._source.minzoom), n2 = Math.max(e3 + i2.maxUnderzooming, this._source.minzoom), s2 = {}, l2 = 0, c2 = t2; l2 < c2.length; l2 += 1) {
              var u2 = c2[l2], h2 = this._addTile(u2);
              o2[u2.key] = u2, h2.hasData() || e3 < this._source.maxzoom && (s2[u2.key] = u2);
            }
            this._retainLoadedChildren(s2, e3, n2, o2);
            for (var p2 = 0, d2 = t2; p2 < d2.length; p2 += 1) {
              var _2 = d2[p2], f2 = this._tiles[_2.key];
              if (!f2.hasData()) {
                if (e3 + 1 > this._source.maxzoom) {
                  var m2 = _2.children(this._source.maxzoom)[0], g2 = this.getTile(m2);
                  if (g2 && g2.hasData()) {
                    o2[m2.key] = m2;
                    continue;
                  }
                } else {
                  var v2 = _2.children(this._source.maxzoom);
                  if (o2[v2[0].key] && o2[v2[1].key] && o2[v2[2].key] && o2[v2[3].key])
                    continue;
                }
                for (var y2 = f2.wasRequested(), x2 = _2.overscaledZ - 1; x2 >= a2; --x2) {
                  var b2 = _2.scaledTo(x2);
                  if (r2[b2.key])
                    break;
                  if (r2[b2.key] = true, !(f2 = this.getTile(b2)) && y2 && (f2 = this._addTile(b2)), f2 && (o2[b2.key] = b2, y2 = f2.wasRequested(), f2.hasData()))
                    break;
                }
              }
            }
            return o2;
          }, i2.prototype._updateLoadedParentTileCache = function() {
            for (var t2 in this._loadedParentTiles = {}, this._tiles) {
              for (var e3 = [], i3 = void 0, o2 = this._tiles[t2].tileID; o2.overscaledZ > 0; ) {
                if (o2.key in this._loadedParentTiles) {
                  i3 = this._loadedParentTiles[o2.key];
                  break;
                }
                e3.push(o2.key);
                var r2 = o2.scaledTo(o2.overscaledZ - 1);
                if (i3 = this._getLoadedTile(r2))
                  break;
                o2 = r2;
              }
              for (var a2 = 0, n2 = e3; a2 < n2.length; a2 += 1) {
                var s2 = n2[a2];
                this._loadedParentTiles[s2] = i3;
              }
            }
          }, i2.prototype._addTile = function(e3) {
            var i3 = this._tiles[e3.key];
            if (i3)
              return i3;
            (i3 = this._cache.getAndRemove(e3)) && (this._setTileReloadTimer(e3.key, i3), i3.tileID = e3, this._state.initializeTileState(i3, this.map ? this.map.painter : null), this._cacheTimers[e3.key] && (clearTimeout(this._cacheTimers[e3.key]), delete this._cacheTimers[e3.key], this._setTileReloadTimer(e3.key, i3)));
            var o2 = Boolean(i3);
            return o2 || (i3 = new t.Tile(e3, this._source.tileSize * e3.overscaleFactor()), this._loadTile(i3, this._tileLoaded.bind(this, i3, e3.key, i3.state))), i3 ? (i3.uses++, this._tiles[e3.key] = i3, o2 || this._source.fire(new t.Event("dataloading", { tile: i3, coord: i3.tileID, dataType: "source" })), i3) : null;
          }, i2.prototype._setTileReloadTimer = function(t2, e3) {
            var i3 = this;
            t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
            var o2 = e3.getExpiryTimeout();
            o2 && (this._timers[t2] = setTimeout(function() {
              i3._reloadTile(t2, "expired"), delete i3._timers[t2];
            }, o2));
          }, i2.prototype._removeTile = function(t2) {
            var e3 = this._tiles[t2];
            e3 && (e3.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e3.uses > 0 || (e3.hasData() && "reloading" !== e3.state ? this._cache.add(e3.tileID, e3, e3.getExpiryTimeout()) : (e3.aborted = true, this._abortTile(e3), this._unloadTile(e3))));
          }, i2.prototype.clearTiles = function() {
            for (var t2 in this._shouldReloadOnResume = false, this._paused = false, this._tiles)
              this._removeTile(t2);
            this._cache.reset();
          }, i2.prototype.tilesIn = function(e3, i3, o2) {
            var r2 = this, a2 = [], n2 = this.transform;
            if (!n2)
              return a2;
            for (var s2 = o2 ? n2.getCameraQueryGeometry(e3) : e3, l2 = e3.map(function(t2) {
              return n2.pointCoordinate(t2);
            }), c2 = s2.map(function(t2) {
              return n2.pointCoordinate(t2);
            }), u2 = this.getIds(), h2 = 1 / 0, p2 = 1 / 0, d2 = -1 / 0, _2 = -1 / 0, f2 = 0, m2 = c2; f2 < m2.length; f2 += 1) {
              var g2 = m2[f2];
              h2 = Math.min(h2, g2.x), p2 = Math.min(p2, g2.y), d2 = Math.max(d2, g2.x), _2 = Math.max(_2, g2.y);
            }
            for (var v2 = function(e4) {
              var o3 = r2._tiles[u2[e4]];
              if (!o3.holdingForFade()) {
                var s3 = o3.tileID, f3 = Math.pow(2, n2.zoom - o3.tileID.overscaledZ), m3 = i3 * o3.queryPadding * t.EXTENT / o3.tileSize / f3, g3 = [s3.getTilePoint(new t.MercatorCoordinate(h2, p2)), s3.getTilePoint(new t.MercatorCoordinate(d2, _2))];
                if (g3[0].x - m3 < t.EXTENT && g3[0].y - m3 < t.EXTENT && g3[1].x + m3 >= 0 && g3[1].y + m3 >= 0) {
                  var v3 = l2.map(function(t2) {
                    return s3.getTilePoint(t2);
                  }), y3 = c2.map(function(t2) {
                    return s3.getTilePoint(t2);
                  });
                  a2.push({ tile: o3, tileID: s3, queryGeometry: v3, cameraQueryGeometry: y3, scale: f3 });
                }
              }
            }, y2 = 0; y2 < u2.length; y2++)
              v2(y2);
            return a2;
          }, i2.prototype.getVisibleCoordinates = function(t2) {
            for (var e3 = this, i3 = this.getRenderableIds(t2).map(function(t3) {
              return e3._tiles[t3].tileID;
            }), o2 = 0, r2 = i3; o2 < r2.length; o2 += 1) {
              var a2 = r2[o2];
              a2.posMatrix = this.transform.calculatePosMatrix(a2.toUnwrapped());
            }
            return i3;
          }, i2.prototype.hasTransition = function() {
            if (this._source.hasTransition())
              return true;
            if (Dt(this._source.type))
              for (var e3 in this._tiles) {
                var i3 = this._tiles[e3];
                if (void 0 !== i3.fadeEndTime && i3.fadeEndTime >= t.browser.now())
                  return true;
              }
            return false;
          }, i2.prototype.setFeatureState = function(t2, e3, i3) {
            t2 = t2 || "_geojsonTileLayer", this._state.updateState(t2, e3, i3);
          }, i2.prototype.removeFeatureState = function(t2, e3, i3) {
            t2 = t2 || "_geojsonTileLayer", this._state.removeFeatureState(t2, e3, i3);
          }, i2.prototype.getFeatureState = function(t2, e3) {
            return t2 = t2 || "_geojsonTileLayer", this._state.getState(t2, e3);
          }, i2.prototype.setDependencies = function(t2, e3, i3) {
            var o2 = this._tiles[t2];
            o2 && o2.setDependencies(e3, i3);
          }, i2.prototype.reloadTilesForDependencies = function(t2, e3) {
            for (var i3 in this._tiles) {
              this._tiles[i3].hasDependency(t2, e3) && this._reloadTile(i3, "reloading");
            }
            this._cache.filter(function(i4) {
              return !i4.hasDependency(t2, e3);
            });
          }, i2;
        }(t.Evented);
        function Lt(t2, e2) {
          var i2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), o2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
          return t2.overscaledZ - e2.overscaledZ || o2 - i2 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
        }
        function Dt(t2) {
          return "raster" === t2 || "image" === t2 || "video" === t2;
        }
        function At() {
          return new t.window.Worker(ar.workerUrl);
        }
        Mt.maxOverzooming = 10, Mt.maxUnderzooming = 3;
        var Rt = function() {
          this.active = {};
        };
        Rt.prototype.acquire = function(t2) {
          if (!this.workers)
            for (this.workers = []; this.workers.length < Rt.workerCount; )
              this.workers.push(new At());
          return this.active[t2] = true, this.workers.slice();
        }, Rt.prototype.release = function(t2) {
          delete this.active[t2], 0 === Object.keys(this.active).length && (this.workers.forEach(function(t3) {
            t3.terminate();
          }), this.workers = null);
        };
        var kt, Bt = Math.floor(t.browser.hardwareConcurrency / 2);
        function Ot(e2, i2) {
          var o2 = {};
          for (var r2 in e2)
            "ref" !== r2 && (o2[r2] = e2[r2]);
          return t.refProperties.forEach(function(t2) {
            t2 in i2 && (o2[t2] = i2[t2]);
          }), o2;
        }
        function Ft(t2) {
          t2 = t2.slice();
          for (var e2 = /* @__PURE__ */ Object.create(null), i2 = 0; i2 < t2.length; i2++)
            e2[t2[i2].id] = t2[i2];
          for (var o2 = 0; o2 < t2.length; o2++)
            "ref" in t2[o2] && (t2[o2] = Ot(t2[o2], e2[t2[o2].ref]));
          return t2;
        }
        Rt.workerCount = Math.max(Math.min(Bt, 6), 1);
        var Ut = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
        function Nt(t2, e2, i2) {
          i2.push({ command: Ut.addSource, args: [t2, e2[t2]] });
        }
        function Zt(t2, e2, i2) {
          e2.push({ command: Ut.removeSource, args: [t2] }), i2[t2] = true;
        }
        function qt(t2, e2, i2, o2) {
          Zt(t2, i2, o2), Nt(t2, e2, i2);
        }
        function jt(e2, i2, o2) {
          var r2;
          for (r2 in e2[o2])
            if (e2[o2].hasOwnProperty(r2) && "data" !== r2 && !t.deepEqual(e2[o2][r2], i2[o2][r2]))
              return false;
          for (r2 in i2[o2])
            if (i2[o2].hasOwnProperty(r2) && "data" !== r2 && !t.deepEqual(e2[o2][r2], i2[o2][r2]))
              return false;
          return true;
        }
        function Vt(e2, i2, o2, r2, a2, n2) {
          var s2;
          for (s2 in i2 = i2 || {}, e2 = e2 || {})
            e2.hasOwnProperty(s2) && (t.deepEqual(e2[s2], i2[s2]) || o2.push({ command: n2, args: [r2, s2, i2[s2], a2] }));
          for (s2 in i2)
            i2.hasOwnProperty(s2) && !e2.hasOwnProperty(s2) && (t.deepEqual(e2[s2], i2[s2]) || o2.push({ command: n2, args: [r2, s2, i2[s2], a2] }));
        }
        function Gt(t2) {
          return t2.id;
        }
        function Wt(t2, e2) {
          return t2[e2.id] = e2, t2;
        }
        function Xt(e2, i2) {
          if (!e2)
            return [{ command: Ut.setStyle, args: [i2] }];
          var o2 = [];
          try {
            if (!t.deepEqual(e2.version, i2.version))
              return [{ command: Ut.setStyle, args: [i2] }];
            t.deepEqual(e2.center, i2.center) || o2.push({ command: Ut.setCenter, args: [i2.center] }), t.deepEqual(e2.zoom, i2.zoom) || o2.push({ command: Ut.setZoom, args: [i2.zoom] }), t.deepEqual(e2.bearing, i2.bearing) || o2.push({ command: Ut.setBearing, args: [i2.bearing] }), t.deepEqual(e2.pitch, i2.pitch) || o2.push({ command: Ut.setPitch, args: [i2.pitch] }), t.deepEqual(e2.sprite, i2.sprite) || o2.push({ command: Ut.setSprite, args: [i2.sprite] }), t.deepEqual(e2.glyphs, i2.glyphs) || o2.push({ command: Ut.setGlyphs, args: [i2.glyphs] }), t.deepEqual(e2.transition, i2.transition) || o2.push({ command: Ut.setTransition, args: [i2.transition] }), t.deepEqual(e2.light, i2.light) || o2.push({ command: Ut.setLight, args: [i2.light] });
            var r2 = {}, a2 = [];
            !function(e3, i3, o3, r3) {
              var a3;
              for (a3 in i3 = i3 || {}, e3 = e3 || {})
                e3.hasOwnProperty(a3) && (i3.hasOwnProperty(a3) || Zt(a3, o3, r3));
              for (a3 in i3)
                i3.hasOwnProperty(a3) && (e3.hasOwnProperty(a3) ? t.deepEqual(e3[a3], i3[a3]) || ("geojson" === e3[a3].type && "geojson" === i3[a3].type && jt(e3, i3, a3) ? o3.push({ command: Ut.setGeoJSONSourceData, args: [a3, i3[a3].data] }) : qt(a3, i3, o3, r3)) : Nt(a3, i3, o3));
            }(e2.sources, i2.sources, a2, r2);
            var n2 = [];
            e2.layers && e2.layers.forEach(function(t2) {
              r2[t2.source] ? o2.push({ command: Ut.removeLayer, args: [t2.id] }) : n2.push(t2);
            }), o2 = o2.concat(a2), function(e3, i3, o3) {
              i3 = i3 || [];
              var r3, a3, n3, s2, l2, c2, u2, h2 = (e3 = e3 || []).map(Gt), p2 = i3.map(Gt), d2 = e3.reduce(Wt, {}), _2 = i3.reduce(Wt, {}), f2 = h2.slice(), m2 = /* @__PURE__ */ Object.create(null);
              for (r3 = 0, a3 = 0; r3 < h2.length; r3++)
                n3 = h2[r3], _2.hasOwnProperty(n3) ? a3++ : (o3.push({ command: Ut.removeLayer, args: [n3] }), f2.splice(f2.indexOf(n3, a3), 1));
              for (r3 = 0, a3 = 0; r3 < p2.length; r3++)
                n3 = p2[p2.length - 1 - r3], f2[f2.length - 1 - r3] !== n3 && (d2.hasOwnProperty(n3) ? (o3.push({ command: Ut.removeLayer, args: [n3] }), f2.splice(f2.lastIndexOf(n3, f2.length - a3), 1)) : a3++, c2 = f2[f2.length - r3], o3.push({ command: Ut.addLayer, args: [_2[n3], c2] }), f2.splice(f2.length - r3, 0, n3), m2[n3] = true);
              for (r3 = 0; r3 < p2.length; r3++)
                if (s2 = d2[n3 = p2[r3]], l2 = _2[n3], !m2[n3] && !t.deepEqual(s2, l2))
                  if (t.deepEqual(s2.source, l2.source) && t.deepEqual(s2["source-layer"], l2["source-layer"]) && t.deepEqual(s2.type, l2.type)) {
                    for (u2 in Vt(s2.layout, l2.layout, o3, n3, null, Ut.setLayoutProperty), Vt(s2.paint, l2.paint, o3, n3, null, Ut.setPaintProperty), t.deepEqual(s2.filter, l2.filter) || o3.push({ command: Ut.setFilter, args: [n3, l2.filter] }), t.deepEqual(s2.minzoom, l2.minzoom) && t.deepEqual(s2.maxzoom, l2.maxzoom) || o3.push({ command: Ut.setLayerZoomRange, args: [n3, l2.minzoom, l2.maxzoom] }), s2)
                      s2.hasOwnProperty(u2) && "layout" !== u2 && "paint" !== u2 && "filter" !== u2 && "metadata" !== u2 && "minzoom" !== u2 && "maxzoom" !== u2 && (0 === u2.indexOf("paint.") ? Vt(s2[u2], l2[u2], o3, n3, u2.slice(6), Ut.setPaintProperty) : t.deepEqual(s2[u2], l2[u2]) || o3.push({ command: Ut.setLayerProperty, args: [n3, u2, l2[u2]] }));
                    for (u2 in l2)
                      l2.hasOwnProperty(u2) && !s2.hasOwnProperty(u2) && "layout" !== u2 && "paint" !== u2 && "filter" !== u2 && "metadata" !== u2 && "minzoom" !== u2 && "maxzoom" !== u2 && (0 === u2.indexOf("paint.") ? Vt(s2[u2], l2[u2], o3, n3, u2.slice(6), Ut.setPaintProperty) : t.deepEqual(s2[u2], l2[u2]) || o3.push({ command: Ut.setLayerProperty, args: [n3, u2, l2[u2]] }));
                  } else
                    o3.push({ command: Ut.removeLayer, args: [n3] }), c2 = f2[f2.lastIndexOf(n3) + 1], o3.push({ command: Ut.addLayer, args: [l2, c2] });
            }(n2, i2.layers, o2);
          } catch (t2) {
            console.warn("Unable to compute style diff:", t2), o2 = [{ command: Ut.setStyle, args: [i2] }];
          }
          return o2;
        }
        var Ht = function(t2, e2, i2) {
          var o2 = this.boxCells = [], r2 = this.circleCells = [];
          this.xCellCount = Math.ceil(t2 / i2), this.yCellCount = Math.ceil(e2 / i2);
          for (var a2 = 0; a2 < this.xCellCount * this.yCellCount; a2++)
            o2.push([]), r2.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t2, this.height = e2, this.xScale = this.xCellCount / t2, this.yScale = this.yCellCount / e2, this.boxUid = 0, this.circleUid = 0;
        };
        function Kt(e2, i2, o2, r2, a2) {
          var n2 = t.create();
          return i2 ? (t.scale(n2, n2, [1 / a2, 1 / a2, 1]), o2 || t.rotateZ(n2, n2, r2.angle)) : t.multiply(n2, r2.labelPlaneMatrix, e2), n2;
        }
        function Yt(e2, i2, o2, r2, a2) {
          if (i2) {
            var n2 = t.clone(e2);
            return t.scale(n2, n2, [a2, a2, 1]), o2 || t.rotateZ(n2, n2, -r2.angle), n2;
          }
          return r2.glCoordMatrix;
        }
        function Jt(e2, i2) {
          var o2 = [e2.x, e2.y, 0, 1];
          se(o2, o2, i2);
          var r2 = o2[3];
          return { point: new t.Point(o2[0] / r2, o2[1] / r2), signedDistanceFromCamera: r2 };
        }
        function Qt(t2, e2) {
          var i2 = t2[0] / t2[3], o2 = t2[1] / t2[3];
          return i2 >= -e2[0] && i2 <= e2[0] && o2 >= -e2[1] && o2 <= e2[1];
        }
        function $t(e2, i2, o2, r2, a2, n2, s2, l2) {
          var c2 = r2 ? e2.textSizeData : e2.iconSizeData, u2 = t.evaluateSizeForZoom(c2, o2.transform.zoom), h2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], p2 = r2 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
          p2.clear();
          for (var d2 = e2.lineVertexArray, _2 = r2 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, f2 = o2.transform.width / o2.transform.height, m2 = false, g2 = 0; g2 < _2.length; g2++) {
            var v2 = _2.get(g2);
            if (v2.hidden || v2.writingMode === t.WritingMode.vertical && !m2)
              ne(v2.numGlyphs, p2);
            else {
              m2 = false;
              var y2 = [v2.anchorX, v2.anchorY, 0, 1];
              if (t.transformMat4(y2, y2, i2), Qt(y2, h2)) {
                var x2 = 0.5 + y2[3] / o2.transform.cameraToCenterDistance * 0.5, b2 = t.evaluateSizeForFeature(c2, u2, v2), w2 = s2 ? b2 * x2 : b2 / x2, E2 = new t.Point(v2.anchorX, v2.anchorY), T2 = Jt(E2, a2).point, I2 = {}, S2 = ie(v2, w2, false, l2, i2, a2, n2, e2.glyphOffsetArray, d2, p2, T2, E2, I2, f2);
                m2 = S2.useVertical, (S2.notEnoughRoom || m2 || S2.needsFlipping && ie(v2, w2, true, l2, i2, a2, n2, e2.glyphOffsetArray, d2, p2, T2, E2, I2, f2).notEnoughRoom) && ne(v2.numGlyphs, p2);
              } else
                ne(v2.numGlyphs, p2);
            }
          }
          r2 ? e2.text.dynamicLayoutVertexBuffer.updateData(p2) : e2.icon.dynamicLayoutVertexBuffer.updateData(p2);
        }
        function te(t2, e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2) {
          var p2 = s2.glyphStartIndex + s2.numGlyphs, d2 = s2.lineStartIndex, _2 = s2.lineStartIndex + s2.lineLength, f2 = e2.getoffsetX(s2.glyphStartIndex), m2 = e2.getoffsetX(p2 - 1), g2 = re(t2 * f2, i2, o2, r2, a2, n2, s2.segment, d2, _2, l2, c2, u2, h2);
          if (!g2)
            return null;
          var v2 = re(t2 * m2, i2, o2, r2, a2, n2, s2.segment, d2, _2, l2, c2, u2, h2);
          return v2 ? { first: g2, last: v2 } : null;
        }
        function ee(e2, i2, o2, r2) {
          if (e2 === t.WritingMode.horizontal && Math.abs(o2.y - i2.y) > Math.abs(o2.x - i2.x) * r2)
            return { useVertical: true };
          return (e2 === t.WritingMode.vertical ? i2.y < o2.y : i2.x > o2.x) ? { needsFlipping: true } : null;
        }
        function ie(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2, d2, _2) {
          var f2, m2 = i2 / 24, g2 = e2.lineOffsetX * m2, v2 = e2.lineOffsetY * m2;
          if (e2.numGlyphs > 1) {
            var y2 = e2.glyphStartIndex + e2.numGlyphs, x2 = e2.lineStartIndex, b2 = e2.lineStartIndex + e2.lineLength, w2 = te(m2, l2, g2, v2, o2, h2, p2, e2, c2, n2, d2, false);
            if (!w2)
              return { notEnoughRoom: true };
            var E2 = Jt(w2.first.point, s2).point, T2 = Jt(w2.last.point, s2).point;
            if (r2 && !o2) {
              var I2 = ee(e2.writingMode, E2, T2, _2);
              if (I2)
                return I2;
            }
            f2 = [w2.first];
            for (var S2 = e2.glyphStartIndex + 1; S2 < y2 - 1; S2++)
              f2.push(re(m2 * l2.getoffsetX(S2), g2, v2, o2, h2, p2, e2.segment, x2, b2, c2, n2, d2, false));
            f2.push(w2.last);
          } else {
            if (r2 && !o2) {
              var C2 = Jt(p2, a2).point, P2 = e2.lineStartIndex + e2.segment + 1, z2 = new t.Point(c2.getx(P2), c2.gety(P2)), M2 = Jt(z2, a2), L2 = M2.signedDistanceFromCamera > 0 ? M2.point : oe(p2, z2, C2, 1, a2), D2 = ee(e2.writingMode, C2, L2, _2);
              if (D2)
                return D2;
            }
            var A2 = re(m2 * l2.getoffsetX(e2.glyphStartIndex), g2, v2, o2, h2, p2, e2.segment, e2.lineStartIndex, e2.lineStartIndex + e2.lineLength, c2, n2, d2, false);
            if (!A2)
              return { notEnoughRoom: true };
            f2 = [A2];
          }
          for (var R2 = 0, k2 = f2; R2 < k2.length; R2 += 1) {
            var B2 = k2[R2];
            t.addDynamicAttributes(u2, B2.point, B2.angle);
          }
          return {};
        }
        function oe(t2, e2, i2, o2, r2) {
          var a2 = Jt(t2.add(t2.sub(e2)._unit()), r2).point, n2 = i2.sub(a2);
          return i2.add(n2._mult(o2 / n2.mag()));
        }
        function re(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2, d2) {
          var _2 = r2 ? e2 - i2 : e2 + i2, f2 = _2 > 0 ? 1 : -1, m2 = 0;
          r2 && (f2 *= -1, m2 = Math.PI), f2 < 0 && (m2 += Math.PI);
          for (var g2 = f2 > 0 ? l2 + s2 : l2 + s2 + 1, v2 = g2, y2 = a2, x2 = a2, b2 = 0, w2 = 0, E2 = Math.abs(_2); b2 + w2 <= E2; ) {
            if ((g2 += f2) < l2 || g2 >= c2)
              return null;
            if (x2 = y2, void 0 === (y2 = p2[g2])) {
              var T2 = new t.Point(u2.getx(g2), u2.gety(g2)), I2 = Jt(T2, h2);
              if (I2.signedDistanceFromCamera > 0)
                y2 = p2[g2] = I2.point;
              else {
                var S2 = g2 - f2;
                y2 = oe(0 === b2 ? n2 : new t.Point(u2.getx(S2), u2.gety(S2)), T2, x2, E2 - b2 + 1, h2);
              }
            }
            b2 += w2, w2 = x2.dist(y2);
          }
          var C2 = (E2 - b2) / w2, P2 = y2.sub(x2), z2 = P2.mult(C2)._add(x2);
          return z2._add(P2._unit()._perp()._mult(o2 * f2)), { point: z2, angle: m2 + Math.atan2(y2.y - x2.y, y2.x - x2.x), tileDistance: d2 ? { prevTileDistance: g2 - f2 === v2 ? 0 : u2.gettileUnitDistanceFromAnchor(g2 - f2), lastSegmentViewportDistance: E2 - b2 } : null };
        }
        Ht.prototype.keysLength = function() {
          return this.boxKeys.length + this.circleKeys.length;
        }, Ht.prototype.insert = function(t2, e2, i2, o2, r2) {
          this._forEachCell(e2, i2, o2, r2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t2), this.bboxes.push(e2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(r2);
        }, Ht.prototype.insertCircle = function(t2, e2, i2, o2) {
          this._forEachCell(e2 - o2, i2 - o2, e2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t2), this.circles.push(e2), this.circles.push(i2), this.circles.push(o2);
        }, Ht.prototype._insertBoxCell = function(t2, e2, i2, o2, r2, a2) {
          this.boxCells[r2].push(a2);
        }, Ht.prototype._insertCircleCell = function(t2, e2, i2, o2, r2, a2) {
          this.circleCells[r2].push(a2);
        }, Ht.prototype._query = function(t2, e2, i2, o2, r2, a2) {
          if (i2 < 0 || t2 > this.width || o2 < 0 || e2 > this.height)
            return !r2 && [];
          var n2 = [];
          if (t2 <= 0 && e2 <= 0 && this.width <= i2 && this.height <= o2) {
            if (r2)
              return true;
            for (var s2 = 0; s2 < this.boxKeys.length; s2++)
              n2.push({ key: this.boxKeys[s2], x1: this.bboxes[4 * s2], y1: this.bboxes[4 * s2 + 1], x2: this.bboxes[4 * s2 + 2], y2: this.bboxes[4 * s2 + 3] });
            for (var l2 = 0; l2 < this.circleKeys.length; l2++) {
              var c2 = this.circles[3 * l2], u2 = this.circles[3 * l2 + 1], h2 = this.circles[3 * l2 + 2];
              n2.push({ key: this.circleKeys[l2], x1: c2 - h2, y1: u2 - h2, x2: c2 + h2, y2: u2 + h2 });
            }
            return a2 ? n2.filter(a2) : n2;
          }
          var p2 = { hitTest: r2, seenUids: { box: {}, circle: {} } };
          return this._forEachCell(t2, e2, i2, o2, this._queryCell, n2, p2, a2), r2 ? n2.length > 0 : n2;
        }, Ht.prototype._queryCircle = function(t2, e2, i2, o2, r2) {
          var a2 = t2 - i2, n2 = t2 + i2, s2 = e2 - i2, l2 = e2 + i2;
          if (n2 < 0 || a2 > this.width || l2 < 0 || s2 > this.height)
            return !o2 && [];
          var c2 = [], u2 = { hitTest: o2, circle: { x: t2, y: e2, radius: i2 }, seenUids: { box: {}, circle: {} } };
          return this._forEachCell(a2, s2, n2, l2, this._queryCellCircle, c2, u2, r2), o2 ? c2.length > 0 : c2;
        }, Ht.prototype.query = function(t2, e2, i2, o2, r2) {
          return this._query(t2, e2, i2, o2, false, r2);
        }, Ht.prototype.hitTest = function(t2, e2, i2, o2, r2) {
          return this._query(t2, e2, i2, o2, true, r2);
        }, Ht.prototype.hitTestCircle = function(t2, e2, i2, o2) {
          return this._queryCircle(t2, e2, i2, true, o2);
        }, Ht.prototype._queryCell = function(t2, e2, i2, o2, r2, a2, n2, s2) {
          var l2 = n2.seenUids, c2 = this.boxCells[r2];
          if (null !== c2)
            for (var u2 = this.bboxes, h2 = 0, p2 = c2; h2 < p2.length; h2 += 1) {
              var d2 = p2[h2];
              if (!l2.box[d2]) {
                l2.box[d2] = true;
                var _2 = 4 * d2;
                if (t2 <= u2[_2 + 2] && e2 <= u2[_2 + 3] && i2 >= u2[_2 + 0] && o2 >= u2[_2 + 1] && (!s2 || s2(this.boxKeys[d2]))) {
                  if (n2.hitTest)
                    return a2.push(true), true;
                  a2.push({ key: this.boxKeys[d2], x1: u2[_2], y1: u2[_2 + 1], x2: u2[_2 + 2], y2: u2[_2 + 3] });
                }
              }
            }
          var f2 = this.circleCells[r2];
          if (null !== f2)
            for (var m2 = this.circles, g2 = 0, v2 = f2; g2 < v2.length; g2 += 1) {
              var y2 = v2[g2];
              if (!l2.circle[y2]) {
                l2.circle[y2] = true;
                var x2 = 3 * y2;
                if (this._circleAndRectCollide(m2[x2], m2[x2 + 1], m2[x2 + 2], t2, e2, i2, o2) && (!s2 || s2(this.circleKeys[y2]))) {
                  if (n2.hitTest)
                    return a2.push(true), true;
                  var b2 = m2[x2], w2 = m2[x2 + 1], E2 = m2[x2 + 2];
                  a2.push({ key: this.circleKeys[y2], x1: b2 - E2, y1: w2 - E2, x2: b2 + E2, y2: w2 + E2 });
                }
              }
            }
        }, Ht.prototype._queryCellCircle = function(t2, e2, i2, o2, r2, a2, n2, s2) {
          var l2 = n2.circle, c2 = n2.seenUids, u2 = this.boxCells[r2];
          if (null !== u2)
            for (var h2 = this.bboxes, p2 = 0, d2 = u2; p2 < d2.length; p2 += 1) {
              var _2 = d2[p2];
              if (!c2.box[_2]) {
                c2.box[_2] = true;
                var f2 = 4 * _2;
                if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, h2[f2 + 0], h2[f2 + 1], h2[f2 + 2], h2[f2 + 3]) && (!s2 || s2(this.boxKeys[_2])))
                  return a2.push(true), true;
              }
            }
          var m2 = this.circleCells[r2];
          if (null !== m2)
            for (var g2 = this.circles, v2 = 0, y2 = m2; v2 < y2.length; v2 += 1) {
              var x2 = y2[v2];
              if (!c2.circle[x2]) {
                c2.circle[x2] = true;
                var b2 = 3 * x2;
                if (this._circlesCollide(g2[b2], g2[b2 + 1], g2[b2 + 2], l2.x, l2.y, l2.radius) && (!s2 || s2(this.circleKeys[x2])))
                  return a2.push(true), true;
              }
            }
        }, Ht.prototype._forEachCell = function(t2, e2, i2, o2, r2, a2, n2, s2) {
          for (var l2 = this._convertToXCellCoord(t2), c2 = this._convertToYCellCoord(e2), u2 = this._convertToXCellCoord(i2), h2 = this._convertToYCellCoord(o2), p2 = l2; p2 <= u2; p2++)
            for (var d2 = c2; d2 <= h2; d2++) {
              var _2 = this.xCellCount * d2 + p2;
              if (r2.call(this, t2, e2, i2, o2, _2, a2, n2, s2))
                return;
            }
        }, Ht.prototype._convertToXCellCoord = function(t2) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t2 * this.xScale)));
        }, Ht.prototype._convertToYCellCoord = function(t2) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t2 * this.yScale)));
        }, Ht.prototype._circlesCollide = function(t2, e2, i2, o2, r2, a2) {
          var n2 = o2 - t2, s2 = r2 - e2, l2 = i2 + a2;
          return l2 * l2 > n2 * n2 + s2 * s2;
        }, Ht.prototype._circleAndRectCollide = function(t2, e2, i2, o2, r2, a2, n2) {
          var s2 = (a2 - o2) / 2, l2 = Math.abs(t2 - (o2 + s2));
          if (l2 > s2 + i2)
            return false;
          var c2 = (n2 - r2) / 2, u2 = Math.abs(e2 - (r2 + c2));
          if (u2 > c2 + i2)
            return false;
          if (l2 <= s2 || u2 <= c2)
            return true;
          var h2 = l2 - s2, p2 = u2 - c2;
          return h2 * h2 + p2 * p2 <= i2 * i2;
        };
        var ae = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function ne(t2, e2) {
          for (var i2 = 0; i2 < t2; i2++) {
            var o2 = e2.length;
            e2.resize(o2 + 4), e2.float32.set(ae, 3 * o2);
          }
        }
        function se(t2, e2, i2) {
          var o2 = e2[0], r2 = e2[1];
          return t2[0] = i2[0] * o2 + i2[4] * r2 + i2[12], t2[1] = i2[1] * o2 + i2[5] * r2 + i2[13], t2[3] = i2[3] * o2 + i2[7] * r2 + i2[15], t2;
        }
        var le = function(t2, e2, i2) {
          void 0 === e2 && (e2 = new Ht(t2.width + 200, t2.height + 200, 25)), void 0 === i2 && (i2 = new Ht(t2.width + 200, t2.height + 200, 25)), this.transform = t2, this.grid = e2, this.ignoredGrid = i2, this.pitchfactor = Math.cos(t2._pitch) * t2.cameraToCenterDistance, this.screenRightBoundary = t2.width + 100, this.screenBottomBoundary = t2.height + 100, this.gridRightBoundary = t2.width + 200, this.gridBottomBoundary = t2.height + 200;
        };
        function ce(t2, e2, i2) {
          t2[e2 + 4] = i2 ? 1 : 0;
        }
        function ue(e2, i2, o2) {
          return i2 * (t.EXTENT / (e2.tileSize * Math.pow(2, o2 - e2.tileID.overscaledZ)));
        }
        le.prototype.placeCollisionBox = function(t2, e2, i2, o2, r2) {
          var a2 = this.projectAndGetPerspectiveRatio(o2, t2.anchorPointX, t2.anchorPointY), n2 = i2 * a2.perspectiveRatio, s2 = t2.x1 * n2 + a2.point.x, l2 = t2.y1 * n2 + a2.point.y, c2 = t2.x2 * n2 + a2.point.x, u2 = t2.y2 * n2 + a2.point.y;
          return !this.isInsideGrid(s2, l2, c2, u2) || !e2 && this.grid.hitTest(s2, l2, c2, u2, r2) ? { box: [], offscreen: false } : { box: [s2, l2, c2, u2], offscreen: this.isOffscreen(s2, l2, c2, u2) };
        }, le.prototype.approximateTileDistance = function(t2, e2, i2, o2, r2) {
          var a2 = r2 ? 1 : o2 / this.pitchfactor, n2 = t2.lastSegmentViewportDistance * i2;
          return t2.prevTileDistance + n2 + (a2 - 1) * n2 * Math.abs(Math.sin(e2));
        }, le.prototype.placeCollisionCircles = function(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2, d2) {
          var _2 = [], f2 = this.projectAnchor(c2, a2.anchorX, a2.anchorY), m2 = l2 / 24, g2 = a2.lineOffsetX * l2, v2 = a2.lineOffsetY * l2, y2 = new t.Point(a2.anchorX, a2.anchorY), x2 = te(m2, s2, g2, v2, false, Jt(y2, u2).point, y2, a2, n2, u2, {}, true), b2 = false, w2 = false, E2 = true, T2 = f2.perspectiveRatio * r2, I2 = 1 / (r2 * o2), S2 = 0, C2 = 0;
          x2 && (S2 = this.approximateTileDistance(x2.first.tileDistance, x2.first.angle, I2, f2.cameraDistance, p2), C2 = this.approximateTileDistance(x2.last.tileDistance, x2.last.angle, I2, f2.cameraDistance, p2));
          for (var P2 = 0; P2 < e2.length; P2 += 5) {
            var z2 = e2[P2], M2 = e2[P2 + 1], L2 = e2[P2 + 2], D2 = e2[P2 + 3];
            if (!x2 || D2 < -S2 || D2 > C2)
              ce(e2, P2, false);
            else {
              var A2 = this.projectPoint(c2, z2, M2), R2 = L2 * T2;
              if (_2.length > 0) {
                var k2 = A2.x - _2[_2.length - 4], B2 = A2.y - _2[_2.length - 3];
                if (R2 * R2 * 2 > k2 * k2 + B2 * B2) {
                  if (P2 + 8 < e2.length) {
                    var O2 = e2[P2 + 8];
                    if (O2 > -S2 && O2 < C2) {
                      ce(e2, P2, false);
                      continue;
                    }
                  }
                }
              }
              var F2 = P2 / 5;
              _2.push(A2.x, A2.y, R2, F2), ce(e2, P2, true);
              var U2 = A2.x - R2, N2 = A2.y - R2, Z2 = A2.x + R2, q2 = A2.y + R2;
              if (E2 = E2 && this.isOffscreen(U2, N2, Z2, q2), w2 = w2 || this.isInsideGrid(U2, N2, Z2, q2), !i2 && this.grid.hitTestCircle(A2.x, A2.y, R2, d2)) {
                if (!h2)
                  return { circles: [], offscreen: false };
                b2 = true;
              }
            }
          }
          return { circles: b2 || !w2 ? [] : _2, offscreen: E2 };
        }, le.prototype.queryRenderedSymbols = function(e2) {
          if (0 === e2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
            return {};
          for (var i2 = [], o2 = 1 / 0, r2 = 1 / 0, a2 = -1 / 0, n2 = -1 / 0, s2 = 0, l2 = e2; s2 < l2.length; s2 += 1) {
            var c2 = l2[s2], u2 = new t.Point(c2.x + 100, c2.y + 100);
            o2 = Math.min(o2, u2.x), r2 = Math.min(r2, u2.y), a2 = Math.max(a2, u2.x), n2 = Math.max(n2, u2.y), i2.push(u2);
          }
          for (var h2 = {}, p2 = {}, d2 = 0, _2 = this.grid.query(o2, r2, a2, n2).concat(this.ignoredGrid.query(o2, r2, a2, n2)); d2 < _2.length; d2 += 1) {
            var f2 = _2[d2], m2 = f2.key;
            if (void 0 === h2[m2.bucketInstanceId] && (h2[m2.bucketInstanceId] = {}), !h2[m2.bucketInstanceId][m2.featureIndex]) {
              var g2 = [new t.Point(f2.x1, f2.y1), new t.Point(f2.x2, f2.y1), new t.Point(f2.x2, f2.y2), new t.Point(f2.x1, f2.y2)];
              t.polygonIntersectsPolygon(i2, g2) && (h2[m2.bucketInstanceId][m2.featureIndex] = true, void 0 === p2[m2.bucketInstanceId] && (p2[m2.bucketInstanceId] = []), p2[m2.bucketInstanceId].push(m2.featureIndex));
            }
          }
          return p2;
        }, le.prototype.insertCollisionBox = function(t2, e2, i2, o2, r2) {
          var a2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 };
          (e2 ? this.ignoredGrid : this.grid).insert(a2, t2[0], t2[1], t2[2], t2[3]);
        }, le.prototype.insertCollisionCircles = function(t2, e2, i2, o2, r2) {
          for (var a2 = e2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 }, s2 = 0; s2 < t2.length; s2 += 4)
            a2.insertCircle(n2, t2[s2], t2[s2 + 1], t2[s2 + 2]);
        }, le.prototype.projectAnchor = function(t2, e2, i2) {
          var o2 = [e2, i2, 0, 1];
          return se(o2, o2, t2), { perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / o2[3] * 0.5, cameraDistance: o2[3] };
        }, le.prototype.projectPoint = function(e2, i2, o2) {
          var r2 = [i2, o2, 0, 1];
          return se(r2, r2, e2), new t.Point((r2[0] / r2[3] + 1) / 2 * this.transform.width + 100, (-r2[1] / r2[3] + 1) / 2 * this.transform.height + 100);
        }, le.prototype.projectAndGetPerspectiveRatio = function(e2, i2, o2) {
          var r2 = [i2, o2, 0, 1];
          return se(r2, r2, e2), { point: new t.Point((r2[0] / r2[3] + 1) / 2 * this.transform.width + 100, (-r2[1] / r2[3] + 1) / 2 * this.transform.height + 100), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / r2[3] * 0.5 };
        }, le.prototype.isOffscreen = function(t2, e2, i2, o2) {
          return i2 < 100 || t2 >= this.screenRightBoundary || o2 < 100 || e2 > this.screenBottomBoundary;
        }, le.prototype.isInsideGrid = function(t2, e2, i2, o2) {
          return i2 >= 0 && t2 < this.gridRightBoundary && o2 >= 0 && e2 < this.gridBottomBoundary;
        };
        var he = function(t2, e2, i2, o2) {
          this.opacity = t2 ? Math.max(0, Math.min(1, t2.opacity + (t2.placed ? e2 : -e2))) : o2 && i2 ? 1 : 0, this.placed = i2;
        };
        he.prototype.isHidden = function() {
          return 0 === this.opacity && !this.placed;
        };
        var pe = function(t2, e2, i2, o2, r2) {
          this.text = new he(t2 ? t2.text : null, e2, i2, r2), this.icon = new he(t2 ? t2.icon : null, e2, o2, r2);
        };
        pe.prototype.isHidden = function() {
          return this.text.isHidden() && this.icon.isHidden();
        };
        var de = function(t2, e2, i2) {
          this.text = t2, this.icon = e2, this.skipFade = i2;
        }, _e = function(t2, e2, i2, o2, r2) {
          this.bucketInstanceId = t2, this.featureIndex = e2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = r2;
        }, fe = function(t2) {
          this.crossSourceCollisions = t2, this.maxGroupID = 0, this.collisionGroups = {};
        };
        function me(e2, i2, o2, r2, a2) {
          var n2 = t.getAnchorAlignment(e2), s2 = -(n2.horizontalAlign - 0.5) * i2, l2 = -(n2.verticalAlign - 0.5) * o2, c2 = t.evaluateVariableOffset(e2, r2);
          return new t.Point(s2 + c2[0] * a2, l2 + c2[1] * a2);
        }
        function ge(e2, i2, o2, r2, a2, n2) {
          var s2 = e2.x1, l2 = e2.x2, c2 = e2.y1, u2 = e2.y2, h2 = e2.anchorPointX, p2 = e2.anchorPointY, d2 = new t.Point(i2, o2);
          return r2 && d2._rotate(a2 ? n2 : -n2), { x1: s2 + d2.x, y1: c2 + d2.y, x2: l2 + d2.x, y2: u2 + d2.y, anchorPointX: h2, anchorPointY: p2 };
        }
        fe.prototype.get = function(t2) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[t2]) {
            var e2 = ++this.maxGroupID;
            this.collisionGroups[t2] = { ID: e2, predicate: function(t3) {
              return t3.collisionGroupID === e2;
            } };
          }
          return this.collisionGroups[t2];
        };
        var ve = function(t2, e2, i2, o2) {
          this.transform = t2.clone(), this.collisionIndex = new le(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = e2, this.retainedQueryData = {}, this.collisionGroups = new fe(i2), this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
        };
        function ye(t2, e2, i2, o2, r2) {
          t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0);
        }
        ve.prototype.placeLayerTile = function(e2, i2, o2, r2) {
          var a2 = i2.getBucket(e2), n2 = i2.latestFeatureIndex;
          if (a2 && n2 && e2.id === a2.layerIds[0]) {
            var s2 = i2.collisionBoxArray, l2 = a2.layers[0].layout, c2 = Math.pow(2, this.transform.zoom - i2.tileID.overscaledZ), u2 = i2.tileSize / t.EXTENT, h2 = this.transform.calculatePosMatrix(i2.tileID.toUnwrapped()), p2 = Kt(h2, "map" === l2.get("text-pitch-alignment"), "map" === l2.get("text-rotation-alignment"), this.transform, ue(i2, 1, this.transform.zoom)), d2 = Kt(h2, "map" === l2.get("icon-pitch-alignment"), "map" === l2.get("icon-rotation-alignment"), this.transform, ue(i2, 1, this.transform.zoom));
            this.retainedQueryData[a2.bucketInstanceId] = new _e(a2.bucketInstanceId, n2, a2.sourceLayerIndex, a2.index, i2.tileID), this.placeLayerBucket(a2, h2, p2, d2, c2, u2, o2, i2.holdingForFade(), r2, s2);
          }
        }, ve.prototype.attemptAnchorPlacement = function(t2, e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2, d2, _2) {
          var f2, m2 = [h2.textOffset0, h2.textOffset1], g2 = me(t2, i2, o2, m2, r2), v2 = this.collisionIndex.placeCollisionBox(ge(e2, g2.x, g2.y, a2, n2, this.transform.angle), u2, s2, l2, c2.predicate);
          if (_2 && 0 === this.collisionIndex.placeCollisionBox(ge(_2, g2.x, g2.y, a2, n2, this.transform.angle), u2, s2, l2, c2.predicate).box.length)
            return;
          if (v2.box.length > 0)
            return this.prevPlacement && this.prevPlacement.variableOffsets[h2.crossTileID] && this.prevPlacement.placements[h2.crossTileID] && this.prevPlacement.placements[h2.crossTileID].text && (f2 = this.prevPlacement.variableOffsets[h2.crossTileID].anchor), this.variableOffsets[h2.crossTileID] = { textOffset: m2, width: i2, height: o2, anchor: t2, textBoxScale: r2, prevAnchor: f2 }, this.markUsedJustification(p2, t2, h2, d2), p2.allowVerticalPlacement && (this.markUsedOrientation(p2, d2, h2), this.placedOrientations[h2.crossTileID] = d2), { shift: g2, placedGlyphBoxes: v2 };
        }, ve.prototype.placeLayerBucket = function(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2) {
          var h2 = this, p2 = e2.layers[0].layout, d2 = t.evaluateSizeForZoom(e2.textSizeData, this.transform.zoom), _2 = p2.get("text-optional"), f2 = p2.get("icon-optional"), m2 = p2.get("text-allow-overlap"), g2 = p2.get("icon-allow-overlap"), v2 = m2 && (g2 || !e2.hasIconData() || f2), y2 = g2 && (m2 || !e2.hasTextData() || _2), x2 = this.collisionGroups.get(e2.sourceID), b2 = "map" === p2.get("text-rotation-alignment"), w2 = "map" === p2.get("text-pitch-alignment"), E2 = "none" !== p2.get("icon-text-fit"), T2 = "viewport-y" === p2.get("symbol-z-order");
          !e2.collisionArrays && u2 && e2.deserializeCollisionBoxes(u2);
          var I2 = function(r3, u3) {
            if (!c2[r3.crossTileID])
              if (l2)
                h2.placements[r3.crossTileID] = new de(false, false, false);
              else {
                var T3, I3 = false, S3 = false, C3 = true, P3 = null, z3 = { box: null, offscreen: null }, M2 = { box: null, offscreen: null }, L2 = null, D2 = null, A2 = 0, R2 = 0, k2 = 0;
                u3.textFeatureIndex && (A2 = u3.textFeatureIndex), u3.verticalTextFeatureIndex && (R2 = u3.verticalTextFeatureIndex);
                var B2 = u3.textBox;
                if (B2) {
                  var O2 = function(i3) {
                    var o3 = t.WritingMode.horizontal;
                    if (e2.allowVerticalPlacement && !i3 && h2.prevPlacement) {
                      var a3 = h2.prevPlacement.placedOrientations[r3.crossTileID];
                      a3 && (h2.placedOrientations[r3.crossTileID] = a3, o3 = a3, h2.markUsedOrientation(e2, o3, r3));
                    }
                    return o3;
                  }, F2 = function(i3, o3) {
                    if (e2.allowVerticalPlacement && r3.numVerticalGlyphVertices > 0 && u3.verticalTextBox)
                      for (var a3 = 0, n3 = e2.writingModes; a3 < n3.length; a3 += 1) {
                        if (n3[a3] === t.WritingMode.vertical ? (z3 = o3(), M2 = z3) : z3 = i3(), z3 && z3.box && z3.box.length)
                          break;
                      }
                    else
                      z3 = i3();
                  };
                  if (p2.get("text-variable-anchor")) {
                    var U2 = p2.get("text-variable-anchor");
                    if (h2.prevPlacement && h2.prevPlacement.variableOffsets[r3.crossTileID]) {
                      var N2 = h2.prevPlacement.variableOffsets[r3.crossTileID];
                      U2.indexOf(N2.anchor) > 0 && (U2 = U2.filter(function(t2) {
                        return t2 !== N2.anchor;
                      })).unshift(N2.anchor);
                    }
                    var Z2 = function(t2, o3, a3) {
                      for (var s3 = t2.x2 - t2.x1, l3 = t2.y2 - t2.y1, c3 = r3.textBoxScale, u4 = E2 && !g2 ? o3 : null, p3 = { box: [], offscreen: false }, d3 = m2 ? 2 * U2.length : U2.length, _3 = 0; _3 < d3; ++_3) {
                        var f3 = U2[_3 % U2.length], v3 = _3 >= U2.length, y3 = h2.attemptAnchorPlacement(f3, t2, s3, l3, c3, b2, w2, n2, i2, x2, v3, r3, e2, a3, u4);
                        if (y3 && (p3 = y3.placedGlyphBoxes) && p3.box && p3.box.length) {
                          I3 = true, P3 = y3.shift;
                          break;
                        }
                      }
                      return p3;
                    };
                    F2(function() {
                      return Z2(B2, u3.iconBox, t.WritingMode.horizontal);
                    }, function() {
                      var i3 = u3.verticalTextBox, o3 = z3 && z3.box && z3.box.length;
                      return e2.allowVerticalPlacement && !o3 && r3.numVerticalGlyphVertices > 0 && i3 ? Z2(i3, u3.verticalIconBox, t.WritingMode.vertical) : { box: null, offscreen: null };
                    }), z3 && (I3 = z3.box, C3 = z3.offscreen);
                    var q2 = O2(z3 && z3.box);
                    if (!I3 && h2.prevPlacement) {
                      var j2 = h2.prevPlacement.variableOffsets[r3.crossTileID];
                      j2 && (h2.variableOffsets[r3.crossTileID] = j2, h2.markUsedJustification(e2, j2.anchor, r3, q2));
                    }
                  } else {
                    var V2 = function(t2, o3) {
                      var a3 = h2.collisionIndex.placeCollisionBox(t2, p2.get("text-allow-overlap"), n2, i2, x2.predicate);
                      return a3 && a3.box && a3.box.length && (h2.markUsedOrientation(e2, o3, r3), h2.placedOrientations[r3.crossTileID] = o3), a3;
                    };
                    F2(function() {
                      return V2(B2, t.WritingMode.horizontal);
                    }, function() {
                      var i3 = u3.verticalTextBox;
                      return e2.allowVerticalPlacement && r3.numVerticalGlyphVertices > 0 && i3 ? V2(i3, t.WritingMode.vertical) : { box: null, offscreen: null };
                    }), O2(z3 && z3.box && z3.box.length);
                  }
                }
                I3 = (T3 = z3) && T3.box && T3.box.length > 0, C3 = T3 && T3.offscreen;
                var G2 = u3.textCircles;
                if (G2) {
                  var W2 = e2.text.placedSymbolArray.get(r3.centerJustifiedTextSymbolIndex), X2 = t.evaluateSizeForFeature(e2.textSizeData, d2, W2);
                  L2 = h2.collisionIndex.placeCollisionCircles(G2, p2.get("text-allow-overlap"), a2, n2, W2, e2.lineVertexArray, e2.glyphOffsetArray, X2, i2, o2, s2, w2, x2.predicate), I3 = p2.get("text-allow-overlap") || L2.circles.length > 0, C3 = C3 && L2.offscreen;
                }
                if (u3.iconFeatureIndex && (k2 = u3.iconFeatureIndex), u3.iconBox) {
                  var H2 = function(t2) {
                    var e3 = E2 && P3 ? ge(t2, P3.x, P3.y, b2, w2, h2.transform.angle) : t2;
                    return h2.collisionIndex.placeCollisionBox(e3, p2.get("icon-allow-overlap"), n2, i2, x2.predicate);
                  };
                  S3 = M2 && M2.box && M2.box.length && u3.verticalIconBox ? (D2 = H2(u3.verticalIconBox)).box.length > 0 : (D2 = H2(u3.iconBox)).box.length > 0, C3 = C3 && D2.offscreen;
                }
                var K2 = _2 || 0 === r3.numHorizontalGlyphVertices && 0 === r3.numVerticalGlyphVertices, Y2 = f2 || 0 === r3.numIconVertices;
                K2 || Y2 ? Y2 ? K2 || (S3 = S3 && I3) : I3 = S3 && I3 : S3 = I3 = S3 && I3, I3 && T3 && T3.box && (M2 && M2.box && R2 ? h2.collisionIndex.insertCollisionBox(T3.box, p2.get("text-ignore-placement"), e2.bucketInstanceId, R2, x2.ID) : h2.collisionIndex.insertCollisionBox(T3.box, p2.get("text-ignore-placement"), e2.bucketInstanceId, A2, x2.ID)), S3 && D2 && h2.collisionIndex.insertCollisionBox(D2.box, p2.get("icon-ignore-placement"), e2.bucketInstanceId, k2, x2.ID), I3 && L2 && h2.collisionIndex.insertCollisionCircles(L2.circles, p2.get("text-ignore-placement"), e2.bucketInstanceId, A2, x2.ID), h2.placements[r3.crossTileID] = new de(I3 || v2, S3 || y2, C3 || e2.justReloaded), c2[r3.crossTileID] = true;
              }
          };
          if (T2)
            for (var S2 = e2.getSortedSymbolIndexes(this.transform.angle), C2 = S2.length - 1; C2 >= 0; --C2) {
              var P2 = S2[C2];
              I2(e2.symbolInstances.get(P2), e2.collisionArrays[P2]);
            }
          else
            for (var z2 = 0; z2 < e2.symbolInstances.length; ++z2)
              I2(e2.symbolInstances.get(z2), e2.collisionArrays[z2]);
          e2.justReloaded = false;
        }, ve.prototype.markUsedJustification = function(e2, i2, o2, r2) {
          var a2, n2 = { left: o2.leftJustifiedTextSymbolIndex, center: o2.centerJustifiedTextSymbolIndex, right: o2.rightJustifiedTextSymbolIndex };
          a2 = r2 === t.WritingMode.vertical ? o2.verticalPlacedTextSymbolIndex : n2[t.getAnchorJustification(i2)];
          for (var s2 = 0, l2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex, o2.verticalPlacedTextSymbolIndex]; s2 < l2.length; s2 += 1) {
            var c2 = l2[s2];
            c2 >= 0 && (e2.text.placedSymbolArray.get(c2).crossTileID = a2 >= 0 && c2 !== a2 ? 0 : o2.crossTileID);
          }
        }, ve.prototype.markUsedOrientation = function(e2, i2, o2) {
          for (var r2 = i2 === t.WritingMode.horizontal || i2 === t.WritingMode.horizontalOnly ? i2 : 0, a2 = i2 === t.WritingMode.vertical ? i2 : 0, n2 = 0, s2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex]; n2 < s2.length; n2 += 1) {
            var l2 = s2[n2];
            e2.text.placedSymbolArray.get(l2).placedOrientation = r2;
          }
          o2.verticalPlacedTextSymbolIndex && (e2.text.placedSymbolArray.get(o2.verticalPlacedTextSymbolIndex).placedOrientation = a2);
        }, ve.prototype.commit = function(t2) {
          this.commitTime = t2, this.zoomAtLastRecencyCheck = this.transform.zoom;
          var e2 = this.prevPlacement, i2 = false;
          this.prevZoomAdjustment = e2 ? e2.zoomAdjustment(this.transform.zoom) : 0;
          var o2 = e2 ? e2.symbolFadeChange(t2) : 1, r2 = e2 ? e2.opacities : {}, a2 = e2 ? e2.variableOffsets : {}, n2 = e2 ? e2.placedOrientations : {};
          for (var s2 in this.placements) {
            var l2 = this.placements[s2], c2 = r2[s2];
            c2 ? (this.opacities[s2] = new pe(c2, o2, l2.text, l2.icon), i2 = i2 || l2.text !== c2.text.placed || l2.icon !== c2.icon.placed) : (this.opacities[s2] = new pe(null, o2, l2.text, l2.icon, l2.skipFade), i2 = i2 || l2.text || l2.icon);
          }
          for (var u2 in r2) {
            var h2 = r2[u2];
            if (!this.opacities[u2]) {
              var p2 = new pe(h2, o2, false, false);
              p2.isHidden() || (this.opacities[u2] = p2, i2 = i2 || h2.text.placed || h2.icon.placed);
            }
          }
          for (var d2 in a2)
            this.variableOffsets[d2] || !this.opacities[d2] || this.opacities[d2].isHidden() || (this.variableOffsets[d2] = a2[d2]);
          for (var _2 in n2)
            this.placedOrientations[_2] || !this.opacities[_2] || this.opacities[_2].isHidden() || (this.placedOrientations[_2] = n2[_2]);
          i2 ? this.lastPlacementChangeTime = t2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e2 ? e2.lastPlacementChangeTime : t2);
        }, ve.prototype.updateLayerOpacities = function(t2, e2) {
          for (var i2 = {}, o2 = 0, r2 = e2; o2 < r2.length; o2 += 1) {
            var a2 = r2[o2], n2 = a2.getBucket(t2);
            n2 && a2.latestFeatureIndex && t2.id === n2.layerIds[0] && this.updateBucketOpacities(n2, i2, a2.collisionBoxArray);
          }
        }, ve.prototype.updateBucketOpacities = function(e2, i2, o2) {
          var r2 = this;
          e2.hasTextData() && e2.text.opacityVertexArray.clear(), e2.hasIconData() && e2.icon.opacityVertexArray.clear(), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear(), e2.hasIconCollisionCircleData() && e2.iconCollisionCircle.collisionVertexArray.clear(), e2.hasTextCollisionCircleData() && e2.textCollisionCircle.collisionVertexArray.clear();
          var a2 = e2.layers[0].layout, n2 = new pe(null, 0, false, false, true), s2 = a2.get("text-allow-overlap"), l2 = a2.get("icon-allow-overlap"), c2 = a2.get("text-variable-anchor"), u2 = "map" === a2.get("text-rotation-alignment"), h2 = "map" === a2.get("text-pitch-alignment"), p2 = "none" !== a2.get("icon-text-fit"), d2 = new pe(null, 0, s2 && (l2 || !e2.hasIconData() || a2.get("icon-optional")), l2 && (s2 || !e2.hasTextData() || a2.get("text-optional")), true);
          !e2.collisionArrays && o2 && (e2.hasIconCollisionBoxData() || e2.hasIconCollisionCircleData() || e2.hasTextCollisionBoxData() || e2.hasTextCollisionCircleData()) && e2.deserializeCollisionBoxes(o2);
          for (var _2 = function(t2, e3, i3) {
            for (var o3 = 0; o3 < e3 / 4; o3++)
              t2.opacityVertexArray.emplaceBack(i3);
          }, f2 = function(o3) {
            var a3 = e2.symbolInstances.get(o3), s3 = a3.numHorizontalGlyphVertices, l3 = a3.numVerticalGlyphVertices, f3 = a3.crossTileID, m3 = i2[f3], g2 = r2.opacities[f3];
            m3 ? g2 = n2 : g2 || (g2 = d2, r2.opacities[f3] = g2), i2[f3] = true;
            var v2 = s3 > 0 || l3 > 0, y2 = a3.numIconVertices > 0, x2 = r2.placedOrientations[a3.crossTileID], b2 = x2 === t.WritingMode.vertical, w2 = x2 === t.WritingMode.horizontal || x2 === t.WritingMode.horizontalOnly;
            if (v2) {
              var E2 = Ce(g2.text), T2 = b2 ? Pe : E2;
              _2(e2.text, s3, T2);
              var I2 = w2 ? Pe : E2;
              _2(e2.text, l3, I2);
              var S2 = g2.text.isHidden();
              [a3.rightJustifiedTextSymbolIndex, a3.centerJustifiedTextSymbolIndex, a3.leftJustifiedTextSymbolIndex].forEach(function(t2) {
                t2 >= 0 && (e2.text.placedSymbolArray.get(t2).hidden = S2 || b2 ? 1 : 0);
              }), a3.verticalPlacedTextSymbolIndex >= 0 && (e2.text.placedSymbolArray.get(a3.verticalPlacedTextSymbolIndex).hidden = S2 || w2 ? 1 : 0);
              var C2 = r2.variableOffsets[a3.crossTileID];
              C2 && r2.markUsedJustification(e2, C2.anchor, a3, x2);
              var P2 = r2.placedOrientations[a3.crossTileID];
              P2 && (r2.markUsedJustification(e2, "left", a3, P2), r2.markUsedOrientation(e2, P2, a3));
            }
            if (y2) {
              var z2 = Ce(g2.icon), M2 = !(p2 && a3.verticalPlacedIconSymbolIndex && b2);
              if (a3.placedIconSymbolIndex >= 0) {
                var L2 = M2 ? z2 : Pe;
                _2(e2.icon, a3.numIconVertices, L2), e2.icon.placedSymbolArray.get(a3.placedIconSymbolIndex).hidden = g2.icon.isHidden();
              }
              if (a3.verticalPlacedIconSymbolIndex >= 0) {
                var D2 = M2 ? Pe : z2;
                _2(e2.icon, a3.numVerticalIconVertices, D2), e2.icon.placedSymbolArray.get(a3.verticalPlacedIconSymbolIndex).hidden = g2.icon.isHidden();
              }
            }
            if (e2.hasIconCollisionBoxData() || e2.hasIconCollisionCircleData() || e2.hasTextCollisionBoxData() || e2.hasTextCollisionCircleData()) {
              var A2 = e2.collisionArrays[o3];
              if (A2) {
                var R2 = new t.Point(0, 0);
                if (A2.textBox || A2.verticalTextBox) {
                  var k2 = true;
                  if (c2) {
                    var B2 = r2.variableOffsets[f3];
                    B2 ? (R2 = me(B2.anchor, B2.width, B2.height, B2.textOffset, B2.textBoxScale), u2 && R2._rotate(h2 ? r2.transform.angle : -r2.transform.angle)) : k2 = false;
                  }
                  A2.textBox && ye(e2.textCollisionBox.collisionVertexArray, g2.text.placed, !k2 || b2, R2.x, R2.y), A2.verticalTextBox && ye(e2.textCollisionBox.collisionVertexArray, g2.text.placed, !k2 || w2, R2.x, R2.y);
                }
                var O2 = Boolean(!w2 && A2.verticalIconBox);
                A2.iconBox && ye(e2.iconCollisionBox.collisionVertexArray, g2.icon.placed, O2, p2 ? R2.x : 0, p2 ? R2.y : 0), A2.verticalIconBox && ye(e2.iconCollisionBox.collisionVertexArray, g2.icon.placed, !O2, p2 ? R2.x : 0, p2 ? R2.y : 0);
                var F2 = A2.textCircles;
                if (F2 && e2.hasTextCollisionCircleData())
                  for (var U2 = 0; U2 < F2.length; U2 += 5) {
                    var N2 = m3 || 0 === F2[U2 + 4];
                    ye(e2.textCollisionCircle.collisionVertexArray, g2.text.placed, N2);
                  }
              }
            }
          }, m2 = 0; m2 < e2.symbolInstances.length; m2++)
            f2(m2);
          e2.sortFeatures(this.transform.angle), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.hasIconCollisionCircleData() && e2.iconCollisionCircle.collisionVertexBuffer && e2.iconCollisionCircle.collisionVertexBuffer.updateData(e2.iconCollisionCircle.collisionVertexArray), e2.hasTextCollisionCircleData() && e2.textCollisionCircle.collisionVertexBuffer && e2.textCollisionCircle.collisionVertexBuffer.updateData(e2.textCollisionCircle.collisionVertexArray);
        }, ve.prototype.symbolFadeChange = function(t2) {
          return 0 === this.fadeDuration ? 1 : (t2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }, ve.prototype.zoomAdjustment = function(t2) {
          return Math.max(0, (this.transform.zoom - t2) / 1.5);
        }, ve.prototype.hasTransitions = function(t2) {
          return this.stale || t2 - this.lastPlacementChangeTime < this.fadeDuration;
        }, ve.prototype.stillRecent = function(t2, e2) {
          var i2 = this.zoomAtLastRecencyCheck === e2 ? 1 - this.zoomAdjustment(e2) : 1;
          return this.zoomAtLastRecencyCheck = e2, this.commitTime + this.fadeDuration * i2 > t2;
        }, ve.prototype.setStale = function() {
          this.stale = true;
        };
        var xe = Math.pow(2, 25), be = Math.pow(2, 24), we = Math.pow(2, 17), Ee = Math.pow(2, 16), Te = Math.pow(2, 9), Ie = Math.pow(2, 8), Se = Math.pow(2, 1);
        function Ce(t2) {
          if (0 === t2.opacity && !t2.placed)
            return 0;
          if (1 === t2.opacity && t2.placed)
            return 4294967295;
          var e2 = t2.placed ? 1 : 0, i2 = Math.floor(127 * t2.opacity);
          return i2 * xe + e2 * be + i2 * we + e2 * Ee + i2 * Te + e2 * Ie + i2 * Se + e2;
        }
        var Pe = 0, ze = function() {
          this._currentTileIndex = 0, this._seenCrossTileIDs = {};
        };
        ze.prototype.continuePlacement = function(t2, e2, i2, o2, r2) {
          for (; this._currentTileIndex < t2.length; ) {
            var a2 = t2[this._currentTileIndex];
            if (e2.placeLayerTile(o2, a2, i2, this._seenCrossTileIDs), this._currentTileIndex++, r2())
              return true;
          }
        };
        var Me = function(t2, e2, i2, o2, r2, a2, n2) {
          this.placement = new ve(t2, r2, a2, n2), this._currentPlacementIndex = e2.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
        };
        Me.prototype.isDone = function() {
          return this._done;
        }, Me.prototype.continuePlacement = function(e2, i2, o2) {
          for (var r2 = this, a2 = t.browser.now(), n2 = function() {
            var e3 = t.browser.now() - a2;
            return !r2._forceFullPlacement && e3 > 2;
          }; this._currentPlacementIndex >= 0; ) {
            var s2 = i2[e2[this._currentPlacementIndex]], l2 = this.placement.collisionIndex.transform.zoom;
            if ("symbol" === s2.type && (!s2.minzoom || s2.minzoom <= l2) && (!s2.maxzoom || s2.maxzoom > l2)) {
              if (this._inProgressLayer || (this._inProgressLayer = new ze()), this._inProgressLayer.continuePlacement(o2[s2.source], this.placement, this._showCollisionBoxes, s2, n2))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }, Me.prototype.commit = function(t2) {
          return this.placement.commit(t2), this.placement;
        };
        var Le = 512 / t.EXTENT / 2, De = function(t2, e2, i2) {
          this.tileID = t2, this.indexedSymbolInstances = {}, this.bucketInstanceId = i2;
          for (var o2 = 0; o2 < e2.length; o2++) {
            var r2 = e2.get(o2), a2 = r2.key;
            this.indexedSymbolInstances[a2] || (this.indexedSymbolInstances[a2] = []), this.indexedSymbolInstances[a2].push({ crossTileID: r2.crossTileID, coord: this.getScaledCoordinates(r2, t2) });
          }
        };
        De.prototype.getScaledCoordinates = function(e2, i2) {
          var o2 = i2.canonical.z - this.tileID.canonical.z, r2 = Le / Math.pow(2, o2);
          return { x: Math.floor((i2.canonical.x * t.EXTENT + e2.anchorX) * r2), y: Math.floor((i2.canonical.y * t.EXTENT + e2.anchorY) * r2) };
        }, De.prototype.findMatches = function(t2, e2, i2) {
          for (var o2 = this.tileID.canonical.z < e2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e2.canonical.z), r2 = 0; r2 < t2.length; r2++) {
            var a2 = t2.get(r2);
            if (!a2.crossTileID) {
              var n2 = this.indexedSymbolInstances[a2.key];
              if (n2)
                for (var s2 = this.getScaledCoordinates(a2, e2), l2 = 0, c2 = n2; l2 < c2.length; l2 += 1) {
                  var u2 = c2[l2];
                  if (Math.abs(u2.coord.x - s2.x) <= o2 && Math.abs(u2.coord.y - s2.y) <= o2 && !i2[u2.crossTileID]) {
                    i2[u2.crossTileID] = true, a2.crossTileID = u2.crossTileID;
                    break;
                  }
                }
            }
          }
        };
        var Ae = function() {
          this.maxCrossTileID = 0;
        };
        Ae.prototype.generate = function() {
          return ++this.maxCrossTileID;
        };
        var Re = function() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        };
        Re.prototype.handleWrapJump = function(t2) {
          var e2 = Math.round((t2 - this.lng) / 360);
          if (0 !== e2)
            for (var i2 in this.indexes) {
              var o2 = this.indexes[i2], r2 = {};
              for (var a2 in o2) {
                var n2 = o2[a2];
                n2.tileID = n2.tileID.unwrapTo(n2.tileID.wrap + e2), r2[n2.tileID.key] = n2;
              }
              this.indexes[i2] = r2;
            }
          this.lng = t2;
        }, Re.prototype.addBucket = function(t2, e2, i2) {
          if (this.indexes[t2.overscaledZ] && this.indexes[t2.overscaledZ][t2.key]) {
            if (this.indexes[t2.overscaledZ][t2.key].bucketInstanceId === e2.bucketInstanceId)
              return false;
            this.removeBucketCrossTileIDs(t2.overscaledZ, this.indexes[t2.overscaledZ][t2.key]);
          }
          for (var o2 = 0; o2 < e2.symbolInstances.length; o2++) {
            e2.symbolInstances.get(o2).crossTileID = 0;
          }
          this.usedCrossTileIDs[t2.overscaledZ] || (this.usedCrossTileIDs[t2.overscaledZ] = {});
          var r2 = this.usedCrossTileIDs[t2.overscaledZ];
          for (var a2 in this.indexes) {
            var n2 = this.indexes[a2];
            if (Number(a2) > t2.overscaledZ)
              for (var s2 in n2) {
                var l2 = n2[s2];
                l2.tileID.isChildOf(t2) && l2.findMatches(e2.symbolInstances, t2, r2);
              }
            else {
              var c2 = n2[t2.scaledTo(Number(a2)).key];
              c2 && c2.findMatches(e2.symbolInstances, t2, r2);
            }
          }
          for (var u2 = 0; u2 < e2.symbolInstances.length; u2++) {
            var h2 = e2.symbolInstances.get(u2);
            h2.crossTileID || (h2.crossTileID = i2.generate(), r2[h2.crossTileID] = true);
          }
          return void 0 === this.indexes[t2.overscaledZ] && (this.indexes[t2.overscaledZ] = {}), this.indexes[t2.overscaledZ][t2.key] = new De(t2, e2.symbolInstances, e2.bucketInstanceId), true;
        }, Re.prototype.removeBucketCrossTileIDs = function(t2, e2) {
          for (var i2 in e2.indexedSymbolInstances)
            for (var o2 = 0, r2 = e2.indexedSymbolInstances[i2]; o2 < r2.length; o2 += 1) {
              var a2 = r2[o2];
              delete this.usedCrossTileIDs[t2][a2.crossTileID];
            }
        }, Re.prototype.removeStaleBuckets = function(t2) {
          var e2 = false;
          for (var i2 in this.indexes) {
            var o2 = this.indexes[i2];
            for (var r2 in o2)
              t2[o2[r2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[r2]), delete o2[r2], e2 = true);
          }
          return e2;
        };
        var ke = function() {
          this.layerIndexes = {}, this.crossTileIDs = new Ae(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        };
        ke.prototype.addLayer = function(t2, e2, i2) {
          var o2 = this.layerIndexes[t2.id];
          void 0 === o2 && (o2 = this.layerIndexes[t2.id] = new Re());
          var r2 = false, a2 = {};
          o2.handleWrapJump(i2);
          for (var n2 = 0, s2 = e2; n2 < s2.length; n2 += 1) {
            var l2 = s2[n2], c2 = l2.getBucket(t2);
            c2 && t2.id === c2.layerIds[0] && (c2.bucketInstanceId || (c2.bucketInstanceId = ++this.maxBucketInstanceId), o2.addBucket(l2.tileID, c2, this.crossTileIDs) && (r2 = true), a2[c2.bucketInstanceId] = true);
          }
          return o2.removeStaleBuckets(a2) && (r2 = true), r2;
        }, ke.prototype.pruneUnusedLayers = function(t2) {
          var e2 = {};
          for (var i2 in t2.forEach(function(t3) {
            e2[t3] = true;
          }), this.layerIndexes)
            e2[i2] || delete this.layerIndexes[i2];
        };
        var Be = function(e2, i2) {
          return t.emitValidationErrors(e2, i2 && i2.filter(function(t2) {
            return "source.canvas" !== t2.identifier;
          }));
        }, Oe = t.pick(Ut, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), Fe = t.pick(Ut, ["setCenter", "setZoom", "setBearing", "setPitch"]), Ue = function() {
          var e2 = {}, i2 = t.styleSpec.$version;
          for (var o2 in t.styleSpec.$root) {
            var r2 = t.styleSpec.$root[o2];
            if (r2.required) {
              var a2 = null;
              null != (a2 = "version" === o2 ? i2 : "array" === r2.type ? [] : {}) && (e2[o2] = a2);
            }
          }
          return e2;
        }(), Ne = function(e2) {
          function i2(o2, r2) {
            var a2 = this;
            void 0 === r2 && (r2 = {}), e2.call(this), this.map = o2, this.dispatcher = new T((kt || (kt = new Rt()), kt), this), this.imageManager = new p(), this.imageManager.setEventedParent(this), this.glyphManager = new y(o2._requestManager, r2.localIdeographFontFamily), this.lineAtlas = new E(256, 512), this.crossTileSymbolIndex = new ke(), this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ZoomHistory(), this._loaded = false, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.getReferrer());
            var n2 = this;
            this._rtlTextPluginCallback = i2.registerForPluginStateChange(function(e3) {
              var i3 = { pluginStatus: e3.pluginStatus, pluginURL: e3.pluginURL };
              n2.dispatcher.broadcast("syncRTLPluginState", i3, function(e4, i4) {
                if ((t.triggerPluginCompletionEvent(e4), i4) && i4.every(function(t2) {
                  return t2;
                }))
                  for (var o3 in n2.sourceCaches)
                    n2.sourceCaches[o3].reload();
              });
            }), this.on("data", function(t2) {
              if ("source" === t2.dataType && "metadata" === t2.sourceDataType) {
                var e3 = a2.sourceCaches[t2.sourceId];
                if (e3) {
                  var i3 = e3.getSource();
                  if (i3 && i3.vectorLayerIds)
                    for (var o3 in a2._layers) {
                      var r3 = a2._layers[o3];
                      r3.source === i3.id && a2._validateLayer(r3);
                    }
                }
              }
            });
          }
          return e2 && (i2.__proto__ = e2), i2.prototype = Object.create(e2 && e2.prototype), i2.prototype.constructor = i2, i2.prototype.loadURL = function(e3, i3) {
            var o2 = this;
            void 0 === i3 && (i3 = {}), this.fire(new t.Event("dataloading", { dataType: "style" }));
            var r2 = "boolean" == typeof i3.validate ? i3.validate : !t.isGoongURL(e3);
            e3 = this.map._requestManager.normalizeStyleURL(e3, i3.accessToken);
            var a2 = this.map._requestManager.transformRequest(e3, t.ResourceType.Style);
            this._request = t.getJSON(a2, function(e4, i4) {
              o2._request = null, e4 ? o2.fire(new t.ErrorEvent(e4)) : i4 && o2._load(i4, r2);
            });
          }, i2.prototype.loadJSON = function(e3, i3) {
            var o2 = this;
            void 0 === i3 && (i3 = {}), this.fire(new t.Event("dataloading", { dataType: "style" })), this._request = t.browser.frame(function() {
              o2._request = null, o2._load(e3, false !== i3.validate);
            });
          }, i2.prototype.loadEmpty = function() {
            this.fire(new t.Event("dataloading", { dataType: "style" })), this._load(Ue, false);
          }, i2.prototype._load = function(e3, i3) {
            var o2 = this;
            if (!i3 || !Be(this, t.validateStyle(e3))) {
              for (var r2 in this._loaded = true, this.stylesheet = e3, e3.sources)
                this.addSource(r2, e3.sources[r2], { validate: false });
              e3.sprite ? this._spriteRequest = function(e4, i4, o3) {
                var r3, a3, n3, s3 = t.browser.devicePixelRatio > 1 ? "@2x" : "", l3 = t.getJSON(i4.transformRequest(i4.normalizeSpriteURL(e4, s3, ".json"), t.ResourceType.SpriteJSON), function(t2, e5) {
                  l3 = null, n3 || (n3 = t2, r3 = e5, u2());
                }), c2 = t.getImage(i4.transformRequest(i4.normalizeSpriteURL(e4, s3, ".png"), t.ResourceType.SpriteImage), function(t2, e5) {
                  c2 = null, n3 || (n3 = t2, a3 = e5, u2());
                });
                function u2() {
                  if (n3)
                    o3(n3);
                  else if (r3 && a3) {
                    var e5 = t.browser.getImageData(a3), i5 = {};
                    for (var s4 in r3) {
                      var l4 = r3[s4], c3 = l4.width, u3 = l4.height, h2 = l4.x, p2 = l4.y, d2 = l4.sdf, _2 = l4.pixelRatio, f2 = l4.stretchX, m2 = l4.stretchY, g2 = l4.content, v2 = new t.RGBAImage({ width: c3, height: u3 });
                      t.RGBAImage.copy(e5, v2, { x: h2, y: p2 }, { x: 0, y: 0 }, { width: c3, height: u3 }), i5[s4] = { data: v2, pixelRatio: _2, sdf: d2, stretchX: f2, stretchY: m2, content: g2 };
                    }
                    o3(null, i5);
                  }
                }
                return { cancel: function() {
                  l3 && (l3.cancel(), l3 = null), c2 && (c2.cancel(), c2 = null);
                } };
              }(e3.sprite, this.map._requestManager, function(e4, i4) {
                if (o2._spriteRequest = null, e4)
                  o2.fire(new t.ErrorEvent(e4));
                else if (i4)
                  for (var r3 in i4)
                    o2.imageManager.addImage(r3, i4[r3]);
                o2.imageManager.setLoaded(true), o2.dispatcher.broadcast("setImages", o2.imageManager.listImages()), o2.fire(new t.Event("data", { dataType: "style" }));
              }) : this.imageManager.setLoaded(true), this.glyphManager.setURL(e3.glyphs);
              var a2 = Ft(this.stylesheet.layers);
              this._order = a2.map(function(t2) {
                return t2.id;
              }), this._layers = {};
              for (var n2 = 0, s2 = a2; n2 < s2.length; n2 += 1) {
                var l2 = s2[n2];
                (l2 = t.createStyleLayer(l2)).setEventedParent(this, { layer: { id: l2.id } }), this._layers[l2.id] = l2;
              }
              this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new w(this.stylesheet.light), this.fire(new t.Event("data", { dataType: "style" })), this.fire(new t.Event("style.load"));
            }
          }, i2.prototype._validateLayer = function(e3) {
            var i3 = this.sourceCaches[e3.source];
            if (i3) {
              var o2 = e3.sourceLayer;
              if (o2) {
                var r2 = i3.getSource();
                ("geojson" === r2.type || r2.vectorLayerIds && -1 === r2.vectorLayerIds.indexOf(o2)) && this.fire(new t.ErrorEvent(new Error('Source layer "' + o2 + '" does not exist on source "' + r2.id + '" as specified by style layer "' + e3.id + '"')));
              }
            }
          }, i2.prototype.loaded = function() {
            if (!this._loaded)
              return false;
            if (Object.keys(this._updatedSources).length)
              return false;
            for (var t2 in this.sourceCaches)
              if (!this.sourceCaches[t2].loaded())
                return false;
            return !!this.imageManager.isLoaded();
          }, i2.prototype._serializeLayers = function(t2) {
            for (var e3 = [], i3 = 0, o2 = t2; i3 < o2.length; i3 += 1) {
              var r2 = o2[i3], a2 = this._layers[r2];
              "custom" !== a2.type && e3.push(a2.serialize());
            }
            return e3;
          }, i2.prototype.hasTransitions = function() {
            if (this.light && this.light.hasTransition())
              return true;
            for (var t2 in this.sourceCaches)
              if (this.sourceCaches[t2].hasTransition())
                return true;
            for (var e3 in this._layers)
              if (this._layers[e3].hasTransition())
                return true;
            return false;
          }, i2.prototype._checkLoaded = function() {
            if (!this._loaded)
              throw new Error("Style is not done loading");
          }, i2.prototype.update = function(e3) {
            if (this._loaded) {
              var i3 = this._changed;
              if (this._changed) {
                var o2 = Object.keys(this._updatedLayers), r2 = Object.keys(this._removedLayers);
                for (var a2 in (o2.length || r2.length) && this._updateWorkerLayers(o2, r2), this._updatedSources) {
                  var n2 = this._updatedSources[a2];
                  "reload" === n2 ? this._reloadSource(a2) : "clear" === n2 && this._clearSource(a2);
                }
                for (var s2 in this._updateTilesForChangedImages(), this._updatedPaintProps)
                  this._layers[s2].updateTransitions(e3);
                this.light.updateTransitions(e3), this._resetUpdates();
              }
              for (var l2 in this.sourceCaches)
                this.sourceCaches[l2].used = false;
              for (var c2 = 0, u2 = this._order; c2 < u2.length; c2 += 1) {
                var h2 = u2[c2], p2 = this._layers[h2];
                p2.recalculate(e3, this.imageManager.listImages()), !p2.isHidden(e3.zoom) && p2.source && (this.sourceCaches[p2.source].used = true);
              }
              this.light.recalculate(e3), this.z = e3.zoom, i3 && this.fire(new t.Event("data", { dataType: "style" }));
            }
          }, i2.prototype._updateTilesForChangedImages = function() {
            var t2 = Object.keys(this._changedImages);
            if (t2.length) {
              for (var e3 in this.sourceCaches)
                this.sourceCaches[e3].reloadTilesForDependencies(["icons", "patterns"], t2);
              this._changedImages = {};
            }
          }, i2.prototype._updateWorkerLayers = function(t2, e3) {
            this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(t2), removedIds: e3 });
          }, i2.prototype._resetUpdates = function() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
          }, i2.prototype.setState = function(e3) {
            var i3 = this;
            if (this._checkLoaded(), Be(this, t.validateStyle(e3)))
              return false;
            (e3 = t.clone$1(e3)).layers = Ft(e3.layers);
            var o2 = Xt(this.serialize(), e3).filter(function(t2) {
              return !(t2.command in Fe);
            });
            if (0 === o2.length)
              return false;
            var r2 = o2.filter(function(t2) {
              return !(t2.command in Oe);
            });
            if (r2.length > 0)
              throw new Error("Unimplemented: " + r2.map(function(t2) {
                return t2.command;
              }).join(", ") + ".");
            return o2.forEach(function(t2) {
              "setTransition" !== t2.command && i3[t2.command].apply(i3, t2.args);
            }), this.stylesheet = e3, true;
          }, i2.prototype.addImage = function(e3, i3) {
            if (this.getImage(e3))
              return this.fire(new t.ErrorEvent(new Error("An image with this name already exists.")));
            this.imageManager.addImage(e3, i3), this._changedImages[e3] = true, this._changed = true, this.fire(new t.Event("data", { dataType: "style" }));
          }, i2.prototype.updateImage = function(t2, e3) {
            this.imageManager.updateImage(t2, e3);
          }, i2.prototype.getImage = function(t2) {
            return this.imageManager.getImage(t2);
          }, i2.prototype.removeImage = function(e3) {
            if (!this.getImage(e3))
              return this.fire(new t.ErrorEvent(new Error("No image with this name exists.")));
            this.imageManager.removeImage(e3), this._changedImages[e3] = true, this._changed = true, this.fire(new t.Event("data", { dataType: "style" }));
          }, i2.prototype.listImages = function() {
            return this._checkLoaded(), this.imageManager.listImages();
          }, i2.prototype.addSource = function(e3, i3, o2) {
            var r2 = this;
            if (void 0 === o2 && (o2 = {}), this._checkLoaded(), void 0 !== this.sourceCaches[e3])
              throw new Error("There is already a source with this ID");
            if (!i3.type)
              throw new Error("The type property must be defined, but the only the following properties were given: " + Object.keys(i3).join(", ") + ".");
            if (!(["vector", "raster", "geojson", "video", "image"].indexOf(i3.type) >= 0) || !this._validate(t.validateStyle.source, "sources." + e3, i3, null, o2)) {
              this.map && this.map._collectResourceTiming && (i3.collectResourceTiming = true);
              var a2 = this.sourceCaches[e3] = new Mt(e3, i3, this.dispatcher);
              a2.style = this, a2.setEventedParent(this, function() {
                return { isSourceLoaded: r2.loaded(), source: a2.serialize(), sourceId: e3 };
              }), a2.onAdd(this.map), this._changed = true;
            }
          }, i2.prototype.removeSource = function(e3) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[e3])
              throw new Error("There is no source with this ID");
            for (var i3 in this._layers)
              if (this._layers[i3].source === e3)
                return this.fire(new t.ErrorEvent(new Error('Source "' + e3 + '" cannot be removed while layer "' + i3 + '" is using it.')));
            var o2 = this.sourceCaches[e3];
            delete this.sourceCaches[e3], delete this._updatedSources[e3], o2.fire(new t.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: e3 })), o2.setEventedParent(null), o2.clearTiles(), o2.onRemove && o2.onRemove(this.map), this._changed = true;
          }, i2.prototype.setGeoJSONSourceData = function(t2, e3) {
            this._checkLoaded(), this.sourceCaches[t2].getSource().setData(e3), this._changed = true;
          }, i2.prototype.getSource = function(t2) {
            return this.sourceCaches[t2] && this.sourceCaches[t2].getSource();
          }, i2.prototype.addLayer = function(e3, i3, o2) {
            void 0 === o2 && (o2 = {}), this._checkLoaded();
            var r2 = e3.id;
            if (this.getLayer(r2))
              this.fire(new t.ErrorEvent(new Error('Layer with id "' + r2 + '" already exists on this map')));
            else {
              var a2;
              if ("custom" === e3.type) {
                if (Be(this, t.validateCustomStyleLayer(e3)))
                  return;
                a2 = t.createStyleLayer(e3);
              } else {
                if ("object" == typeof e3.source && (this.addSource(r2, e3.source), e3 = t.clone$1(e3), e3 = t.extend(e3, { source: r2 })), this._validate(t.validateStyle.layer, "layers." + r2, e3, { arrayIndex: -1 }, o2))
                  return;
                a2 = t.createStyleLayer(e3), this._validateLayer(a2), a2.setEventedParent(this, { layer: { id: r2 } });
              }
              var n2 = i3 ? this._order.indexOf(i3) : this._order.length;
              if (i3 && -1 === n2)
                this.fire(new t.ErrorEvent(new Error('Layer with id "' + i3 + '" does not exist on this map.')));
              else {
                if (this._order.splice(n2, 0, r2), this._layerOrderChanged = true, this._layers[r2] = a2, this._removedLayers[r2] && a2.source && "custom" !== a2.type) {
                  var s2 = this._removedLayers[r2];
                  delete this._removedLayers[r2], s2.type !== a2.type ? this._updatedSources[a2.source] = "clear" : (this._updatedSources[a2.source] = "reload", this.sourceCaches[a2.source].pause());
                }
                this._updateLayer(a2), a2.onAdd && a2.onAdd(this.map);
              }
            }
          }, i2.prototype.moveLayer = function(e3, i3) {
            if (this._checkLoaded(), this._changed = true, this._layers[e3]) {
              if (e3 !== i3) {
                var o2 = this._order.indexOf(e3);
                this._order.splice(o2, 1);
                var r2 = i3 ? this._order.indexOf(i3) : this._order.length;
                i3 && -1 === r2 ? this.fire(new t.ErrorEvent(new Error('Layer with id "' + i3 + '" does not exist on this map.'))) : (this._order.splice(r2, 0, e3), this._layerOrderChanged = true);
              }
            } else
              this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be moved.")));
          }, i2.prototype.removeLayer = function(e3) {
            this._checkLoaded();
            var i3 = this._layers[e3];
            if (i3) {
              i3.setEventedParent(null);
              var o2 = this._order.indexOf(e3);
              this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e3] = i3, delete this._layers[e3], delete this._updatedLayers[e3], delete this._updatedPaintProps[e3], i3.onRemove && i3.onRemove(this.map);
            } else
              this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be removed.")));
          }, i2.prototype.getLayer = function(t2) {
            return this._layers[t2];
          }, i2.prototype.setLayerZoomRange = function(e3, i3, o2) {
            this._checkLoaded();
            var r2 = this.getLayer(e3);
            r2 ? r2.minzoom === i3 && r2.maxzoom === o2 || (null != i3 && (r2.minzoom = i3), null != o2 && (r2.maxzoom = o2), this._updateLayer(r2)) : this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot have zoom extent.")));
          }, i2.prototype.setFilter = function(e3, i3, o2) {
            void 0 === o2 && (o2 = {}), this._checkLoaded();
            var r2 = this.getLayer(e3);
            if (r2) {
              if (!t.deepEqual(r2.filter, i3))
                return null == i3 ? (r2.filter = void 0, void this._updateLayer(r2)) : void (this._validate(t.validateStyle.filter, "layers." + r2.id + ".filter", i3, null, o2) || (r2.filter = t.clone$1(i3), this._updateLayer(r2)));
            } else
              this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be filtered.")));
          }, i2.prototype.getFilter = function(e3) {
            return t.clone$1(this.getLayer(e3).filter);
          }, i2.prototype.setLayoutProperty = function(e3, i3, o2, r2) {
            void 0 === r2 && (r2 = {}), this._checkLoaded();
            var a2 = this.getLayer(e3);
            a2 ? t.deepEqual(a2.getLayoutProperty(i3), o2) || (a2.setLayoutProperty(i3, o2, r2), this._updateLayer(a2)) : this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be styled.")));
          }, i2.prototype.getLayoutProperty = function(e3, i3) {
            var o2 = this.getLayer(e3);
            if (o2)
              return o2.getLayoutProperty(i3);
            this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style.")));
          }, i2.prototype.setPaintProperty = function(e3, i3, o2, r2) {
            void 0 === r2 && (r2 = {}), this._checkLoaded();
            var a2 = this.getLayer(e3);
            a2 ? t.deepEqual(a2.getPaintProperty(i3), o2) || (a2.setPaintProperty(i3, o2, r2) && this._updateLayer(a2), this._changed = true, this._updatedPaintProps[e3] = true) : this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be styled.")));
          }, i2.prototype.getPaintProperty = function(t2, e3) {
            return this.getLayer(t2).getPaintProperty(e3);
          }, i2.prototype.setFeatureState = function(e3, i3) {
            this._checkLoaded();
            var o2 = e3.source, r2 = e3.sourceLayer, a2 = this.sourceCaches[o2];
            if (void 0 !== a2) {
              var n2 = a2.getSource().type;
              "geojson" === n2 && r2 ? this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== n2 || r2 ? (void 0 === e3.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), a2.setFeatureState(r2, e3.id, i3)) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            } else
              this.fire(new t.ErrorEvent(new Error("The source '" + o2 + "' does not exist in the map's style.")));
          }, i2.prototype.removeFeatureState = function(e3, i3) {
            this._checkLoaded();
            var o2 = e3.source, r2 = this.sourceCaches[o2];
            if (void 0 !== r2) {
              var a2 = r2.getSource().type, n2 = "vector" === a2 ? e3.sourceLayer : void 0;
              "vector" !== a2 || n2 ? i3 && "string" != typeof e3.id && "number" != typeof e3.id ? this.fire(new t.ErrorEvent(new Error("A feature id is requred to remove its specific state property."))) : r2.removeFeatureState(n2, e3.id, i3) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            } else
              this.fire(new t.ErrorEvent(new Error("The source '" + o2 + "' does not exist in the map's style.")));
          }, i2.prototype.getFeatureState = function(e3) {
            this._checkLoaded();
            var i3 = e3.source, o2 = e3.sourceLayer, r2 = this.sourceCaches[i3];
            if (void 0 !== r2) {
              if ("vector" !== r2.getSource().type || o2)
                return void 0 === e3.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), r2.getFeatureState(o2, e3.id);
              this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            } else
              this.fire(new t.ErrorEvent(new Error("The source '" + i3 + "' does not exist in the map's style.")));
          }, i2.prototype.getTransition = function() {
            return t.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }, i2.prototype.serialize = function() {
            return t.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: t.mapObject(this.sourceCaches, function(t2) {
              return t2.serialize();
            }), layers: this._serializeLayers(this._order) }, function(t2) {
              return void 0 !== t2;
            });
          }, i2.prototype._updateLayer = function(t2) {
            this._updatedLayers[t2.id] = true, t2.source && !this._updatedSources[t2.source] && "raster" !== this.sourceCaches[t2.source].getSource().type && (this._updatedSources[t2.source] = "reload", this.sourceCaches[t2.source].pause()), this._changed = true;
          }, i2.prototype._flattenAndSortRenderedFeatures = function(t2) {
            for (var e3 = this, i3 = function(t3) {
              return "fill-extrusion" === e3._layers[t3].type;
            }, o2 = {}, r2 = [], a2 = this._order.length - 1; a2 >= 0; a2--) {
              var n2 = this._order[a2];
              if (i3(n2)) {
                o2[n2] = a2;
                for (var s2 = 0, l2 = t2; s2 < l2.length; s2 += 1) {
                  var c2 = l2[s2][n2];
                  if (c2)
                    for (var u2 = 0, h2 = c2; u2 < h2.length; u2 += 1) {
                      var p2 = h2[u2];
                      r2.push(p2);
                    }
                }
              }
            }
            r2.sort(function(t3, e4) {
              return e4.intersectionZ - t3.intersectionZ;
            });
            for (var d2 = [], _2 = this._order.length - 1; _2 >= 0; _2--) {
              var f2 = this._order[_2];
              if (i3(f2))
                for (var m2 = r2.length - 1; m2 >= 0; m2--) {
                  var g2 = r2[m2].feature;
                  if (o2[g2.layer.id] < _2)
                    break;
                  d2.push(g2), r2.pop();
                }
              else
                for (var v2 = 0, y2 = t2; v2 < y2.length; v2 += 1) {
                  var x2 = y2[v2][f2];
                  if (x2)
                    for (var b2 = 0, w2 = x2; b2 < w2.length; b2 += 1) {
                      var E2 = w2[b2];
                      d2.push(E2.feature);
                    }
                }
            }
            return d2;
          }, i2.prototype.queryRenderedFeatures = function(e3, i3, o2) {
            i3 && i3.filter && this._validate(t.validateStyle.filter, "queryRenderedFeatures.filter", i3.filter, null, i3);
            var r2 = {};
            if (i3 && i3.layers) {
              if (!Array.isArray(i3.layers))
                return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
              for (var a2 = 0, n2 = i3.layers; a2 < n2.length; a2 += 1) {
                var s2 = n2[a2], l2 = this._layers[s2];
                if (!l2)
                  return this.fire(new t.ErrorEvent(new Error("The layer '" + s2 + "' does not exist in the map's style and cannot be queried for features."))), [];
                r2[l2.source] = true;
              }
            }
            var c2 = [];
            for (var u2 in this.sourceCaches)
              i3.layers && !r2[u2] || c2.push(O(this.sourceCaches[u2], this._layers, e3, i3, o2));
            return this.placement && c2.push(function(t2, e4, i4, o3, r3, a3) {
              for (var n3 = {}, s3 = r3.queryRenderedSymbols(i4), l3 = [], c3 = 0, u3 = Object.keys(s3).map(Number); c3 < u3.length; c3 += 1) {
                var h2 = u3[c3];
                l3.push(a3[h2]);
              }
              l3.sort(F);
              for (var p2 = function() {
                var e5 = _2[d2], i5 = e5.featureIndex.lookupSymbolFeatures(s3[e5.bucketInstanceId], e5.bucketIndex, e5.sourceLayerIndex, o3.filter, o3.layers, t2);
                for (var r4 in i5) {
                  var a4 = n3[r4] = n3[r4] || [], l4 = i5[r4];
                  l4.sort(function(t3, i6) {
                    var o4 = e5.featureSortOrder;
                    if (o4) {
                      var r5 = o4.indexOf(t3.featureIndex);
                      return o4.indexOf(i6.featureIndex) - r5;
                    }
                    return i6.featureIndex - t3.featureIndex;
                  });
                  for (var c4 = 0, u4 = l4; c4 < u4.length; c4 += 1) {
                    var h3 = u4[c4];
                    a4.push(h3);
                  }
                }
              }, d2 = 0, _2 = l3; d2 < _2.length; d2 += 1)
                p2();
              var f2 = function(i5) {
                n3[i5].forEach(function(o4) {
                  var r4 = o4.feature, a4 = t2[i5], n4 = e4[a4.source].getFeatureState(r4.layer["source-layer"], r4.id);
                  r4.source = r4.layer.source, r4.layer["source-layer"] && (r4.sourceLayer = r4.layer["source-layer"]), r4.state = n4;
                });
              };
              for (var m2 in n3)
                f2(m2);
              return n3;
            }(this._layers, this.sourceCaches, e3, i3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(c2);
          }, i2.prototype.querySourceFeatures = function(e3, i3) {
            i3 && i3.filter && this._validate(t.validateStyle.filter, "querySourceFeatures.filter", i3.filter, null, i3);
            var o2 = this.sourceCaches[e3];
            return o2 ? function(t2, e4) {
              for (var i4 = t2.getRenderableIds().map(function(e5) {
                return t2.getTileByID(e5);
              }), o3 = [], r2 = {}, a2 = 0; a2 < i4.length; a2++) {
                var n2 = i4[a2], s2 = n2.tileID.canonical.key;
                r2[s2] || (r2[s2] = true, n2.querySourceFeatures(o3, e4));
              }
              return o3;
            }(o2, i3) : [];
          }, i2.prototype.addSourceType = function(t2, e3, o2) {
            return i2.getSourceType(t2) ? o2(new Error('A source type called "' + t2 + '" already exists.')) : (i2.setSourceType(t2, e3), e3.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t2, url: e3.workerSourceURL }, o2) : o2(null, null));
          }, i2.prototype.getLight = function() {
            return this.light.getLight();
          }, i2.prototype.setLight = function(e3, i3) {
            void 0 === i3 && (i3 = {}), this._checkLoaded();
            var o2 = this.light.getLight(), r2 = false;
            for (var a2 in e3)
              if (!t.deepEqual(e3[a2], o2[a2])) {
                r2 = true;
                break;
              }
            if (r2) {
              var n2 = { now: t.browser.now(), transition: t.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
              this.light.setLight(e3, i3), this.light.updateTransitions(n2);
            }
          }, i2.prototype._validate = function(e3, i3, o2, r2, a2) {
            return void 0 === a2 && (a2 = {}), (!a2 || false !== a2.validate) && Be(this, e3.call(t.validateStyle, t.extend({ key: i3, style: this.serialize(), value: o2, styleSpec: t.styleSpec }, r2)));
          }, i2.prototype._remove = function() {
            for (var e3 in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off("pluginStateChange", this._rtlTextPluginCallback), this._layers) {
              this._layers[e3].setEventedParent(null);
            }
            for (var i3 in this.sourceCaches)
              this.sourceCaches[i3].clearTiles(), this.sourceCaches[i3].setEventedParent(null);
            this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
          }, i2.prototype._clearSource = function(t2) {
            this.sourceCaches[t2].clearTiles();
          }, i2.prototype._reloadSource = function(t2) {
            this.sourceCaches[t2].resume(), this.sourceCaches[t2].reload();
          }, i2.prototype._updateSources = function(t2) {
            for (var e3 in this.sourceCaches)
              this.sourceCaches[e3].update(t2);
          }, i2.prototype._generateCollisionBoxes = function() {
            for (var t2 in this.sourceCaches)
              this._reloadSource(t2);
          }, i2.prototype._updatePlacement = function(e3, i3, o2, r2, a2) {
            void 0 === a2 && (a2 = false);
            for (var n2 = false, s2 = false, l2 = {}, c2 = 0, u2 = this._order; c2 < u2.length; c2 += 1) {
              var h2 = u2[c2], p2 = this._layers[h2];
              if ("symbol" === p2.type) {
                if (!l2[p2.source]) {
                  var d2 = this.sourceCaches[p2.source];
                  l2[p2.source] = d2.getRenderableIds(true).map(function(t2) {
                    return d2.getTileByID(t2);
                  }).sort(function(t2, e4) {
                    return e4.tileID.overscaledZ - t2.tileID.overscaledZ || (t2.tileID.isLessThan(e4.tileID) ? -1 : 1);
                  });
                }
                var _2 = this.crossTileSymbolIndex.addLayer(p2, l2[p2.source], e3.center.lng);
                n2 = n2 || _2;
              }
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((a2 = a2 || this._layerOrderChanged || 0 === o2) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.browser.now(), e3.zoom)) && (this.pauseablePlacement = new Me(e3, this._order, a2, i3, o2, r2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.browser.now()), s2 = true), n2 && this.pauseablePlacement.placement.setStale()), s2 || n2)
              for (var f2 = 0, m2 = this._order; f2 < m2.length; f2 += 1) {
                var g2 = m2[f2], v2 = this._layers[g2];
                "symbol" === v2.type && this.placement.updateLayerOpacities(v2, l2[v2.source]);
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.browser.now());
          }, i2.prototype._releaseSymbolFadeTiles = function() {
            for (var t2 in this.sourceCaches)
              this.sourceCaches[t2].releaseSymbolFadeTiles();
          }, i2.prototype.getImages = function(t2, e3, i3) {
            this.imageManager.getImages(e3.icons, i3), this._updateTilesForChangedImages();
            var o2 = this.sourceCaches[e3.source];
            o2 && o2.setDependencies(e3.tileID.key, e3.type, e3.icons);
          }, i2.prototype.getGlyphs = function(t2, e3, i3) {
            this.glyphManager.getGlyphs(e3.stacks, i3);
          }, i2.prototype.getResource = function(e3, i3, o2) {
            return t.makeRequest(i3, o2);
          }, i2;
        }(t.Evented);
        Ne.getSourceType = function(t2) {
          return k[t2];
        }, Ne.setSourceType = function(t2, e2) {
          k[t2] = e2;
        }, Ne.registerForPluginStateChange = t.registerForPluginStateChange;
        var Ze = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), qe = _i("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}"), je = _i("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Ve = _i("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), Ge = _i("varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), We = _i("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Xe = _i("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), He = _i("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), Ke = _i("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), Ye = _i("uniform float u_overscale_factor;varying float v_placed;varying float v_notUsed;varying float v_radius;varying vec2 v_extrude;varying vec2 v_extrude_scale;void main() {float alpha=0.5;vec4 color=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {color=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {color*=.2;}float extrude_scale_length=length(v_extrude_scale);float extrude_length=length(v_extrude)*extrude_scale_length;float stroke_width=15.0*extrude_scale_length/u_overscale_factor;float radius=v_radius*extrude_scale_length;float distance_to_edge=abs(extrude_length-radius);float opacity_t=smoothstep(-stroke_width,0.0,-distance_to_edge);gl_FragColor=opacity_t*color;}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;varying float v_radius;varying vec2 v_extrude;varying vec2 v_extrude_scale;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);highp float padding_factor=1.2;gl_Position.xy+=a_extrude*u_extrude_scale*padding_factor*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;v_radius=abs(a_extrude.y);v_extrude=a_extrude*padding_factor;v_extrude_scale=u_extrude_scale*u_camera_to_center_distance*collision_perspective_ratio;}"), Je = _i("uniform highp vec4 u_color;void main() {gl_FragColor=u_color;}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Qe = _i("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), $e = _i("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), ti = _i("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec4 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float pixelRatio=u_scale.x;float tileRatio=u_scale.y;float fromScale=u_scale.z;float toScale=u_scale.w;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=vec2((pattern_br_a.x-pattern_tl_a.x)/pixelRatio,(pattern_br_a.y-pattern_tl_a.y)/pixelRatio);vec2 display_size_b=vec2((pattern_br_b.x-pattern_tl_b.x)/pixelRatio,(pattern_br_b.y-pattern_tl_b.y)/pixelRatio);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), ei = _i("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec4 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float pixelRatio=u_scale.x;float tileZoomRatio=u_scale.y;float fromScale=u_scale.z;float toScale=u_scale.w;vec2 display_size_a=vec2((pattern_br_a.x-pattern_tl_a.x)/pixelRatio,(pattern_br_a.y-pattern_tl_a.y)/pixelRatio);vec2 display_size_b=vec2((pattern_br_b.x-pattern_tl_b.x)/pixelRatio,(pattern_br_b.y-pattern_tl_b.y)/pixelRatio);gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), ii = _i("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), oi = _i("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec4 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float pixelRatio=u_scale.x;float tileRatio=u_scale.y;float fromScale=u_scale.z;float toScale=u_scale.w;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=vec2((pattern_br_a.x-pattern_tl_a.x)/pixelRatio,(pattern_br_a.y-pattern_tl_a.y)/pixelRatio);vec2 display_size_b=vec2((pattern_br_b.x-pattern_tl_b.x)/pixelRatio,(pattern_br_b.y-pattern_tl_b.y)/pixelRatio);base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), ri = _i("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform float u_maxzoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggeration=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/ pow(2.0,(u_zoom-u_maxzoom)*exaggeration+19.2562-u_zoom);gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), ai = _i("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), ni = _i("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"), si = _i("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp float v_lineprogress;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,vec2(v_lineprogress,0.5));gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define MAX_LINE_DISTANCE 32767.0\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_lineprogress;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_lineprogress=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0/MAX_LINE_DISTANCE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"), li = _i("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec4 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float pixelRatio=u_scale.x;float tileZoomRatio=u_scale.y;float fromScale=u_scale.z;float toScale=u_scale.w;vec2 display_size_a=vec2((pattern_br_a.x-pattern_tl_a.x)/pixelRatio,(pattern_br_a.y-pattern_tl_a.y)/pixelRatio);vec2 display_size_b=vec2((pattern_br_b.x-pattern_tl_b.x)/pixelRatio,(pattern_br_b.y-pattern_tl_b.y)/pixelRatio);vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x,1.0);float x_b=mod(v_linesofar/pattern_size_b.x,1.0);float y_a=0.5+(v_normal.y*clamp(v_width2.s,0.0,(pattern_size_a.y+2.0)/2.0)/pattern_size_a.y);float y_b=0.5+(v_normal.y*clamp(v_width2.s,0.0,(pattern_size_b.y+2.0)/2.0)/pattern_size_b.y);vec2 pos_a=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,vec2(x_a,y_a));vec2 pos_b=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,vec2(x_b,y_b));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);}"), ci = _i("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), ui = _i("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), hi = _i("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}"), pi = _i("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), di = _i("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}");
        function _i(t2, e2) {
          var i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o2 = {};
          return { fragmentSource: t2 = t2.replace(i2, function(t3, e3, i3, r2, a2) {
            return o2[a2] = true, "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_" + a2 + "\nvarying " + i3 + " " + r2 + " " + a2 + ";\n#else\nuniform " + i3 + " " + r2 + " u_" + a2 + ";\n#endif\n" : "\n#ifdef HAS_UNIFORM_u_" + a2 + "\n    " + i3 + " " + r2 + " " + a2 + " = u_" + a2 + ";\n#endif\n";
          }), vertexSource: e2 = e2.replace(i2, function(t3, e3, i3, r2, a2) {
            var n2 = "float" === r2 ? "vec2" : "vec4", s2 = a2.match(/color/) ? "color" : n2;
            return o2[a2] ? "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_" + a2 + "\nuniform lowp float u_" + a2 + "_t;\nattribute " + i3 + " " + n2 + " a_" + a2 + ";\nvarying " + i3 + " " + r2 + " " + a2 + ";\n#else\nuniform " + i3 + " " + r2 + " u_" + a2 + ";\n#endif\n" : "vec4" === s2 ? "\n#ifndef HAS_UNIFORM_u_" + a2 + "\n    " + a2 + " = a_" + a2 + ";\n#else\n    " + i3 + " " + r2 + " " + a2 + " = u_" + a2 + ";\n#endif\n" : "\n#ifndef HAS_UNIFORM_u_" + a2 + "\n    " + a2 + " = unpack_mix_" + s2 + "(a_" + a2 + ", u_" + a2 + "_t);\n#else\n    " + i3 + " " + r2 + " " + a2 + " = u_" + a2 + ";\n#endif\n" : "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_" + a2 + "\nuniform lowp float u_" + a2 + "_t;\nattribute " + i3 + " " + n2 + " a_" + a2 + ";\n#else\nuniform " + i3 + " " + r2 + " u_" + a2 + ";\n#endif\n" : "vec4" === s2 ? "\n#ifndef HAS_UNIFORM_u_" + a2 + "\n    " + i3 + " " + r2 + " " + a2 + " = a_" + a2 + ";\n#else\n    " + i3 + " " + r2 + " " + a2 + " = u_" + a2 + ";\n#endif\n" : "\n#ifndef HAS_UNIFORM_u_" + a2 + "\n    " + i3 + " " + r2 + " " + a2 + " = unpack_mix_" + s2 + "(a_" + a2 + ", u_" + a2 + "_t);\n#else\n    " + i3 + " " + r2 + " " + a2 + " = u_" + a2 + ";\n#endif\n";
          }) };
        }
        var fi = Object.freeze({ __proto__: null, prelude: qe, background: je, backgroundPattern: Ve, circle: Ge, clippingMask: We, heatmap: Xe, heatmapTexture: He, collisionBox: Ke, collisionCircle: Ye, debug: Je, fill: Qe, fillOutline: $e, fillOutlinePattern: ti, fillPattern: ei, fillExtrusion: ii, fillExtrusionPattern: oi, hillshadePrepare: ri, hillshade: ai, line: ni, lineGradient: si, linePattern: li, lineSDF: ci, raster: ui, symbolIcon: hi, symbolSDF: pi, symbolTextAndIcon: di }), mi = function() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        };
        mi.prototype.bind = function(t2, e2, i2, o2, r2, a2, n2, s2) {
          this.context = t2;
          for (var l2 = this.boundPaintVertexBuffers.length !== o2.length, c2 = 0; !l2 && c2 < o2.length; c2++)
            this.boundPaintVertexBuffers[c2] !== o2[c2] && (l2 = true);
          var u2 = !this.vao || this.boundProgram !== e2 || this.boundLayoutVertexBuffer !== i2 || l2 || this.boundIndexBuffer !== r2 || this.boundVertexOffset !== a2 || this.boundDynamicVertexBuffer !== n2 || this.boundDynamicVertexBuffer2 !== s2;
          !t2.extVertexArrayObject || u2 ? this.freshBind(e2, i2, o2, r2, a2, n2, s2) : (t2.bindVertexArrayOES.set(this.vao), n2 && n2.bind(), r2 && r2.dynamicDraw && r2.bind(), s2 && s2.bind());
        }, mi.prototype.freshBind = function(t2, e2, i2, o2, r2, a2, n2) {
          var s2, l2 = t2.numAttributes, c2 = this.context, u2 = c2.gl;
          if (c2.extVertexArrayObject)
            this.vao && this.destroy(), this.vao = c2.extVertexArrayObject.createVertexArrayOES(), c2.bindVertexArrayOES.set(this.vao), s2 = 0, this.boundProgram = t2, this.boundLayoutVertexBuffer = e2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = r2, this.boundDynamicVertexBuffer = a2, this.boundDynamicVertexBuffer2 = n2;
          else {
            s2 = c2.currentNumAttributes || 0;
            for (var h2 = l2; h2 < s2; h2++)
              u2.disableVertexAttribArray(h2);
          }
          e2.enableAttributes(u2, t2);
          for (var p2 = 0, d2 = i2; p2 < d2.length; p2 += 1) {
            d2[p2].enableAttributes(u2, t2);
          }
          a2 && a2.enableAttributes(u2, t2), n2 && n2.enableAttributes(u2, t2), e2.bind(), e2.setVertexAttribPointers(u2, t2, r2);
          for (var _2 = 0, f2 = i2; _2 < f2.length; _2 += 1) {
            var m2 = f2[_2];
            m2.bind(), m2.setVertexAttribPointers(u2, t2, r2);
          }
          a2 && (a2.bind(), a2.setVertexAttribPointers(u2, t2, r2)), o2 && o2.bind(), n2 && (n2.bind(), n2.setVertexAttribPointers(u2, t2, r2)), c2.currentNumAttributes = l2;
        }, mi.prototype.destroy = function() {
          this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
        };
        var gi = function(t2, e2, i2, o2, r2) {
          var a2 = t2.gl;
          this.program = a2.createProgram();
          var n2 = i2.defines();
          r2 && n2.push("#define OVERDRAW_INSPECTOR;");
          var s2 = n2.concat(qe.fragmentSource, e2.fragmentSource).join("\n"), l2 = n2.concat(qe.vertexSource, e2.vertexSource).join("\n"), c2 = a2.createShader(a2.FRAGMENT_SHADER);
          if (a2.isContextLost())
            this.failedToCreate = true;
          else {
            a2.shaderSource(c2, s2), a2.compileShader(c2), a2.attachShader(this.program, c2);
            var u2 = a2.createShader(a2.VERTEX_SHADER);
            if (a2.isContextLost())
              this.failedToCreate = true;
            else {
              a2.shaderSource(u2, l2), a2.compileShader(u2), a2.attachShader(this.program, u2);
              for (var h2 = i2.layoutAttributes || [], p2 = 0; p2 < h2.length; p2++)
                a2.bindAttribLocation(this.program, p2, h2[p2].name);
              a2.linkProgram(this.program), this.numAttributes = a2.getProgramParameter(this.program, a2.ACTIVE_ATTRIBUTES), this.attributes = {};
              for (var d2 = {}, _2 = 0; _2 < this.numAttributes; _2++) {
                var f2 = a2.getActiveAttrib(this.program, _2);
                f2 && (this.attributes[f2.name] = a2.getAttribLocation(this.program, f2.name));
              }
              for (var m2 = a2.getProgramParameter(this.program, a2.ACTIVE_UNIFORMS), g2 = 0; g2 < m2; g2++) {
                var v2 = a2.getActiveUniform(this.program, g2);
                v2 && (d2[v2.name] = a2.getUniformLocation(this.program, v2.name));
              }
              this.fixedUniforms = o2(t2, d2), this.binderUniforms = i2.getUniforms(t2, d2);
            }
          }
        };
        function vi(e2, i2, o2) {
          var r2 = 1 / ue(o2, 1, i2.transform.tileZoom), a2 = Math.pow(2, o2.tileID.overscaledZ), n2 = o2.tileSize * Math.pow(2, i2.transform.tileZoom) / a2, s2 = n2 * (o2.tileID.canonical.x + o2.tileID.wrap * a2), l2 = n2 * o2.tileID.canonical.y;
          return { u_image: 0, u_texsize: o2.imageAtlasTexture.size, u_scale: [t.browser.devicePixelRatio, r2, e2.fromScale, e2.toScale], u_fade: e2.t, u_pixel_coord_upper: [s2 >> 16, l2 >> 16], u_pixel_coord_lower: [65535 & s2, 65535 & l2] };
        }
        gi.prototype.draw = function(t2, e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2, d2, _2, f2) {
          var m2, g2 = t2.gl;
          if (!this.failedToCreate) {
            for (var v2 in t2.program.set(this.program), t2.setDepthMode(i2), t2.setStencilMode(o2), t2.setColorMode(r2), t2.setCullFace(a2), this.fixedUniforms)
              this.fixedUniforms[v2].set(n2[v2]);
            d2 && d2.setUniforms(t2, this.binderUniforms, h2, { zoom: p2 });
            for (var y2 = (m2 = {}, m2[g2.LINES] = 2, m2[g2.TRIANGLES] = 3, m2[g2.LINE_STRIP] = 1, m2)[e2], x2 = 0, b2 = u2.get(); x2 < b2.length; x2 += 1) {
              var w2 = b2[x2], E2 = w2.vaos || (w2.vaos = {});
              (E2[s2] || (E2[s2] = new mi())).bind(t2, this, l2, d2 ? d2.getPaintVertexBuffers() : [], c2, w2.vertexOffset, _2, f2), g2.drawElements(e2, w2.primitiveLength * y2, g2.UNSIGNED_SHORT, w2.primitiveOffset * y2 * 2);
            }
          }
        };
        var yi = function(e2, i2, o2, r2) {
          var a2 = i2.style.light, n2 = a2.properties.get("position"), s2 = [n2.x, n2.y, n2.z], l2 = t.create$1();
          "viewport" === a2.properties.get("anchor") && t.fromRotation(l2, -i2.transform.angle), t.transformMat3(s2, s2, l2);
          var c2 = a2.properties.get("color");
          return { u_matrix: e2, u_lightpos: s2, u_lightintensity: a2.properties.get("intensity"), u_lightcolor: [c2.r, c2.g, c2.b], u_vertical_gradient: +o2, u_opacity: r2 };
        }, xi = function(e2, i2, o2, r2, a2, n2, s2) {
          return t.extend(yi(e2, i2, o2, r2), vi(n2, i2, s2), { u_height_factor: -Math.pow(2, a2.overscaledZ) / s2.tileSize / 8 });
        }, bi = function(t2) {
          return { u_matrix: t2 };
        }, wi = function(e2, i2, o2, r2) {
          return t.extend(bi(e2), vi(o2, i2, r2));
        }, Ei = function(t2, e2) {
          return { u_matrix: t2, u_world: e2 };
        }, Ti = function(e2, i2, o2, r2, a2) {
          return t.extend(wi(e2, i2, o2, r2), { u_world: a2 });
        }, Ii = function(e2, i2, o2, r2) {
          var a2, n2, s2 = e2.transform;
          if ("map" === r2.paint.get("circle-pitch-alignment")) {
            var l2 = ue(o2, 1, s2.zoom);
            a2 = true, n2 = [l2, l2];
          } else
            a2 = false, n2 = s2.pixelsToGLUnits;
          return { u_camera_to_center_distance: s2.cameraToCenterDistance, u_scale_with_map: +("map" === r2.paint.get("circle-pitch-scale")), u_matrix: e2.translatePosMatrix(i2.posMatrix, o2, r2.paint.get("circle-translate"), r2.paint.get("circle-translate-anchor")), u_pitch_with_map: +a2, u_device_pixel_ratio: t.browser.devicePixelRatio, u_extrude_scale: n2 };
        }, Si = function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pixels_to_tile_units: new t.Uniform1f(e2, i2.u_pixels_to_tile_units), u_extrude_scale: new t.Uniform2f(e2, i2.u_extrude_scale), u_overscale_factor: new t.Uniform1f(e2, i2.u_overscale_factor) };
        }, Ci = function(t2, e2, i2) {
          var o2 = ue(i2, 1, e2.zoom), r2 = Math.pow(2, e2.zoom - i2.tileID.overscaledZ), a2 = i2.tileID.overscaleFactor();
          return { u_matrix: t2, u_camera_to_center_distance: e2.cameraToCenterDistance, u_pixels_to_tile_units: o2, u_extrude_scale: [e2.pixelsToGLUnits[0] / (o2 * r2), e2.pixelsToGLUnits[1] / (o2 * r2)], u_overscale_factor: a2 };
        }, Pi = function(t2, e2) {
          return { u_matrix: t2, u_color: e2 };
        }, zi = function(t2) {
          return { u_matrix: t2 };
        }, Mi = function(t2, e2, i2, o2) {
          return { u_matrix: t2, u_extrude_scale: ue(e2, 1, i2), u_intensity: o2 };
        };
        function Li(e2, i2) {
          var o2 = Math.pow(2, i2.canonical.z), r2 = i2.canonical.y;
          return [new t.MercatorCoordinate(0, r2 / o2).toLngLat().lat, new t.MercatorCoordinate(0, (r2 + 1) / o2).toLngLat().lat];
        }
        var Di = function(e2, i2, o2) {
          var r2 = e2.transform;
          return { u_matrix: Oi(e2, i2, o2), u_ratio: 1 / ue(i2, 1, r2.zoom), u_device_pixel_ratio: t.browser.devicePixelRatio, u_units_to_pixels: [1 / r2.pixelsToGLUnits[0], 1 / r2.pixelsToGLUnits[1]] };
        }, Ai = function(e2, i2, o2) {
          return t.extend(Di(e2, i2, o2), { u_image: 0 });
        }, Ri = function(e2, i2, o2, r2) {
          var a2 = e2.transform, n2 = Bi(i2, a2);
          return { u_matrix: Oi(e2, i2, o2), u_texsize: i2.imageAtlasTexture.size, u_ratio: 1 / ue(i2, 1, a2.zoom), u_device_pixel_ratio: t.browser.devicePixelRatio, u_image: 0, u_scale: [t.browser.devicePixelRatio, n2, r2.fromScale, r2.toScale], u_fade: r2.t, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]] };
        }, ki = function(e2, i2, o2, r2, a2) {
          var n2 = e2.transform, s2 = e2.lineAtlas, l2 = Bi(i2, n2), c2 = "round" === o2.layout.get("line-cap"), u2 = s2.getDash(r2.from, c2), h2 = s2.getDash(r2.to, c2), p2 = u2.width * a2.fromScale, d2 = h2.width * a2.toScale;
          return t.extend(Di(e2, i2, o2), { u_patternscale_a: [l2 / p2, -u2.height / 2], u_patternscale_b: [l2 / d2, -h2.height / 2], u_sdfgamma: s2.width / (256 * Math.min(p2, d2) * t.browser.devicePixelRatio) / 2, u_image: 0, u_tex_y_a: u2.y, u_tex_y_b: h2.y, u_mix: a2.t });
        };
        function Bi(t2, e2) {
          return 1 / ue(t2, 1, e2.tileZoom);
        }
        function Oi(t2, e2, i2) {
          return t2.translatePosMatrix(e2.tileID.posMatrix, e2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
        }
        var Fi = function(t2, e2, i2, o2, r2) {
          return { u_matrix: t2, u_tl_parent: e2, u_scale_parent: i2, u_buffer_scale: 1, u_fade_t: o2.mix, u_opacity: o2.opacity * r2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r2.paint.get("raster-brightness-min"), u_brightness_high: r2.paint.get("raster-brightness-max"), u_saturation_factor: (n2 = r2.paint.get("raster-saturation"), n2 > 0 ? 1 - 1 / (1.001 - n2) : -n2), u_contrast_factor: (a2 = r2.paint.get("raster-contrast"), a2 > 0 ? 1 / (1 - a2) : 1 + a2), u_spin_weights: Ui(r2.paint.get("raster-hue-rotate")) };
          var a2, n2;
        };
        function Ui(t2) {
          t2 *= Math.PI / 180;
          var e2 = Math.sin(t2), i2 = Math.cos(t2);
          return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * e2 - i2 + 1) / 3, (Math.sqrt(3) * e2 - i2 + 1) / 3];
        }
        var Ni = function(t2, e2, i2, o2, r2, a2, n2, s2, l2, c2) {
          var u2 = r2.transform;
          return { u_is_size_zoom_constant: +("constant" === t2 || "source" === t2), u_is_size_feature_constant: +("constant" === t2 || "camera" === t2), u_size_t: e2 ? e2.uSizeT : 0, u_size: e2 ? e2.uSize : 0, u_camera_to_center_distance: u2.cameraToCenterDistance, u_pitch: u2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: u2.width / u2.height, u_fade_change: r2.options.fadeDuration ? r2.symbolFadeChange : 1, u_matrix: a2, u_label_plane_matrix: n2, u_coord_matrix: s2, u_is_text: +l2, u_pitch_with_map: +o2, u_texsize: c2, u_texture: 0 };
        }, Zi = function(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2) {
          var p2 = a2.transform;
          return t.extend(Ni(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2), { u_gamma_scale: r2 ? Math.cos(p2._pitch) * p2.cameraToCenterDistance : 1, u_device_pixel_ratio: t.browser.devicePixelRatio, u_is_halo: +h2 });
        }, qi = function(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2) {
          return t.extend(Zi(e2, i2, o2, r2, a2, n2, s2, l2, true, c2, true), { u_texsize_icon: u2, u_texture_icon: 1 });
        }, ji = function(t2, e2, i2) {
          return { u_matrix: t2, u_opacity: e2, u_color: i2 };
        }, Vi = function(e2, i2, o2, r2, a2, n2) {
          return t.extend(function(t2, e3, i3, o3) {
            var r3 = i3.imageManager.getPattern(t2.from.toString()), a3 = i3.imageManager.getPattern(t2.to.toString()), n3 = i3.imageManager.getPixelSize(), s2 = n3.width, l2 = n3.height, c2 = Math.pow(2, o3.tileID.overscaledZ), u2 = o3.tileSize * Math.pow(2, i3.transform.tileZoom) / c2, h2 = u2 * (o3.tileID.canonical.x + o3.tileID.wrap * c2), p2 = u2 * o3.tileID.canonical.y;
            return { u_image: 0, u_pattern_tl_a: r3.tl, u_pattern_br_a: r3.br, u_pattern_tl_b: a3.tl, u_pattern_br_b: a3.br, u_texsize: [s2, l2], u_mix: e3.t, u_pattern_size_a: r3.displaySize, u_pattern_size_b: a3.displaySize, u_scale_a: e3.fromScale, u_scale_b: e3.toScale, u_tile_units_to_pixels: 1 / ue(o3, 1, i3.transform.tileZoom), u_pixel_coord_upper: [h2 >> 16, p2 >> 16], u_pixel_coord_lower: [65535 & h2, 65535 & p2] };
          }(r2, n2, o2, a2), { u_matrix: e2, u_opacity: i2 });
        }, Gi = { fillExtrusion: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_lightpos: new t.Uniform3f(e2, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e2, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e2, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e2, i2.u_vertical_gradient), u_opacity: new t.Uniform1f(e2, i2.u_opacity) };
        }, fillExtrusionPattern: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_lightpos: new t.Uniform3f(e2, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e2, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e2, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e2, i2.u_vertical_gradient), u_height_factor: new t.Uniform1f(e2, i2.u_height_factor), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform4f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade), u_opacity: new t.Uniform1f(e2, i2.u_opacity) };
        }, fill: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) };
        }, fillPattern: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform4f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) };
        }, fillOutline: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world) };
        }, fillOutlinePattern: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform4f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) };
        }, circle: function(e2, i2) {
          return { u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_scale_with_map: new t.Uniform1i(e2, i2.u_scale_with_map), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_extrude_scale: new t.Uniform2f(e2, i2.u_extrude_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) };
        }, collisionBox: Si, collisionCircle: Si, debug: function(e2, i2) {
          return { u_color: new t.UniformColor(e2, i2.u_color), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) };
        }, clippingMask: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) };
        }, heatmap: function(e2, i2) {
          return { u_extrude_scale: new t.Uniform1f(e2, i2.u_extrude_scale), u_intensity: new t.Uniform1f(e2, i2.u_intensity), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) };
        }, heatmapTexture: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world), u_image: new t.Uniform1i(e2, i2.u_image), u_color_ramp: new t.Uniform1i(e2, i2.u_color_ramp), u_opacity: new t.Uniform1f(e2, i2.u_opacity) };
        }, hillshade: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_latrange: new t.Uniform2f(e2, i2.u_latrange), u_light: new t.Uniform2f(e2, i2.u_light), u_shadow: new t.UniformColor(e2, i2.u_shadow), u_highlight: new t.UniformColor(e2, i2.u_highlight), u_accent: new t.UniformColor(e2, i2.u_accent) };
        }, hillshadePrepare: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_dimension: new t.Uniform2f(e2, i2.u_dimension), u_zoom: new t.Uniform1f(e2, i2.u_zoom), u_maxzoom: new t.Uniform1f(e2, i2.u_maxzoom), u_unpack: new t.Uniform4f(e2, i2.u_unpack) };
        }, line: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels) };
        }, lineGradient: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_image: new t.Uniform1i(e2, i2.u_image) };
        }, linePattern: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_image: new t.Uniform1i(e2, i2.u_image), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_scale: new t.Uniform4f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) };
        }, lineSDF: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_patternscale_a: new t.Uniform2f(e2, i2.u_patternscale_a), u_patternscale_b: new t.Uniform2f(e2, i2.u_patternscale_b), u_sdfgamma: new t.Uniform1f(e2, i2.u_sdfgamma), u_image: new t.Uniform1i(e2, i2.u_image), u_tex_y_a: new t.Uniform1f(e2, i2.u_tex_y_a), u_tex_y_b: new t.Uniform1f(e2, i2.u_tex_y_b), u_mix: new t.Uniform1f(e2, i2.u_mix) };
        }, raster: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_tl_parent: new t.Uniform2f(e2, i2.u_tl_parent), u_scale_parent: new t.Uniform1f(e2, i2.u_scale_parent), u_buffer_scale: new t.Uniform1f(e2, i2.u_buffer_scale), u_fade_t: new t.Uniform1f(e2, i2.u_fade_t), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_image0: new t.Uniform1i(e2, i2.u_image0), u_image1: new t.Uniform1i(e2, i2.u_image1), u_brightness_low: new t.Uniform1f(e2, i2.u_brightness_low), u_brightness_high: new t.Uniform1f(e2, i2.u_brightness_high), u_saturation_factor: new t.Uniform1f(e2, i2.u_saturation_factor), u_contrast_factor: new t.Uniform1f(e2, i2.u_contrast_factor), u_spin_weights: new t.Uniform3f(e2, i2.u_spin_weights) };
        }, symbolIcon: function(e2, i2) {
          return { u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1f(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texture: new t.Uniform1i(e2, i2.u_texture) };
        }, symbolSDF: function(e2, i2) {
          return { u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1f(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texture: new t.Uniform1i(e2, i2.u_texture), u_gamma_scale: new t.Uniform1f(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1f(e2, i2.u_is_halo) };
        }, symbolTextAndIcon: function(e2, i2) {
          return { u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1f(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texsize_icon: new t.Uniform2f(e2, i2.u_texsize_icon), u_texture: new t.Uniform1i(e2, i2.u_texture), u_texture_icon: new t.Uniform1i(e2, i2.u_texture_icon), u_gamma_scale: new t.Uniform1f(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1f(e2, i2.u_is_halo) };
        }, background: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_color: new t.UniformColor(e2, i2.u_color) };
        }, backgroundPattern: function(e2, i2) {
          return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_image: new t.Uniform1i(e2, i2.u_image), u_pattern_tl_a: new t.Uniform2f(e2, i2.u_pattern_tl_a), u_pattern_br_a: new t.Uniform2f(e2, i2.u_pattern_br_a), u_pattern_tl_b: new t.Uniform2f(e2, i2.u_pattern_tl_b), u_pattern_br_b: new t.Uniform2f(e2, i2.u_pattern_br_b), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_mix: new t.Uniform1f(e2, i2.u_mix), u_pattern_size_a: new t.Uniform2f(e2, i2.u_pattern_size_a), u_pattern_size_b: new t.Uniform2f(e2, i2.u_pattern_size_b), u_scale_a: new t.Uniform1f(e2, i2.u_scale_a), u_scale_b: new t.Uniform1f(e2, i2.u_scale_b), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new t.Uniform1f(e2, i2.u_tile_units_to_pixels) };
        } };
        function Wi(t2, e2, i2, o2, r2, a2, n2, s2) {
          for (var l2 = t2.context, c2 = l2.gl, u2 = r2 ? t2.useProgram("collisionCircle") : t2.useProgram("collisionBox"), h2 = 0; h2 < o2.length; h2++) {
            var p2 = o2[h2], d2 = e2.getTile(p2), _2 = d2.getBucket(i2);
            if (_2) {
              var f2 = r2 ? s2 ? _2.textCollisionCircle : _2.iconCollisionCircle : s2 ? _2.textCollisionBox : _2.iconCollisionBox;
              if (f2) {
                var m2 = p2.posMatrix;
                0 === a2[0] && 0 === a2[1] || (m2 = t2.translatePosMatrix(p2.posMatrix, d2, a2, n2)), u2.draw(l2, r2 ? c2.TRIANGLES : c2.LINES, It.disabled, St.disabled, t2.colorModeForRenderPass(), Pt.disabled, Ci(m2, t2.transform, d2), i2.id, f2.layoutVertexBuffer, f2.indexBuffer, f2.segments, null, t2.transform.zoom, null, null, f2.collisionVertexBuffer);
              }
            }
          }
        }
        function Xi(t2, e2, i2, o2, r2, a2, n2) {
          Wi(t2, e2, i2, o2, false, r2, a2, n2), Wi(t2, e2, i2, o2, true, r2, a2, n2);
        }
        var Hi = t.identity(new Float32Array(16));
        function Ki(e2, i2, o2, r2, a2, n2) {
          var s2 = t.getAnchorAlignment(e2), l2 = -(s2.horizontalAlign - 0.5) * i2, c2 = -(s2.verticalAlign - 0.5) * o2, u2 = t.evaluateVariableOffset(e2, r2);
          return new t.Point((l2 / a2 + u2[0]) * n2, (c2 / a2 + u2[1]) * n2);
        }
        function Yi(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2) {
          var p2 = e2.text.placedSymbolArray, d2 = e2.text.dynamicLayoutVertexArray, _2 = e2.icon.dynamicLayoutVertexArray, f2 = {};
          d2.clear();
          for (var m2 = 0; m2 < p2.length; m2++) {
            var g2 = p2.get(m2), v2 = e2.allowVerticalPlacement && !g2.placedOrientation, y2 = g2.hidden || !g2.crossTileID || v2 ? null : r2[g2.crossTileID];
            if (y2) {
              var x2 = new t.Point(g2.anchorX, g2.anchorY), b2 = Jt(x2, o2 ? l2 : s2), w2 = 0.5 + n2.cameraToCenterDistance / b2.signedDistanceFromCamera * 0.5, E2 = a2.evaluateSizeForFeature(e2.textSizeData, u2, g2) * w2 / t.ONE_EM;
              o2 && (E2 *= e2.tilePixelRatio / c2);
              for (var T2 = y2.width, I2 = y2.height, S2 = Ki(y2.anchor, T2, I2, y2.textOffset, y2.textBoxScale, E2), C2 = o2 ? Jt(x2.add(S2), s2).point : b2.point.add(i2 ? S2.rotate(-n2.angle) : S2), P2 = e2.allowVerticalPlacement && g2.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0, z2 = 0; z2 < g2.numGlyphs; z2++)
                t.addDynamicAttributes(d2, C2, P2);
              h2 && g2.associatedIconIndex >= 0 && (f2[g2.associatedIconIndex] = { shiftedAnchor: C2, angle: P2 });
            } else
              ne(g2.numGlyphs, d2);
          }
          if (h2) {
            _2.clear();
            for (var M2 = e2.icon.placedSymbolArray, L2 = 0; L2 < M2.length; L2++) {
              var D2 = M2.get(L2);
              if (D2.hidden)
                ne(D2.numGlyphs, _2);
              else {
                var A2 = f2[L2];
                if (A2)
                  for (var R2 = 0; R2 < D2.numGlyphs; R2++)
                    t.addDynamicAttributes(_2, A2.shiftedAnchor, A2.angle);
                else
                  ne(D2.numGlyphs, _2);
              }
            }
            e2.icon.dynamicLayoutVertexBuffer.updateData(_2);
          }
          e2.text.dynamicLayoutVertexBuffer.updateData(d2);
        }
        function Ji(t2, e2, i2) {
          return i2.iconsInText && e2 ? "symbolTextAndIcon" : t2 ? "symbolSDF" : "symbolIcon";
        }
        function Qi(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2) {
          for (var d2, _2, f2 = e2.context, m2 = f2.gl, g2 = e2.transform, v2 = "map" === l2, y2 = "map" === c2, x2 = v2 && "point" !== o2.layout.get("symbol-placement"), b2 = v2 && !y2 && !x2, w2 = void 0 !== o2.layout.get("symbol-sort-key").constantOr(1), E2 = e2.depthModeForSublayer(0, It.ReadOnly), T2 = o2.layout.get("text-variable-anchor"), I2 = [], S2 = 0, C2 = r2; S2 < C2.length; S2 += 1) {
            var P2 = C2[S2], z2 = i2.getTile(P2), M2 = z2.getBucket(o2);
            if (M2) {
              var L2 = a2 ? M2.text : M2.icon;
              if (L2 && L2.segments.get().length) {
                var D2 = L2.programConfigurations.get(o2.id), A2 = a2 || M2.sdfIcons, R2 = a2 ? M2.textSizeData : M2.iconSizeData, k2 = y2 || 0 !== g2.pitch;
                d2 || (d2 = e2.useProgram(Ji(A2, a2, M2), D2), _2 = t.evaluateSizeForZoom(R2, g2.zoom));
                var B2 = void 0, O2 = [0, 0], F2 = void 0, U2 = void 0, N2 = null, Z2 = void 0;
                if (a2) {
                  if (F2 = z2.glyphAtlasTexture, U2 = m2.LINEAR, B2 = z2.glyphAtlasTexture.size, M2.iconsInText) {
                    O2 = z2.imageAtlasTexture.size, N2 = z2.imageAtlasTexture;
                    var q2 = "composite" === R2.kind || "camera" === R2.kind;
                    Z2 = k2 || e2.options.rotating || e2.options.zooming || q2 ? m2.LINEAR : m2.NEAREST;
                  }
                } else {
                  var j2 = 1 !== o2.layout.get("icon-size").constantOr(0) || M2.iconsNeedLinear;
                  F2 = z2.imageAtlasTexture, U2 = A2 || e2.options.rotating || e2.options.zooming || j2 || k2 ? m2.LINEAR : m2.NEAREST, B2 = z2.imageAtlasTexture.size;
                }
                var V2 = ue(z2, 1, e2.transform.zoom), G2 = Kt(P2.posMatrix, y2, v2, e2.transform, V2), W2 = Yt(P2.posMatrix, y2, v2, e2.transform, V2), X2 = T2 && M2.hasTextData(), H2 = "none" !== o2.layout.get("icon-text-fit") && X2 && M2.hasIconData();
                x2 && $t(M2, P2.posMatrix, e2, a2, G2, W2, y2, u2);
                var K2 = e2.translatePosMatrix(P2.posMatrix, z2, n2, s2), Y2 = x2 || a2 && T2 || H2 ? Hi : G2, J2 = e2.translatePosMatrix(W2, z2, n2, s2, true), Q2 = A2 && 0 !== o2.paint.get(a2 ? "text-halo-width" : "icon-halo-width").constantOr(1), $2 = { program: d2, buffers: L2, uniformValues: A2 ? M2.iconsInText ? qi(R2.kind, _2, b2, y2, e2, K2, Y2, J2, B2, O2) : Zi(R2.kind, _2, b2, y2, e2, K2, Y2, J2, a2, B2, true) : Ni(R2.kind, _2, b2, y2, e2, K2, Y2, J2, a2, B2), atlasTexture: F2, atlasTextureIcon: N2, atlasInterpolation: U2, atlasInterpolationIcon: Z2, isSDF: A2, hasHalo: Q2 };
                if (w2)
                  for (var tt2 = 0, et2 = L2.segments.get(); tt2 < et2.length; tt2 += 1) {
                    var it2 = et2[tt2];
                    I2.push({ segments: new t.SegmentVector([it2]), sortKey: it2.sortKey, state: $2 });
                  }
                else
                  I2.push({ segments: L2.segments, sortKey: 0, state: $2 });
              }
            }
          }
          w2 && I2.sort(function(t2, e3) {
            return t2.sortKey - e3.sortKey;
          });
          for (var ot2 = 0, rt2 = I2; ot2 < rt2.length; ot2 += 1) {
            var at2 = rt2[ot2], nt2 = at2.state;
            if (f2.activeTexture.set(m2.TEXTURE0), nt2.atlasTexture.bind(nt2.atlasInterpolation, m2.CLAMP_TO_EDGE), nt2.atlasTextureIcon && (f2.activeTexture.set(m2.TEXTURE1), nt2.atlasTextureIcon && nt2.atlasTextureIcon.bind(nt2.atlasInterpolationIcon, m2.CLAMP_TO_EDGE)), nt2.isSDF) {
              var st2 = nt2.uniformValues;
              nt2.hasHalo && (st2.u_is_halo = 1, $i(nt2.buffers, at2.segments, o2, e2, nt2.program, E2, h2, p2, st2)), st2.u_is_halo = 0;
            }
            $i(nt2.buffers, at2.segments, o2, e2, nt2.program, E2, h2, p2, nt2.uniformValues);
          }
        }
        function $i(t2, e2, i2, o2, r2, a2, n2, s2, l2) {
          var c2 = o2.context, u2 = c2.gl;
          r2.draw(c2, u2.TRIANGLES, a2, n2, s2, Pt.disabled, l2, i2.id, t2.layoutVertexBuffer, t2.indexBuffer, e2, i2.paint, o2.transform.zoom, t2.programConfigurations.get(i2.id), t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer);
        }
        function to(t2, e2, i2, o2, r2, a2, n2) {
          var s2, l2, c2, u2, h2, p2 = t2.context.gl, d2 = i2.paint.get("fill-pattern"), _2 = d2 && d2.constantOr(1), f2 = i2.getCrossfadeParameters();
          n2 ? (l2 = _2 && !i2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", s2 = p2.LINES) : (l2 = _2 ? "fillPattern" : "fill", s2 = p2.TRIANGLES);
          for (var m2 = 0, g2 = o2; m2 < g2.length; m2 += 1) {
            var v2 = g2[m2], y2 = e2.getTile(v2);
            if (!_2 || y2.patternsLoaded()) {
              var x2 = y2.getBucket(i2);
              if (x2) {
                var b2 = x2.programConfigurations.get(i2.id), w2 = t2.useProgram(l2, b2);
                _2 && (t2.context.activeTexture.set(p2.TEXTURE0), y2.imageAtlasTexture.bind(p2.LINEAR, p2.CLAMP_TO_EDGE), b2.updatePatternPaintBuffers(f2));
                var E2 = d2.constantOr(null);
                if (E2 && y2.imageAtlas) {
                  var T2 = y2.imageAtlas, I2 = T2.patternPositions[E2.to.toString()], S2 = T2.patternPositions[E2.from.toString()];
                  I2 && S2 && b2.setConstantPatternPositions(I2, S2);
                }
                var C2 = t2.translatePosMatrix(v2.posMatrix, y2, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor"));
                if (n2) {
                  u2 = x2.indexBuffer2, h2 = x2.segments2;
                  var P2 = [p2.drawingBufferWidth, p2.drawingBufferHeight];
                  c2 = "fillOutlinePattern" === l2 && _2 ? Ti(C2, t2, f2, y2, P2) : Ei(C2, P2);
                } else
                  u2 = x2.indexBuffer, h2 = x2.segments, c2 = _2 ? wi(C2, t2, f2, y2) : bi(C2);
                w2.draw(t2.context, s2, r2, t2.stencilModeForClipping(v2), a2, Pt.disabled, c2, i2.id, x2.layoutVertexBuffer, u2, h2, i2.paint, t2.transform.zoom, b2);
              }
            }
          }
        }
        function eo(t2, e2, i2, o2, r2, a2, n2) {
          for (var s2 = t2.context, l2 = s2.gl, c2 = i2.paint.get("fill-extrusion-pattern"), u2 = c2.constantOr(1), h2 = i2.getCrossfadeParameters(), p2 = i2.paint.get("fill-extrusion-opacity"), d2 = 0, _2 = o2; d2 < _2.length; d2 += 1) {
            var f2 = _2[d2], m2 = e2.getTile(f2), g2 = m2.getBucket(i2);
            if (g2) {
              var v2 = g2.programConfigurations.get(i2.id), y2 = t2.useProgram(u2 ? "fillExtrusionPattern" : "fillExtrusion", v2);
              u2 && (t2.context.activeTexture.set(l2.TEXTURE0), m2.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), v2.updatePatternPaintBuffers(h2));
              var x2 = c2.constantOr(null);
              if (x2 && m2.imageAtlas) {
                var b2 = m2.imageAtlas, w2 = b2.patternPositions[x2.to.toString()], E2 = b2.patternPositions[x2.from.toString()];
                w2 && E2 && v2.setConstantPatternPositions(w2, E2);
              }
              var T2 = t2.translatePosMatrix(f2.posMatrix, m2, i2.paint.get("fill-extrusion-translate"), i2.paint.get("fill-extrusion-translate-anchor")), I2 = i2.paint.get("fill-extrusion-vertical-gradient"), S2 = u2 ? xi(T2, t2, I2, p2, f2, h2, m2) : yi(T2, t2, I2, p2);
              y2.draw(s2, s2.gl.TRIANGLES, r2, a2, n2, Pt.backCCW, S2, i2.id, g2.layoutVertexBuffer, g2.indexBuffer, g2.segments, i2.paint, t2.transform.zoom, v2);
            }
          }
        }
        function io(t2, e2, i2, o2, r2, a2) {
          var n2 = t2.context, s2 = n2.gl, l2 = e2.fbo;
          if (l2) {
            var c2 = t2.useProgram("hillshade");
            n2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, l2.colorAttachment.get());
            var u2 = function(t3, e3, i3) {
              var o3 = i3.paint.get("hillshade-shadow-color"), r3 = i3.paint.get("hillshade-highlight-color"), a3 = i3.paint.get("hillshade-accent-color"), n3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
              "viewport" === i3.paint.get("hillshade-illumination-anchor") && (n3 -= t3.transform.angle);
              var s3 = !t3.options.moving;
              return { u_matrix: t3.transform.calculatePosMatrix(e3.tileID.toUnwrapped(), s3), u_image: 0, u_latrange: Li(t3, e3.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), n3], u_shadow: o3, u_highlight: r3, u_accent: a3 };
            }(t2, e2, i2);
            c2.draw(n2, s2.TRIANGLES, o2, r2, a2, Pt.disabled, u2, i2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
          }
        }
        function oo(e2, i2, o2, r2, a2, n2, s2) {
          var l2 = e2.context, c2 = l2.gl, u2 = i2.dem;
          if (u2 && u2.data) {
            var h2 = u2.dim, p2 = u2.stride, d2 = u2.getPixels();
            if (l2.activeTexture.set(c2.TEXTURE1), l2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || e2.getTileTexture(p2), i2.demTexture) {
              var _2 = i2.demTexture;
              _2.update(d2, { premultiply: false }), _2.bind(c2.NEAREST, c2.CLAMP_TO_EDGE);
            } else
              i2.demTexture = new t.Texture(l2, d2, c2.RGBA, { premultiply: false }), i2.demTexture.bind(c2.NEAREST, c2.CLAMP_TO_EDGE);
            l2.activeTexture.set(c2.TEXTURE0);
            var f2 = i2.fbo;
            if (!f2) {
              var m2 = new t.Texture(l2, { width: h2, height: h2, data: null }, c2.RGBA);
              m2.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), (f2 = i2.fbo = l2.createFramebuffer(h2, h2)).colorAttachment.set(m2.texture);
            }
            l2.bindFramebuffer.set(f2.framebuffer), l2.viewport.set([0, 0, h2, h2]), e2.useProgram("hillshadePrepare").draw(l2, c2.TRIANGLES, a2, n2, s2, Pt.disabled, function(e3, i3, o3) {
              var r3 = i3.stride, a3 = t.create();
              return t.ortho(a3, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(a3, a3, [0, -t.EXTENT, 0]), { u_matrix: a3, u_image: 1, u_dimension: [r3, r3], u_zoom: e3.overscaledZ, u_maxzoom: o3, u_unpack: i3.getUnpackVector() };
            }(i2.tileID, u2, r2), o2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments), i2.needsHillshadePrepare = false;
          }
        }
        function ro(e2, i2, o2, r2, a2) {
          var n2 = r2.paint.get("raster-fade-duration");
          if (n2 > 0) {
            var s2 = t.browser.now(), l2 = (s2 - e2.timeAdded) / n2, c2 = i2 ? (s2 - i2.timeAdded) / n2 : -1, u2 = o2.getSource(), h2 = a2.coveringZoomLevel({ tileSize: u2.tileSize, roundZoom: u2.roundZoom }), p2 = !i2 || Math.abs(i2.tileID.overscaledZ - h2) > Math.abs(e2.tileID.overscaledZ - h2), d2 = p2 && e2.refreshedUponExpiration ? 1 : t.clamp(p2 ? l2 : 1 - c2, 0, 1);
            return e2.refreshedUponExpiration && l2 >= 1 && (e2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - d2 } : { opacity: d2, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        function ao(e2, i2, o2) {
          var r2 = e2.context, a2 = r2.gl, n2 = o2.posMatrix, s2 = e2.useProgram("debug"), l2 = It.disabled, c2 = St.disabled, u2 = e2.colorModeForRenderPass(), h2 = "$debug";
          s2.draw(r2, a2.LINE_STRIP, l2, c2, u2, Pt.disabled, Pi(n2, t.Color.red), h2, e2.debugBuffer, e2.tileBorderIndexBuffer, e2.debugSegments);
          var p2 = i2.getTileByID(o2.key).latestRawTileData, d2 = p2 && p2.byteLength || 0, _2 = Math.floor(d2 / 1024), f2 = i2.getTile(o2).tileSize, m2 = 512 / Math.min(f2, 512), g2 = o2.canonical.toString();
          o2.overscaledZ !== o2.canonical.z && (g2 += " => " + o2.overscaledZ);
          for (var v2 = function(t2, e3, i3, o3) {
            o3 = o3 || 1;
            var r3, a3, n3, s3, l3, c3, u3, h3, p3 = [];
            for (r3 = 0, a3 = t2.length; r3 < a3; r3++)
              if (l3 = no[t2[r3]]) {
                for (h3 = null, n3 = 0, s3 = l3[1].length; n3 < s3; n3 += 2)
                  -1 === l3[1][n3] && -1 === l3[1][n3 + 1] ? h3 = null : (c3 = e3 + l3[1][n3] * o3, u3 = i3 - l3[1][n3 + 1] * o3, h3 && p3.push(h3.x, h3.y, c3, u3), h3 = { x: c3, y: u3 });
                e3 += l3[0] * o3;
              }
            return p3;
          }(g2 + " " + _2 + "kb", 50, 200 * m2, 5 * m2), y2 = new t.StructArrayLayout2i4(), x2 = new t.StructArrayLayout2ui4(), b2 = 0; b2 < v2.length; b2 += 2)
            y2.emplaceBack(v2[b2], v2[b2 + 1]), x2.emplaceBack(b2, b2 + 1);
          for (var w2 = r2.createVertexBuffer(y2, Ze.members), E2 = r2.createIndexBuffer(x2), T2 = t.SegmentVector.simpleSegment(0, 0, y2.length / 2, y2.length / 2), I2 = t.EXTENT / (Math.pow(2, e2.transform.zoom - o2.overscaledZ) * f2 * m2), S2 = [], C2 = -1; C2 <= 1; C2++)
            for (var P2 = -1; P2 <= 1 && (0 !== C2 || 0 !== P2); P2++)
              S2.push([C2, P2]);
          for (var z2 = 0; z2 < S2.length; z2++) {
            var M2 = S2[z2];
            s2.draw(r2, a2.LINES, l2, c2, u2, Pt.disabled, Pi(t.translate([], n2, [I2 * M2[0], I2 * M2[1], 0]), t.Color.white), h2, w2, E2, T2);
          }
          s2.draw(r2, a2.LINES, l2, c2, u2, Pt.disabled, Pi(n2, t.Color.black), h2, w2, E2, T2), w2.destroy(), E2.destroy(), T2.destroy();
        }
        var no = { " ": [16, []], "!": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]], '"': [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]], "#": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]], $: [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]], "%": [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]], "&": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]], "'": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]], "(": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]], ")": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]], "*": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]], "+": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]], ",": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]], "-": [26, [4, 9, 22, 9]], ".": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]], "/": [22, [20, 25, 2, -7]], 0: [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]], 1: [20, [6, 17, 8, 18, 11, 21, 11, 0]], 2: [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]], 3: [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]], 4: [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]], 5: [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]], 6: [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]], 7: [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]], 8: [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]], 9: [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]], ":": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]], ";": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]], "<": [24, [20, 18, 4, 9, 20, 0]], "=": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]], ">": [24, [4, 18, 20, 9, 4, 0]], "?": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]], "@": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]], A: [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]], B: [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]], C: [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]], D: [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]], E: [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]], F: [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]], G: [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]], H: [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]], I: [8, [4, 21, 4, 0]], J: [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]], K: [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]], L: [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]], M: [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]], N: [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]], O: [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]], P: [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]], Q: [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]], R: [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]], S: [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]], T: [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]], U: [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]], V: [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]], W: [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]], X: [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]], Y: [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]], Z: [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]], "[": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]], "\\": [14, [0, 21, 14, -3]], "]": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]], "^": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]], _: [16, [0, -2, 16, -2]], "`": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]], a: [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], b: [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]], c: [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], d: [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], e: [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], f: [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]], g: [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], h: [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]], i: [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]], j: [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]], k: [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]], l: [8, [4, 21, 4, 0]], m: [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]], n: [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]], o: [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]], p: [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]], q: [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], r: [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]], s: [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]], t: [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]], u: [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]], v: [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]], w: [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]], x: [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]], y: [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]], z: [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]], "{": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]], "|": [8, [4, 25, 4, -7]], "}": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]], "~": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]] };
        var so = { symbol: function(e2, i2, o2, r2, a2) {
          if ("translucent" === e2.renderPass) {
            var n2 = St.disabled, s2 = e2.colorModeForRenderPass();
            o2.layout.get("text-variable-anchor") && function(e3, i3, o3, r3, a3, n3, s3) {
              for (var l2 = i3.transform, c2 = "map" === a3, u2 = "map" === n3, h2 = 0, p2 = e3; h2 < p2.length; h2 += 1) {
                var d2 = p2[h2], _2 = r3.getTile(d2), f2 = _2.getBucket(o3);
                if (f2 && f2.text && f2.text.segments.get().length) {
                  var m2 = f2.textSizeData, g2 = t.evaluateSizeForZoom(m2, l2.zoom), v2 = ue(_2, 1, i3.transform.zoom), y2 = Kt(d2.posMatrix, u2, c2, i3.transform, v2), x2 = "none" !== o3.layout.get("icon-text-fit") && f2.hasIconData();
                  if (g2) {
                    var b2 = Math.pow(2, l2.zoom - _2.tileID.overscaledZ);
                    Yi(f2, c2, u2, s3, t.symbolSize, l2, y2, d2.posMatrix, b2, g2, x2);
                  }
                }
              }
            }(r2, e2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), a2), 0 !== o2.paint.get("icon-opacity").constantOr(1) && Qi(e2, i2, o2, r2, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), n2, s2), 0 !== o2.paint.get("text-opacity").constantOr(1) && Qi(e2, i2, o2, r2, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), n2, s2), i2.map.showCollisionBoxes && (Xi(e2, i2, o2, r2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), Xi(e2, i2, o2, r2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
          }
        }, circle: function(e2, i2, o2, r2) {
          if ("translucent" === e2.renderPass) {
            var a2 = o2.paint.get("circle-opacity"), n2 = o2.paint.get("circle-stroke-width"), s2 = o2.paint.get("circle-stroke-opacity"), l2 = void 0 !== o2.layout.get("circle-sort-key").constantOr(1);
            if (0 !== a2.constantOr(1) || 0 !== n2.constantOr(1) && 0 !== s2.constantOr(1)) {
              for (var c2 = e2.context, u2 = c2.gl, h2 = e2.depthModeForSublayer(0, It.ReadOnly), p2 = St.disabled, d2 = e2.colorModeForRenderPass(), _2 = [], f2 = 0; f2 < r2.length; f2++) {
                var m2 = r2[f2], g2 = i2.getTile(m2), v2 = g2.getBucket(o2);
                if (v2) {
                  var y2 = v2.programConfigurations.get(o2.id), x2 = { programConfiguration: y2, program: e2.useProgram("circle", y2), layoutVertexBuffer: v2.layoutVertexBuffer, indexBuffer: v2.indexBuffer, uniformValues: Ii(e2, m2, g2, o2) };
                  if (l2)
                    for (var b2 = 0, w2 = v2.segments.get(); b2 < w2.length; b2 += 1) {
                      var E2 = w2[b2];
                      _2.push({ segments: new t.SegmentVector([E2]), sortKey: E2.sortKey, state: x2 });
                    }
                  else
                    _2.push({ segments: v2.segments, sortKey: 0, state: x2 });
                }
              }
              l2 && _2.sort(function(t2, e3) {
                return t2.sortKey - e3.sortKey;
              });
              for (var T2 = 0, I2 = _2; T2 < I2.length; T2 += 1) {
                var S2 = I2[T2], C2 = S2.state, P2 = C2.programConfiguration, z2 = C2.program, M2 = C2.layoutVertexBuffer, L2 = C2.indexBuffer, D2 = C2.uniformValues, A2 = S2.segments;
                z2.draw(c2, u2.TRIANGLES, h2, p2, d2, Pt.disabled, D2, o2.id, M2, L2, A2, o2.paint, e2.transform.zoom, P2);
              }
            }
          }
        }, heatmap: function(e2, i2, o2, r2) {
          if (0 !== o2.paint.get("heatmap-opacity"))
            if ("offscreen" === e2.renderPass) {
              var a2 = e2.context, n2 = a2.gl, s2 = e2.depthModeForSublayer(0, It.ReadOnly), l2 = St.disabled, c2 = new Ct([n2.ONE, n2.ONE], t.Color.transparent, [true, true, true, true]);
              !function(t2, e3, i3) {
                var o3 = t2.gl;
                t2.activeTexture.set(o3.TEXTURE1), t2.viewport.set([0, 0, e3.width / 4, e3.height / 4]);
                var r3 = i3.heatmapFbo;
                if (r3)
                  o3.bindTexture(o3.TEXTURE_2D, r3.colorAttachment.get()), t2.bindFramebuffer.set(r3.framebuffer);
                else {
                  var a3 = o3.createTexture();
                  o3.bindTexture(o3.TEXTURE_2D, a3), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_S, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_T, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MIN_FILTER, o3.LINEAR), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MAG_FILTER, o3.LINEAR), r3 = i3.heatmapFbo = t2.createFramebuffer(e3.width / 4, e3.height / 4), function t3(e4, i4, o4, r4) {
                    var a4 = e4.gl;
                    a4.texImage2D(a4.TEXTURE_2D, 0, a4.RGBA, i4.width / 4, i4.height / 4, 0, a4.RGBA, e4.extTextureHalfFloat ? e4.extTextureHalfFloat.HALF_FLOAT_OES : a4.UNSIGNED_BYTE, null), r4.colorAttachment.set(o4), e4.extTextureHalfFloat && a4.checkFramebufferStatus(a4.FRAMEBUFFER) !== a4.FRAMEBUFFER_COMPLETE && (e4.extTextureHalfFloat = null, r4.colorAttachment.setDirty(), t3(e4, i4, o4, r4));
                  }(t2, e3, a3, r3);
                }
              }(a2, e2, o2), a2.clear({ color: t.Color.transparent });
              for (var u2 = 0; u2 < r2.length; u2++) {
                var h2 = r2[u2];
                if (!i2.hasRenderableParent(h2)) {
                  var p2 = i2.getTile(h2), d2 = p2.getBucket(o2);
                  if (d2) {
                    var _2 = d2.programConfigurations.get(o2.id), f2 = e2.useProgram("heatmap", _2), m2 = e2.transform.zoom;
                    f2.draw(a2, n2.TRIANGLES, s2, l2, c2, Pt.disabled, Mi(h2.posMatrix, p2, m2, o2.paint.get("heatmap-intensity")), o2.id, d2.layoutVertexBuffer, d2.indexBuffer, d2.segments, o2.paint, e2.transform.zoom, _2);
                  }
                }
              }
              a2.viewport.set([0, 0, e2.width, e2.height]);
            } else
              "translucent" === e2.renderPass && (e2.context.setColorMode(e2.colorModeForRenderPass()), function(e3, i3) {
                var o3 = e3.context, r3 = o3.gl, a3 = i3.heatmapFbo;
                if (!a3)
                  return;
                o3.activeTexture.set(r3.TEXTURE0), r3.bindTexture(r3.TEXTURE_2D, a3.colorAttachment.get()), o3.activeTexture.set(r3.TEXTURE1);
                var n3 = i3.colorRampTexture;
                n3 || (n3 = i3.colorRampTexture = new t.Texture(o3, i3.colorRamp, r3.RGBA));
                n3.bind(r3.LINEAR, r3.CLAMP_TO_EDGE), e3.useProgram("heatmapTexture").draw(o3, r3.TRIANGLES, It.disabled, St.disabled, e3.colorModeForRenderPass(), Pt.disabled, function(e4, i4, o4, r4) {
                  var a4 = t.create();
                  t.ortho(a4, 0, e4.width, e4.height, 0, 0, 1);
                  var n4 = e4.context.gl;
                  return { u_matrix: a4, u_world: [n4.drawingBufferWidth, n4.drawingBufferHeight], u_image: o4, u_color_ramp: r4, u_opacity: i4.paint.get("heatmap-opacity") };
                }(e3, i3, 0, 1), i3.id, e3.viewportBuffer, e3.quadTriangleIndexBuffer, e3.viewportSegments, i3.paint, e3.transform.zoom);
              }(e2, o2));
        }, line: function(e2, i2, o2, r2) {
          if ("translucent" === e2.renderPass) {
            var a2 = o2.paint.get("line-opacity"), n2 = o2.paint.get("line-width");
            if (0 !== a2.constantOr(1) && 0 !== n2.constantOr(1)) {
              var s2 = e2.depthModeForSublayer(0, It.ReadOnly), l2 = e2.colorModeForRenderPass(), c2 = o2.paint.get("line-dasharray"), u2 = o2.paint.get("line-pattern"), h2 = u2.constantOr(1), p2 = o2.paint.get("line-gradient"), d2 = o2.getCrossfadeParameters(), _2 = c2 ? "lineSDF" : h2 ? "linePattern" : p2 ? "lineGradient" : "line", f2 = e2.context, m2 = f2.gl, g2 = true;
              if (p2) {
                f2.activeTexture.set(m2.TEXTURE0);
                var v2 = o2.gradientTexture;
                if (!o2.gradient)
                  return;
                v2 || (v2 = o2.gradientTexture = new t.Texture(f2, o2.gradient, m2.RGBA)), v2.bind(m2.LINEAR, m2.CLAMP_TO_EDGE);
              }
              for (var y2 = 0, x2 = r2; y2 < x2.length; y2 += 1) {
                var b2 = x2[y2], w2 = i2.getTile(b2);
                if (!h2 || w2.patternsLoaded()) {
                  var E2 = w2.getBucket(o2);
                  if (E2) {
                    var T2 = E2.programConfigurations.get(o2.id), I2 = e2.context.program.get(), S2 = e2.useProgram(_2, T2), C2 = g2 || S2.program !== I2, P2 = u2.constantOr(null);
                    if (P2 && w2.imageAtlas) {
                      var z2 = w2.imageAtlas, M2 = z2.patternPositions[P2.to.toString()], L2 = z2.patternPositions[P2.from.toString()];
                      M2 && L2 && T2.setConstantPatternPositions(M2, L2);
                    }
                    var D2 = c2 ? ki(e2, w2, o2, c2, d2) : h2 ? Ri(e2, w2, o2, d2) : p2 ? Ai(e2, w2, o2) : Di(e2, w2, o2);
                    c2 && (C2 || e2.lineAtlas.dirty) ? (f2.activeTexture.set(m2.TEXTURE0), e2.lineAtlas.bind(f2)) : h2 && (f2.activeTexture.set(m2.TEXTURE0), w2.imageAtlasTexture.bind(m2.LINEAR, m2.CLAMP_TO_EDGE), T2.updatePatternPaintBuffers(d2)), S2.draw(f2, m2.TRIANGLES, s2, e2.stencilModeForClipping(b2), l2, Pt.disabled, D2, o2.id, E2.layoutVertexBuffer, E2.indexBuffer, E2.segments, o2.paint, e2.transform.zoom, T2), g2 = false;
                  }
                }
              }
            }
          }
        }, fill: function(e2, i2, o2, r2) {
          var a2 = o2.paint.get("fill-color"), n2 = o2.paint.get("fill-opacity");
          if (0 !== n2.constantOr(1)) {
            var s2 = e2.colorModeForRenderPass(), l2 = o2.paint.get("fill-pattern"), c2 = e2.opaquePassEnabledForLayer() && !l2.constantOr(1) && 1 === a2.constantOr(t.Color.transparent).a && 1 === n2.constantOr(0) ? "opaque" : "translucent";
            if (e2.renderPass === c2) {
              var u2 = e2.depthModeForSublayer(1, "opaque" === e2.renderPass ? It.ReadWrite : It.ReadOnly);
              to(e2, i2, o2, r2, u2, s2, false);
            }
            if ("translucent" === e2.renderPass && o2.paint.get("fill-antialias")) {
              var h2 = e2.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, It.ReadOnly);
              to(e2, i2, o2, r2, h2, s2, true);
            }
          }
        }, "fill-extrusion": function(t2, e2, i2, o2) {
          var r2 = i2.paint.get("fill-extrusion-opacity");
          if (0 !== r2 && "translucent" === t2.renderPass) {
            var a2 = new It(t2.context.gl.LEQUAL, It.ReadWrite, t2.depthRangeFor3D);
            if (1 !== r2 || i2.paint.get("fill-extrusion-pattern").constantOr(1))
              eo(t2, e2, i2, o2, a2, St.disabled, Ct.disabled), eo(t2, e2, i2, o2, a2, t2.stencilModeFor3D(), t2.colorModeForRenderPass());
            else {
              var n2 = t2.colorModeForRenderPass();
              eo(t2, e2, i2, o2, a2, St.disabled, n2);
            }
          }
        }, hillshade: function(t2, e2, i2, o2) {
          if ("offscreen" === t2.renderPass || "translucent" === t2.renderPass) {
            for (var r2 = t2.context, a2 = e2.getSource().maxzoom, n2 = t2.depthModeForSublayer(0, It.ReadOnly), s2 = t2.colorModeForRenderPass(), l2 = "translucent" === t2.renderPass ? t2.stencilConfigForOverlap(o2) : [{}, o2], c2 = l2[0], u2 = 0, h2 = l2[1]; u2 < h2.length; u2 += 1) {
              var p2 = h2[u2], d2 = e2.getTile(p2);
              d2.needsHillshadePrepare && "offscreen" === t2.renderPass ? oo(t2, d2, i2, a2, n2, St.disabled, s2) : "translucent" === t2.renderPass && io(t2, d2, i2, n2, c2[p2.overscaledZ], s2);
            }
            r2.viewport.set([0, 0, t2.width, t2.height]);
          }
        }, raster: function(t2, e2, i2, o2) {
          if ("translucent" === t2.renderPass && 0 !== i2.paint.get("raster-opacity") && o2.length)
            for (var r2 = t2.context, a2 = r2.gl, n2 = e2.getSource(), s2 = t2.useProgram("raster"), l2 = t2.colorModeForRenderPass(), c2 = n2 instanceof D ? [{}, o2] : t2.stencilConfigForOverlap(o2), u2 = c2[0], h2 = c2[1], p2 = h2[h2.length - 1].overscaledZ, d2 = !t2.options.moving, _2 = 0, f2 = h2; _2 < f2.length; _2 += 1) {
              var m2 = f2[_2], g2 = t2.depthModeForSublayer(m2.overscaledZ - p2, 1 === i2.paint.get("raster-opacity") ? It.ReadWrite : It.ReadOnly, a2.LESS), v2 = e2.getTile(m2), y2 = t2.transform.calculatePosMatrix(m2.toUnwrapped(), d2);
              v2.registerFadeDuration(i2.paint.get("raster-fade-duration"));
              var x2 = e2.findLoadedParent(m2, 0), b2 = ro(v2, x2, e2, i2, t2.transform), w2 = void 0, E2 = void 0, T2 = "nearest" === i2.paint.get("raster-resampling") ? a2.NEAREST : a2.LINEAR;
              r2.activeTexture.set(a2.TEXTURE0), v2.texture.bind(T2, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST), r2.activeTexture.set(a2.TEXTURE1), x2 ? (x2.texture.bind(T2, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST), w2 = Math.pow(2, x2.tileID.overscaledZ - v2.tileID.overscaledZ), E2 = [v2.tileID.canonical.x * w2 % 1, v2.tileID.canonical.y * w2 % 1]) : v2.texture.bind(T2, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST);
              var I2 = Fi(y2, E2 || [0, 0], w2 || 1, b2, i2);
              n2 instanceof D ? s2.draw(r2, a2.TRIANGLES, g2, St.disabled, l2, Pt.disabled, I2, i2.id, n2.boundsBuffer, t2.quadTriangleIndexBuffer, n2.boundsSegments) : s2.draw(r2, a2.TRIANGLES, g2, u2[m2.overscaledZ], l2, Pt.disabled, I2, i2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
            }
        }, background: function(t2, e2, i2) {
          var o2 = i2.paint.get("background-color"), r2 = i2.paint.get("background-opacity");
          if (0 !== r2) {
            var a2 = t2.context, n2 = a2.gl, s2 = t2.transform, l2 = s2.tileSize, c2 = i2.paint.get("background-pattern");
            if (!t2.isPatternMissing(c2)) {
              var u2 = !c2 && 1 === o2.a && 1 === r2 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (t2.renderPass === u2) {
                var h2 = St.disabled, p2 = t2.depthModeForSublayer(0, "opaque" === u2 ? It.ReadWrite : It.ReadOnly), d2 = t2.colorModeForRenderPass(), _2 = t2.useProgram(c2 ? "backgroundPattern" : "background"), f2 = s2.coveringTiles({ tileSize: l2 });
                c2 && (a2.activeTexture.set(n2.TEXTURE0), t2.imageManager.bind(t2.context));
                for (var m2 = i2.getCrossfadeParameters(), g2 = 0, v2 = f2; g2 < v2.length; g2 += 1) {
                  var y2 = v2[g2], x2 = t2.transform.calculatePosMatrix(y2.toUnwrapped()), b2 = c2 ? Vi(x2, r2, t2, c2, { tileID: y2, tileSize: l2 }, m2) : ji(x2, r2, o2);
                  _2.draw(a2, n2.TRIANGLES, p2, h2, d2, Pt.disabled, b2, i2.id, t2.tileExtentBuffer, t2.quadTriangleIndexBuffer, t2.tileExtentSegments);
                }
              }
            }
          }
        }, debug: function(t2, e2, i2) {
          for (var o2 = 0; o2 < i2.length; o2++)
            ao(t2, e2, i2[o2]);
        }, custom: function(t2, e2, i2) {
          var o2 = t2.context, r2 = i2.implementation;
          if ("offscreen" === t2.renderPass) {
            var a2 = r2.prerender;
            a2 && (t2.setCustomLayerDefaults(), o2.setColorMode(t2.colorModeForRenderPass()), a2.call(r2, o2.gl, t2.transform.customLayerMatrix()), o2.setDirty(), t2.setBaseState());
          } else if ("translucent" === t2.renderPass) {
            t2.setCustomLayerDefaults(), o2.setColorMode(t2.colorModeForRenderPass()), o2.setStencilMode(St.disabled);
            var n2 = "3d" === r2.renderingMode ? new It(t2.context.gl.LEQUAL, It.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, It.ReadOnly);
            o2.setDepthMode(n2), r2.render(o2.gl, t2.transform.customLayerMatrix()), o2.setDirty(), t2.setBaseState(), o2.bindFramebuffer.set(null);
          }
        } }, lo = function(e2, i2) {
          this.context = new zt(e2), this.transform = i2, this._tileTextures = {}, this.setup(), this.numSublayers = Mt.maxUnderzooming + Mt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.depthRboNeedsClear = true, this.emptyProgramConfiguration = new t.ProgramConfiguration(), this.crossTileSymbolIndex = new ke(), this.gpuTimers = {};
        };
        function co(t2, e2) {
          if (t2.y > e2.y) {
            var i2 = t2;
            t2 = e2, e2 = i2;
          }
          return { x0: t2.x, y0: t2.y, x1: e2.x, y1: e2.y, dx: e2.x - t2.x, dy: e2.y - t2.y };
        }
        function uo(t2, e2, i2, o2, r2) {
          var a2 = Math.max(i2, Math.floor(e2.y0)), n2 = Math.min(o2, Math.ceil(e2.y1));
          if (t2.x0 === e2.x0 && t2.y0 === e2.y0 ? t2.x0 + e2.dy / t2.dy * t2.dx < e2.x1 : t2.x1 - e2.dy / t2.dy * t2.dx < e2.x0) {
            var s2 = t2;
            t2 = e2, e2 = s2;
          }
          for (var l2 = t2.dx / t2.dy, c2 = e2.dx / e2.dy, u2 = t2.dx > 0, h2 = e2.dx < 0, p2 = a2; p2 < n2; p2++) {
            var d2 = l2 * Math.max(0, Math.min(t2.dy, p2 + u2 - t2.y0)) + t2.x0, _2 = c2 * Math.max(0, Math.min(e2.dy, p2 + h2 - e2.y0)) + e2.x0;
            r2(Math.floor(_2), Math.ceil(d2), p2);
          }
        }
        function ho(t2, e2, i2, o2, r2, a2) {
          var n2, s2 = co(t2, e2), l2 = co(e2, i2), c2 = co(i2, t2);
          s2.dy > l2.dy && (n2 = s2, s2 = l2, l2 = n2), s2.dy > c2.dy && (n2 = s2, s2 = c2, c2 = n2), l2.dy > c2.dy && (n2 = l2, l2 = c2, c2 = n2), s2.dy && uo(c2, s2, o2, r2, a2), l2.dy && uo(c2, l2, o2, r2, a2);
        }
        lo.prototype.resize = function(e2, i2) {
          var o2 = this.context.gl;
          if (this.width = e2 * t.browser.devicePixelRatio, this.height = i2 * t.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (var r2 = 0, a2 = this.style._order; r2 < a2.length; r2 += 1) {
              var n2 = a2[r2];
              this.style._layers[n2].resize();
            }
          this.depthRbo && (o2.deleteRenderbuffer(this.depthRbo), this.depthRbo = null);
        }, lo.prototype.setup = function() {
          var e2 = this.context, i2 = new t.StructArrayLayout2i4();
          i2.emplaceBack(0, 0), i2.emplaceBack(t.EXTENT, 0), i2.emplaceBack(0, t.EXTENT), i2.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e2.createVertexBuffer(i2, Ze.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
          var o2 = new t.StructArrayLayout2i4();
          o2.emplaceBack(0, 0), o2.emplaceBack(t.EXTENT, 0), o2.emplaceBack(0, t.EXTENT), o2.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e2.createVertexBuffer(o2, Ze.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);
          var r2 = new t.StructArrayLayout4i8();
          r2.emplaceBack(0, 0, 0, 0), r2.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), r2.emplaceBack(0, t.EXTENT, 0, t.EXTENT), r2.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e2.createVertexBuffer(r2, L.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
          var a2 = new t.StructArrayLayout2i4();
          a2.emplaceBack(0, 0), a2.emplaceBack(1, 0), a2.emplaceBack(0, 1), a2.emplaceBack(1, 1), this.viewportBuffer = e2.createVertexBuffer(a2, Ze.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
          var n2 = new t.StructArrayLayout1ui2();
          n2.emplaceBack(0), n2.emplaceBack(1), n2.emplaceBack(3), n2.emplaceBack(2), n2.emplaceBack(0), this.tileBorderIndexBuffer = e2.createIndexBuffer(n2);
          var s2 = new t.StructArrayLayout3ui6();
          s2.emplaceBack(0, 1, 2), s2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e2.createIndexBuffer(s2);
          var l2 = this.context.gl;
          this.stencilClearMode = new St({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO);
        }, lo.prototype.clearStencil = function() {
          var e2 = this.context, i2 = e2.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          var o2 = t.create();
          t.ortho(o2, 0, this.width, this.height, 0, 0, 1), t.scale(o2, o2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e2, i2.TRIANGLES, It.disabled, this.stencilClearMode, Ct.disabled, Pt.disabled, zi(o2), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }, lo.prototype._renderTileClippingMasks = function(t2, e2) {
          if (this.currentStencilSource !== t2.source && t2.isTileClipped() && e2 && e2.length) {
            this.currentStencilSource = t2.source;
            var i2 = this.context, o2 = i2.gl;
            this.nextStencilID + e2.length > 256 && this.clearStencil(), i2.setColorMode(Ct.disabled), i2.setDepthMode(It.disabled);
            var r2 = this.useProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (var a2 = 0, n2 = e2; a2 < n2.length; a2 += 1) {
              var s2 = n2[a2], l2 = this._tileClippingMaskIDs[s2.key] = this.nextStencilID++;
              r2.draw(i2, o2.TRIANGLES, It.disabled, new St({ func: o2.ALWAYS, mask: 0 }, l2, 255, o2.KEEP, o2.KEEP, o2.REPLACE), Ct.disabled, Pt.disabled, zi(s2.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
            }
          }
        }, lo.prototype.stencilModeFor3D = function() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          var t2 = this.nextStencilID++, e2 = this.context.gl;
          return new St({ func: e2.NOTEQUAL, mask: 255 }, t2, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
        }, lo.prototype.stencilModeForClipping = function(t2) {
          var e2 = this.context.gl;
          return new St({ func: e2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, e2.KEEP, e2.KEEP, e2.REPLACE);
        }, lo.prototype.stencilConfigForOverlap = function(t2) {
          var e2, i2 = this.context.gl, o2 = t2.sort(function(t3, e3) {
            return e3.overscaledZ - t3.overscaledZ;
          }), r2 = o2[o2.length - 1].overscaledZ, a2 = o2[0].overscaledZ - r2 + 1;
          if (a2 > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + a2 > 256 && this.clearStencil();
            for (var n2 = {}, s2 = 0; s2 < a2; s2++)
              n2[s2 + r2] = new St({ func: i2.GEQUAL, mask: 255 }, s2 + this.nextStencilID, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
            return this.nextStencilID += a2, [n2, o2];
          }
          return [(e2 = {}, e2[r2] = St.disabled, e2), o2];
        }, lo.prototype.colorModeForRenderPass = function() {
          var e2 = this.context.gl;
          if (this._showOverdrawInspector) {
            return new Ct([e2.CONSTANT_COLOR, e2.ONE], new t.Color(1 / 8, 1 / 8, 1 / 8, 0), [true, true, true, true]);
          }
          return "opaque" === this.renderPass ? Ct.unblended : Ct.alphaBlended;
        }, lo.prototype.depthModeForSublayer = function(t2, e2, i2) {
          if (!this.opaquePassEnabledForLayer())
            return It.disabled;
          var o2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
          return new It(i2 || this.context.gl.LEQUAL, e2, [o2, o2]);
        }, lo.prototype.opaquePassEnabledForLayer = function() {
          return this.currentLayer < this.opaquePassCutoff;
        }, lo.prototype.render = function(e2, i2) {
          var o2 = this;
          this.style = e2, this.options = i2, this.lineAtlas = e2.lineAtlas, this.imageManager = e2.imageManager, this.glyphManager = e2.glyphManager, this.symbolFadeChange = e2.placement.symbolFadeChange(t.browser.now()), this.imageManager.beginFrame();
          var r2 = this.style._order, a2 = this.style.sourceCaches;
          for (var n2 in a2) {
            var s2 = a2[n2];
            s2.used && s2.prepare(this.context);
          }
          var l2, c2, u2 = {}, h2 = {}, p2 = {};
          for (var d2 in a2) {
            var _2 = a2[d2];
            u2[d2] = _2.getVisibleCoordinates(), h2[d2] = u2[d2].slice().reverse(), p2[d2] = _2.getVisibleCoordinates(true).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (var f2 = 0; f2 < r2.length; f2++) {
            var m2 = r2[f2];
            if (this.style._layers[m2].is3D()) {
              this.opaquePassCutoff = f2;
              break;
            }
          }
          this.renderPass = "offscreen", this.depthRboNeedsClear = true;
          for (var g2 = 0, v2 = r2; g2 < v2.length; g2 += 1) {
            var y2 = v2[g2], x2 = this.style._layers[y2];
            if (x2.hasOffscreenPass() && !x2.isHidden(this.transform.zoom)) {
              var b2 = h2[x2.source];
              ("custom" === x2.type || b2.length) && this.renderLayer(this, a2[x2.source], x2, b2);
            }
          }
          for (this.context.bindFramebuffer.set(null), this.context.clear({ color: i2.showOverdrawInspector ? t.Color.black : t.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e2._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = r2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            var w2 = this.style._layers[r2[this.currentLayer]], E2 = a2[w2.source], T2 = u2[w2.source];
            this._renderTileClippingMasks(w2, T2), this.renderLayer(this, E2, w2, T2);
          }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < r2.length; this.currentLayer++) {
            var I2 = this.style._layers[r2[this.currentLayer]], S2 = a2[I2.source], C2 = ("symbol" === I2.type ? p2 : h2)[I2.source];
            this._renderTileClippingMasks(I2, u2[I2.source]), this.renderLayer(this, S2, I2, C2);
          }
          this.options.showTileBoundaries && (t.values(this.style._layers).forEach(function(t2) {
            t2.source && !t2.isHidden(o2.transform.zoom) && (t2.source !== (c2 && c2.id) && (c2 = o2.style.sourceCaches[t2.source]), (!l2 || l2.getSource().maxzoom < c2.getSource().maxzoom) && (l2 = c2));
          }), l2 && so.debug(this, l2, l2.getVisibleCoordinates()));
          this.context.setDefault();
        }, lo.prototype.setupOffscreenDepthRenderbuffer = function() {
          var t2 = this.context;
          this.depthRbo || (this.depthRbo = t2.createRenderbuffer(t2.gl.DEPTH_COMPONENT16, this.width, this.height));
        }, lo.prototype.renderLayer = function(t2, e2, i2, o2) {
          i2.isHidden(this.transform.zoom) || ("background" === i2.type || "custom" === i2.type || o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), so[i2.type](t2, e2, i2, o2, this.style.placement.variableOffsets), this.gpuTimingEnd());
        }, lo.prototype.gpuTimingStart = function(t2) {
          if (this.options.gpuTiming) {
            var e2 = this.context.extTimerQuery, i2 = this.gpuTimers[t2.id];
            i2 || (i2 = this.gpuTimers[t2.id] = { calls: 0, cpuTime: 0, query: e2.createQueryEXT() }), i2.calls++, e2.beginQueryEXT(e2.TIME_ELAPSED_EXT, i2.query);
          }
        }, lo.prototype.gpuTimingEnd = function() {
          if (this.options.gpuTiming) {
            var t2 = this.context.extTimerQuery;
            t2.endQueryEXT(t2.TIME_ELAPSED_EXT);
          }
        }, lo.prototype.collectGpuTimers = function() {
          var t2 = this.gpuTimers;
          return this.gpuTimers = {}, t2;
        }, lo.prototype.queryGpuTimers = function(t2) {
          var e2 = {};
          for (var i2 in t2) {
            var o2 = t2[i2], r2 = this.context.extTimerQuery, a2 = r2.getQueryObjectEXT(o2.query, r2.QUERY_RESULT_EXT) / 1e6;
            r2.deleteQueryEXT(o2.query), e2[i2] = a2;
          }
          return e2;
        }, lo.prototype.translatePosMatrix = function(e2, i2, o2, r2, a2) {
          if (!o2[0] && !o2[1])
            return e2;
          var n2 = a2 ? "map" === r2 ? this.transform.angle : 0 : "viewport" === r2 ? -this.transform.angle : 0;
          if (n2) {
            var s2 = Math.sin(n2), l2 = Math.cos(n2);
            o2 = [o2[0] * l2 - o2[1] * s2, o2[0] * s2 + o2[1] * l2];
          }
          var c2 = [a2 ? o2[0] : ue(i2, o2[0], this.transform.zoom), a2 ? o2[1] : ue(i2, o2[1], this.transform.zoom), 0], u2 = new Float32Array(16);
          return t.translate(u2, e2, c2), u2;
        }, lo.prototype.saveTileTexture = function(t2) {
          var e2 = this._tileTextures[t2.size[0]];
          e2 ? e2.push(t2) : this._tileTextures[t2.size[0]] = [t2];
        }, lo.prototype.getTileTexture = function(t2) {
          var e2 = this._tileTextures[t2];
          return e2 && e2.length > 0 ? e2.pop() : null;
        }, lo.prototype.isPatternMissing = function(t2) {
          if (!t2)
            return false;
          var e2 = this.imageManager.getPattern(t2.from.toString()), i2 = this.imageManager.getPattern(t2.to.toString());
          return !e2 || !i2;
        }, lo.prototype.useProgram = function(t2, e2) {
          void 0 === e2 && (e2 = this.emptyProgramConfiguration), this.cache = this.cache || {};
          var i2 = "" + t2 + (e2.cacheKey || "") + (this._showOverdrawInspector ? "/overdraw" : "");
          return this.cache[i2] || (this.cache[i2] = new gi(this.context, fi[t2], e2, Gi[t2], this._showOverdrawInspector)), this.cache[i2];
        }, lo.prototype.setCustomLayerDefaults = function() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }, lo.prototype.setBaseState = function() {
          var t2 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t2.FUNC_ADD);
        };
        var po = function(e2, i2, o2, r2, a2) {
          this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === a2 || a2, this._minZoom = e2 || 0, this._maxZoom = i2 || 22, this._minPitch = null == o2 ? 0 : o2, this._maxPitch = null == r2 ? 60 : r2, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
        }, _o = { minZoom: { configurable: true }, maxZoom: { configurable: true }, minPitch: { configurable: true }, maxPitch: { configurable: true }, renderWorldCopies: { configurable: true }, worldSize: { configurable: true }, centerPoint: { configurable: true }, size: { configurable: true }, bearing: { configurable: true }, pitch: { configurable: true }, fov: { configurable: true }, zoom: { configurable: true }, center: { configurable: true }, unmodified: { configurable: true }, point: { configurable: true } };
        po.prototype.clone = function() {
          var t2 = new po(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return t2.tileSize = this.tileSize, t2.latRange = this.latRange, t2.width = this.width, t2.height = this.height, t2._center = this._center, t2.zoom = this.zoom, t2.angle = this.angle, t2._fov = this._fov, t2._pitch = this._pitch, t2._unmodified = this._unmodified, t2._calcMatrices(), t2;
        }, _o.minZoom.get = function() {
          return this._minZoom;
        }, _o.minZoom.set = function(t2) {
          this._minZoom !== t2 && (this._minZoom = t2, this.zoom = Math.max(this.zoom, t2));
        }, _o.maxZoom.get = function() {
          return this._maxZoom;
        }, _o.maxZoom.set = function(t2) {
          this._maxZoom !== t2 && (this._maxZoom = t2, this.zoom = Math.min(this.zoom, t2));
        }, _o.minPitch.get = function() {
          return this._minPitch;
        }, _o.minPitch.set = function(t2) {
          this._minPitch !== t2 && (this._minPitch = t2, this.pitch = Math.max(this.pitch, t2));
        }, _o.maxPitch.get = function() {
          return this._maxPitch;
        }, _o.maxPitch.set = function(t2) {
          this._maxPitch !== t2 && (this._maxPitch = t2, this.pitch = Math.min(this.pitch, t2));
        }, _o.renderWorldCopies.get = function() {
          return this._renderWorldCopies;
        }, _o.renderWorldCopies.set = function(t2) {
          void 0 === t2 ? t2 = true : null === t2 && (t2 = false), this._renderWorldCopies = t2;
        }, _o.worldSize.get = function() {
          return this.tileSize * this.scale;
        }, _o.centerPoint.get = function() {
          return this.size._div(2);
        }, _o.size.get = function() {
          return new t.Point(this.width, this.height);
        }, _o.bearing.get = function() {
          return -this.angle / Math.PI * 180;
        }, _o.bearing.set = function(e2) {
          var i2 = -t.wrap(e2, -180, 180) * Math.PI / 180;
          this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = t.create$2(), t.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
        }, _o.pitch.get = function() {
          return this._pitch / Math.PI * 180;
        }, _o.pitch.set = function(e2) {
          var i2 = t.clamp(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
        }, _o.fov.get = function() {
          return this._fov / Math.PI * 180;
        }, _o.fov.set = function(t2) {
          t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = t2 / 180 * Math.PI, this._calcMatrices());
        }, _o.zoom.get = function() {
          return this._zoom;
        }, _o.zoom.set = function(t2) {
          var e2 = Math.min(Math.max(t2, this.minZoom), this.maxZoom);
          this._zoom !== e2 && (this._unmodified = false, this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom, this._constrain(), this._calcMatrices());
        }, _o.center.get = function() {
          return this._center;
        }, _o.center.set = function(t2) {
          t2.lat === this._center.lat && t2.lng === this._center.lng || (this._unmodified = false, this._center = t2, this._constrain(), this._calcMatrices());
        }, po.prototype.coveringZoomLevel = function(t2) {
          var e2 = (t2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t2.tileSize));
          return Math.max(0, e2);
        }, po.prototype.getVisibleUnwrappedCoordinates = function(e2) {
          var i2 = [new t.UnwrappedTileID(0, e2)];
          if (this._renderWorldCopies)
            for (var o2 = this.pointCoordinate(new t.Point(0, 0)), r2 = this.pointCoordinate(new t.Point(this.width, 0)), a2 = this.pointCoordinate(new t.Point(this.width, this.height)), n2 = this.pointCoordinate(new t.Point(0, this.height)), s2 = Math.floor(Math.min(o2.x, r2.x, a2.x, n2.x)), l2 = Math.floor(Math.max(o2.x, r2.x, a2.x, n2.x)), c2 = s2 - 1; c2 <= l2 + 1; c2++)
              0 !== c2 && i2.push(new t.UnwrappedTileID(c2, e2));
          return i2;
        }, po.prototype.coveringTiles = function(e2) {
          var i2 = this.coveringZoomLevel(e2), o2 = i2;
          if (void 0 !== e2.minzoom && i2 < e2.minzoom)
            return [];
          void 0 !== e2.maxzoom && i2 > e2.maxzoom && (i2 = e2.maxzoom);
          var r2 = t.MercatorCoordinate.fromLngLat(this.center), a2 = Math.pow(2, i2), n2 = new t.Point(a2 * r2.x - 0.5, a2 * r2.y - 0.5);
          return function(e3, i3, o3, r3) {
            void 0 === r3 && (r3 = true);
            var a3 = 1 << e3, n3 = {};
            function s2(i4, s3, l3) {
              var c2, u2, h2, p2;
              if (l3 >= 0 && l3 <= a3)
                for (c2 = i4; c2 < s3; c2++)
                  u2 = Math.floor(c2 / a3), h2 = (c2 % a3 + a3) % a3, 0 !== u2 && true !== r3 || (p2 = new t.OverscaledTileID(o3, u2, e3, h2, l3), n3[p2.key] = p2);
            }
            var l2 = i3.map(function(e4) {
              return new t.Point(e4.x, e4.y)._mult(a3);
            });
            return ho(l2[0], l2[1], l2[2], 0, a3, s2), ho(l2[2], l2[3], l2[0], 0, a3, s2), Object.keys(n3).map(function(t2) {
              return n3[t2];
            });
          }(i2, [this.pointCoordinate(new t.Point(0, 0)), this.pointCoordinate(new t.Point(this.width, 0)), this.pointCoordinate(new t.Point(this.width, this.height)), this.pointCoordinate(new t.Point(0, this.height))], e2.reparseOverscaled ? o2 : i2, this._renderWorldCopies).sort(function(t2, e3) {
            return n2.dist(t2.canonical) - n2.dist(e3.canonical);
          });
        }, po.prototype.resize = function(t2, e2) {
          this.width = t2, this.height = e2, this.pixelsToGLUnits = [2 / t2, -2 / e2], this._constrain(), this._calcMatrices();
        }, _o.unmodified.get = function() {
          return this._unmodified;
        }, po.prototype.zoomScale = function(t2) {
          return Math.pow(2, t2);
        }, po.prototype.scaleZoom = function(t2) {
          return Math.log(t2) / Math.LN2;
        }, po.prototype.project = function(e2) {
          var i2 = t.clamp(e2.lat, -this.maxValidLatitude, this.maxValidLatitude);
          return new t.Point(t.mercatorXfromLng(e2.lng) * this.worldSize, t.mercatorYfromLat(i2) * this.worldSize);
        }, po.prototype.unproject = function(e2) {
          return new t.MercatorCoordinate(e2.x / this.worldSize, e2.y / this.worldSize).toLngLat();
        }, _o.point.get = function() {
          return this.project(this.center);
        }, po.prototype.setLocationAtPoint = function(e2, i2) {
          var o2 = this.pointCoordinate(i2), r2 = this.pointCoordinate(this.centerPoint), a2 = this.locationCoordinate(e2), n2 = new t.MercatorCoordinate(a2.x - (o2.x - r2.x), a2.y - (o2.y - r2.y));
          this.center = this.coordinateLocation(n2), this._renderWorldCopies && (this.center = this.center.wrap());
        }, po.prototype.locationPoint = function(t2) {
          return this.coordinatePoint(this.locationCoordinate(t2));
        }, po.prototype.pointLocation = function(t2) {
          return this.coordinateLocation(this.pointCoordinate(t2));
        }, po.prototype.locationCoordinate = function(e2) {
          return t.MercatorCoordinate.fromLngLat(e2);
        }, po.prototype.coordinateLocation = function(t2) {
          return t2.toLngLat();
        }, po.prototype.pointCoordinate = function(e2) {
          var i2 = [e2.x, e2.y, 0, 1], o2 = [e2.x, e2.y, 1, 1];
          t.transformMat4(i2, i2, this.pixelMatrixInverse), t.transformMat4(o2, o2, this.pixelMatrixInverse);
          var r2 = i2[3], a2 = o2[3], n2 = i2[0] / r2, s2 = o2[0] / a2, l2 = i2[1] / r2, c2 = o2[1] / a2, u2 = i2[2] / r2, h2 = o2[2] / a2, p2 = u2 === h2 ? 0 : (0 - u2) / (h2 - u2);
          return new t.MercatorCoordinate(t.number(n2, s2, p2) / this.worldSize, t.number(l2, c2, p2) / this.worldSize);
        }, po.prototype.coordinatePoint = function(e2) {
          var i2 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
          return t.transformMat4(i2, i2, this.pixelMatrix), new t.Point(i2[0] / i2[3], i2[1] / i2[3]);
        }, po.prototype.getBounds = function() {
          return new t.LngLatBounds().extend(this.pointLocation(new t.Point(0, 0))).extend(this.pointLocation(new t.Point(this.width, 0))).extend(this.pointLocation(new t.Point(this.width, this.height))).extend(this.pointLocation(new t.Point(0, this.height)));
        }, po.prototype.getMaxBounds = function() {
          return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }, po.prototype.setMaxBounds = function(t2) {
          t2 ? (this.lngRange = [t2.getWest(), t2.getEast()], this.latRange = [t2.getSouth(), t2.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
        }, po.prototype.calculatePosMatrix = function(e2, i2) {
          void 0 === i2 && (i2 = false);
          var o2 = e2.key, r2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (r2[o2])
            return r2[o2];
          var a2 = e2.canonical, n2 = this.worldSize / this.zoomScale(a2.z), s2 = a2.x + Math.pow(2, a2.z) * e2.wrap, l2 = t.identity(new Float64Array(16));
          return t.translate(l2, l2, [s2 * n2, a2.y * n2, 0]), t.scale(l2, l2, [n2 / t.EXTENT, n2 / t.EXTENT, 1]), t.multiply(l2, i2 ? this.alignedProjMatrix : this.projMatrix, l2), r2[o2] = new Float32Array(l2), r2[o2];
        }, po.prototype.customLayerMatrix = function() {
          return this.mercatorMatrix.slice();
        }, po.prototype._constrain = function() {
          if (this.center && this.width && this.height && !this._constraining) {
            this._constraining = true;
            var e2, i2, o2, r2, a2 = -90, n2 = 90, s2 = -180, l2 = 180, c2 = this.size, u2 = this._unmodified;
            if (this.latRange) {
              var h2 = this.latRange;
              a2 = t.mercatorYfromLat(h2[1]) * this.worldSize, e2 = (n2 = t.mercatorYfromLat(h2[0]) * this.worldSize) - a2 < c2.y ? c2.y / (n2 - a2) : 0;
            }
            if (this.lngRange) {
              var p2 = this.lngRange;
              s2 = t.mercatorXfromLng(p2[0]) * this.worldSize, i2 = (l2 = t.mercatorXfromLng(p2[1]) * this.worldSize) - s2 < c2.x ? c2.x / (l2 - s2) : 0;
            }
            var d2 = this.point, _2 = Math.max(i2 || 0, e2 || 0);
            if (_2)
              return this.center = this.unproject(new t.Point(i2 ? (l2 + s2) / 2 : d2.x, e2 ? (n2 + a2) / 2 : d2.y)), this.zoom += this.scaleZoom(_2), this._unmodified = u2, void (this._constraining = false);
            if (this.latRange) {
              var f2 = d2.y, m2 = c2.y / 2;
              f2 - m2 < a2 && (r2 = a2 + m2), f2 + m2 > n2 && (r2 = n2 - m2);
            }
            if (this.lngRange) {
              var g2 = d2.x, v2 = c2.x / 2;
              g2 - v2 < s2 && (o2 = s2 + v2), g2 + v2 > l2 && (o2 = l2 - v2);
            }
            void 0 === o2 && void 0 === r2 || (this.center = this.unproject(new t.Point(void 0 !== o2 ? o2 : d2.x, void 0 !== r2 ? r2 : d2.y))), this._unmodified = u2, this._constraining = false;
          }
        }, po.prototype._calcMatrices = function() {
          if (this.height) {
            this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height;
            var e2 = this._fov / 2, i2 = Math.PI / 2 + this._pitch, o2 = Math.sin(e2) * this.cameraToCenterDistance / Math.sin(Math.PI - i2 - e2), r2 = this.point, a2 = r2.x, n2 = r2.y, s2 = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * o2 + this.cameraToCenterDistance), l2 = this.height / 50, c2 = new Float64Array(16);
            t.perspective(c2, this._fov, this.width / this.height, l2, s2), t.scale(c2, c2, [1, -1, 1]), t.translate(c2, c2, [0, 0, -this.cameraToCenterDistance]), t.rotateX(c2, c2, this._pitch), t.rotateZ(c2, c2, this.angle), t.translate(c2, c2, [-a2, -n2, 0]), this.mercatorMatrix = t.scale([], c2, [this.worldSize, this.worldSize, this.worldSize]), t.scale(c2, c2, [1, 1, t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]), this.projMatrix = c2;
            var u2 = this.width % 2 / 2, h2 = this.height % 2 / 2, p2 = Math.cos(this.angle), d2 = Math.sin(this.angle), _2 = a2 - Math.round(a2) + p2 * u2 + d2 * h2, f2 = n2 - Math.round(n2) + p2 * h2 + d2 * u2, m2 = new Float64Array(c2);
            if (t.translate(m2, m2, [_2 > 0.5 ? _2 - 1 : _2, f2 > 0.5 ? f2 - 1 : f2, 0]), this.alignedProjMatrix = m2, c2 = t.create(), t.scale(c2, c2, [this.width / 2, -this.height / 2, 1]), t.translate(c2, c2, [1, -1, 0]), this.labelPlaneMatrix = c2, c2 = t.create(), t.scale(c2, c2, [1, -1, 1]), t.translate(c2, c2, [-1, -1, 0]), t.scale(c2, c2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = c2, this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), !(c2 = t.invert(new Float64Array(16), this.pixelMatrix)))
              throw new Error("failed to invert matrix");
            this.pixelMatrixInverse = c2, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
          }
        }, po.prototype.maxPitchScaleFactor = function() {
          if (!this.pixelMatrixInverse)
            return 1;
          var e2 = this.pointCoordinate(new t.Point(0, 0)), i2 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
          return t.transformMat4(i2, i2, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }, po.prototype.getCameraPoint = function() {
          var e2 = this._pitch, i2 = Math.tan(e2) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new t.Point(0, i2));
        }, po.prototype.getCameraQueryGeometry = function(e2) {
          var i2 = this.getCameraPoint();
          if (1 === e2.length)
            return [e2[0], i2];
          for (var o2 = i2.x, r2 = i2.y, a2 = i2.x, n2 = i2.y, s2 = 0, l2 = e2; s2 < l2.length; s2 += 1) {
            var c2 = l2[s2];
            o2 = Math.min(o2, c2.x), r2 = Math.min(r2, c2.y), a2 = Math.max(a2, c2.x), n2 = Math.max(n2, c2.y);
          }
          return [new t.Point(o2, r2), new t.Point(a2, r2), new t.Point(a2, n2), new t.Point(o2, n2), new t.Point(o2, r2)];
        }, Object.defineProperties(po.prototype, _o);
        var fo = function(e2) {
          var i2, o2, r2, a2, n2;
          this._hashName = e2 && encodeURIComponent(e2), t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = (i2 = this._updateHashUnthrottled.bind(this), o2 = 300, r2 = false, a2 = null, n2 = function() {
            a2 = null, r2 && (i2(), a2 = setTimeout(n2, o2), r2 = false);
          }, function() {
            return r2 = true, a2 || n2(), a2;
          });
        };
        fo.prototype.addTo = function(e2) {
          return this._map = e2, t.window.addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
        }, fo.prototype.remove = function() {
          return t.window.removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
        }, fo.prototype.getHashString = function(e2) {
          var i2 = this._map.getCenter(), o2 = Math.round(100 * this._map.getZoom()) / 100, r2 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a2 = Math.pow(10, r2), n2 = Math.round(i2.lng * a2) / a2, s2 = Math.round(i2.lat * a2) / a2, l2 = this._map.getBearing(), c2 = this._map.getPitch(), u2 = "";
          if (u2 += e2 ? "/" + n2 + "/" + s2 + "/" + o2 : o2 + "/" + s2 + "/" + n2, (l2 || c2) && (u2 += "/" + Math.round(10 * l2) / 10), c2 && (u2 += "/" + Math.round(c2)), this._hashName) {
            var h2 = this._hashName, p2 = false, d2 = t.window.location.hash.slice(1).split("&").map(function(t2) {
              var e3 = t2.split("=")[0];
              return e3 === h2 ? (p2 = true, e3 + "=" + u2) : t2;
            }).filter(function(t2) {
              return t2;
            });
            return p2 || d2.push(h2 + "=" + u2), "#" + d2.join("&");
          }
          return "#" + u2;
        }, fo.prototype._getCurrentHash = function() {
          var e2, i2 = this, o2 = t.window.location.hash.replace("#", "");
          return this._hashName ? (o2.split("&").map(function(t2) {
            return t2.split("=");
          }).forEach(function(t2) {
            t2[0] === i2._hashName && (e2 = t2);
          }), (e2 && e2[1] || "").split("/")) : o2.split("/");
        }, fo.prototype._onHashChange = function() {
          var t2 = this._getCurrentHash();
          return t2.length >= 3 && !t2.some(function(t3) {
            return isNaN(t3);
          }) && (this._map.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: +(t2[3] || 0), pitch: +(t2[4] || 0) }), true);
        }, fo.prototype._updateHashUnthrottled = function() {
          var e2 = this.getHashString();
          try {
            t.window.history.replaceState(t.window.history.state, "", e2);
          } catch (t2) {
          }
        };
        var mo = function(e2) {
          function o2(o3, r3, a2, n2) {
            void 0 === n2 && (n2 = {});
            var s2 = i.mousePos(r3.getCanvasContainer(), a2), l2 = r3.unproject(s2);
            e2.call(this, o3, t.extend({ point: s2, lngLat: l2, originalEvent: a2 }, n2)), this._defaultPrevented = false, this.target = r3;
          }
          e2 && (o2.__proto__ = e2), o2.prototype = Object.create(e2 && e2.prototype), o2.prototype.constructor = o2;
          var r2 = { defaultPrevented: { configurable: true } };
          return o2.prototype.preventDefault = function() {
            this._defaultPrevented = true;
          }, r2.defaultPrevented.get = function() {
            return this._defaultPrevented;
          }, Object.defineProperties(o2.prototype, r2), o2;
        }(t.Event), go = function(e2) {
          function o2(o3, r3, a2) {
            var n2 = i.touchPos(r3.getCanvasContainer(), a2), s2 = n2.map(function(t2) {
              return r3.unproject(t2);
            }), l2 = n2.reduce(function(t2, e3, i2, o4) {
              return t2.add(e3.div(o4.length));
            }, new t.Point(0, 0)), c2 = r3.unproject(l2);
            e2.call(this, o3, { points: n2, point: l2, lngLats: s2, lngLat: c2, originalEvent: a2 }), this._defaultPrevented = false;
          }
          e2 && (o2.__proto__ = e2), o2.prototype = Object.create(e2 && e2.prototype), o2.prototype.constructor = o2;
          var r2 = { defaultPrevented: { configurable: true } };
          return o2.prototype.preventDefault = function() {
            this._defaultPrevented = true;
          }, r2.defaultPrevented.get = function() {
            return this._defaultPrevented;
          }, Object.defineProperties(o2.prototype, r2), o2;
        }(t.Event), vo = function(t2) {
          function e2(e3, i3, o2) {
            t2.call(this, e3, { originalEvent: o2 }), this._defaultPrevented = false;
          }
          t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2;
          var i2 = { defaultPrevented: { configurable: true } };
          return e2.prototype.preventDefault = function() {
            this._defaultPrevented = true;
          }, i2.defaultPrevented.get = function() {
            return this._defaultPrevented;
          }, Object.defineProperties(e2.prototype, i2), e2;
        }(t.Event), yo = function(e2) {
          this._map = e2, this._el = e2.getCanvasContainer(), this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 1 / 450, t.bindAll(["_onWheel", "_onTimeout", "_onScrollFrame", "_onScrollFinished"], this);
        };
        yo.prototype.setZoomRate = function(t2) {
          this._defaultZoomRate = t2;
        }, yo.prototype.setWheelZoomRate = function(t2) {
          this._wheelZoomRate = t2;
        }, yo.prototype.isEnabled = function() {
          return !!this._enabled;
        }, yo.prototype.isActive = function() {
          return !!this._active;
        }, yo.prototype.isZooming = function() {
          return !!this._zooming;
        }, yo.prototype.enable = function(t2) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = t2 && "center" === t2.around);
        }, yo.prototype.disable = function() {
          this.isEnabled() && (this._enabled = false);
        }, yo.prototype.onWheel = function(e2) {
          if (this.isEnabled()) {
            var i2 = e2.deltaMode === t.window.WheelEvent.DOM_DELTA_LINE ? 40 * e2.deltaY : e2.deltaY, o2 = t.browser.now(), r2 = o2 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o2, 0 !== i2 && i2 % 4.000244140625 == 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : r2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, e2)) : this._type || (this._type = Math.abs(r2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), e2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = e2, this._delta -= i2, this.isActive() || this._start(e2)), e2.preventDefault();
          }
        }, yo.prototype._onTimeout = function(t2) {
          this._type = "wheel", this._delta -= this._lastValue, this.isActive() || this._start(t2);
        }, yo.prototype._start = function(e2) {
          if (this._delta) {
            this._frameId && (this._map._cancelRenderFrame(this._frameId), this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true, this._map.fire(new t.Event("movestart", { originalEvent: e2 })), this._map.fire(new t.Event("zoomstart", { originalEvent: e2 }))), this._finishTimeout && clearTimeout(this._finishTimeout);
            var o2 = i.mousePos(this._el, e2);
            this._around = t.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(o2)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = this._map._requestRenderFrame(this._onScrollFrame));
          }
        }, yo.prototype._onScrollFrame = function() {
          var e2 = this;
          if (this._frameId = null, this.isActive()) {
            var i2 = this._map.transform;
            if (0 !== this._delta) {
              var o2 = "wheel" === this._type && Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate, r2 = 2 / (1 + Math.exp(-Math.abs(this._delta * o2)));
              this._delta < 0 && 0 !== r2 && (r2 = 1 / r2);
              var a2 = "number" == typeof this._targetZoom ? i2.zoomScale(this._targetZoom) : i2.scale;
              this._targetZoom = Math.min(i2.maxZoom, Math.max(i2.minZoom, i2.scaleZoom(a2 * r2))), "wheel" === this._type && (this._startZoom = i2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            var n2 = "number" == typeof this._targetZoom ? this._targetZoom : i2.zoom, s2 = this._startZoom, l2 = this._easing, c2 = false;
            if ("wheel" === this._type && s2 && l2) {
              var u2 = Math.min((t.browser.now() - this._lastWheelEventTime) / 200, 1), h2 = l2(u2);
              i2.zoom = t.number(s2, n2, h2), u2 < 1 ? this._frameId || (this._frameId = this._map._requestRenderFrame(this._onScrollFrame)) : c2 = true;
            } else
              i2.zoom = n2, c2 = true;
            i2.setLocationAtPoint(this._around, this._aroundPoint), this._map.fire(new t.Event("move", { originalEvent: this._lastWheelEvent })), this._map.fire(new t.Event("zoom", { originalEvent: this._lastWheelEvent })), c2 && (this._active = false, this._finishTimeout = setTimeout(function() {
              e2._zooming = false, e2._map.fire(new t.Event("zoomend", { originalEvent: e2._lastWheelEvent })), e2._map.fire(new t.Event("moveend", { originalEvent: e2._lastWheelEvent })), delete e2._targetZoom;
            }, 200));
          }
        }, yo.prototype._smoothOutEasing = function(e2) {
          var i2 = t.ease;
          if (this._prevEase) {
            var o2 = this._prevEase, r2 = (t.browser.now() - o2.start) / o2.duration, a2 = o2.easing(r2 + 0.01) - o2.easing(r2), n2 = 0.27 / Math.sqrt(a2 * a2 + 1e-4) * 0.01, s2 = Math.sqrt(0.0729 - n2 * n2);
            i2 = t.bezier(n2, s2, 0.25, 1);
          }
          return this._prevEase = { start: t.browser.now(), duration: e2, easing: i2 }, i2;
        };
        var xo = function(e2, i2) {
          this._map = e2, this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = i2.clickTolerance || 1, t.bindAll(["_onMouseMove", "_onMouseUp", "_onKeyDown"], this);
        };
        xo.prototype.isEnabled = function() {
          return !!this._enabled;
        }, xo.prototype.isActive = function() {
          return !!this._active;
        }, xo.prototype.enable = function() {
          this.isEnabled() || (this._enabled = true);
        }, xo.prototype.disable = function() {
          this.isEnabled() && (this._enabled = false);
        }, xo.prototype.onMouseDown = function(e2) {
          this.isEnabled() && e2.shiftKey && 0 === e2.button && (t.window.document.addEventListener("mousemove", this._onMouseMove, false), t.window.document.addEventListener("keydown", this._onKeyDown, false), t.window.document.addEventListener("mouseup", this._onMouseUp, false), i.disableDrag(), this._startPos = this._lastPos = i.mousePos(this._el, e2), this._active = true);
        }, xo.prototype._onMouseMove = function(t2) {
          var e2 = i.mousePos(this._el, t2);
          if (!(this._lastPos.equals(e2) || !this._box && e2.dist(this._startPos) < this._clickTolerance)) {
            var o2 = this._startPos;
            this._lastPos = e2, this._box || (this._box = i.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t2));
            var r2 = Math.min(o2.x, e2.x), a2 = Math.max(o2.x, e2.x), n2 = Math.min(o2.y, e2.y), s2 = Math.max(o2.y, e2.y);
            i.setTransform(this._box, "translate(" + r2 + "px," + n2 + "px)"), this._box.style.width = a2 - r2 + "px", this._box.style.height = s2 - n2 + "px";
          }
        }, xo.prototype._onMouseUp = function(e2) {
          if (0 === e2.button) {
            var o2 = this._startPos, r2 = i.mousePos(this._el, e2);
            this._finish(), i.suppressClick(), o2.x === r2.x && o2.y === r2.y ? this._fireEvent("boxzoomcancel", e2) : this._map.fitScreenCoordinates(o2, r2, this._map.getBearing(), { linear: true }).fire(new t.Event("boxzoomend", { originalEvent: e2 }));
          }
        }, xo.prototype._onKeyDown = function(t2) {
          27 === t2.keyCode && (this._finish(), this._fireEvent("boxzoomcancel", t2));
        }, xo.prototype._finish = function() {
          this._active = false, t.window.document.removeEventListener("mousemove", this._onMouseMove, false), t.window.document.removeEventListener("keydown", this._onKeyDown, false), t.window.document.removeEventListener("mouseup", this._onMouseUp, false), this._container.classList.remove("mapboxgl-crosshair"), this._box && (i.remove(this._box), this._box = null), i.enableDrag(), delete this._startPos, delete this._lastPos;
        }, xo.prototype._fireEvent = function(e2, i2) {
          return this._map.fire(new t.Event(e2, { originalEvent: i2 }));
        };
        var bo = t.bezier(0, 0, 0.25, 1), wo = function(e2, i2) {
          this._map = e2, this._el = i2.element || e2.getCanvasContainer(), this._state = "disabled", this._button = i2.button || "right", this._bearingSnap = i2.bearingSnap || 0, this._pitchWithRotate = false !== i2.pitchWithRotate, t.bindAll(["onMouseDown", "_onMouseMove", "_onMouseUp", "_onBlur", "_onDragFrame"], this);
        };
        wo.prototype.isEnabled = function() {
          return "disabled" !== this._state;
        }, wo.prototype.isActive = function() {
          return "active" === this._state;
        }, wo.prototype.enable = function() {
          this.isEnabled() || (this._state = "enabled");
        }, wo.prototype.disable = function() {
          if (this.isEnabled())
            switch (this._state) {
              case "active":
                this._state = "disabled", this._unbind(), this._deactivate(), this._fireEvent("rotateend"), this._pitchWithRotate && this._fireEvent("pitchend"), this._fireEvent("moveend");
                break;
              case "pending":
                this._state = "disabled", this._unbind();
                break;
              default:
                this._state = "disabled";
            }
        }, wo.prototype.onMouseDown = function(e2) {
          if ("enabled" === this._state) {
            var o2 = "touchstart" === e2.type;
            if (o2)
              this._startTime = Date.now();
            else if ("right" === this._button) {
              if (this._eventButton = i.mouseButton(e2), this._eventButton !== (e2.ctrlKey ? 0 : 2))
                return;
            } else {
              if (e2.ctrlKey || 0 !== i.mouseButton(e2))
                return;
              this._eventButton = 0;
            }
            i.disableDrag(), o2 ? (t.window.document.addEventListener("touchmove", this._onMouseMove, { capture: true }), t.window.document.addEventListener("touchend", this._onMouseUp)) : (t.window.document.addEventListener("mousemove", this._onMouseMove, { capture: true }), t.window.document.addEventListener("mouseup", this._onMouseUp)), t.window.addEventListener("blur", this._onBlur), this._state = "pending", this._inertia = [[t.browser.now(), this._map.getBearing()]], this._startPos = this._prevPos = this._lastPos = i.mousePos(this._el, e2), this._center = this._map.transform.centerPoint, e2.preventDefault();
          }
        }, wo.prototype._onMouseMove = function(t2) {
          var e2 = i.mousePos(this._el, t2);
          this._lastPos.equals(e2) || (this._lastMoveEvent = t2, this._lastPos = e2, "pending" === this._state && (this._state = "active", this._fireEvent("rotatestart", t2), this._fireEvent("movestart", t2), this._pitchWithRotate && this._fireEvent("pitchstart", t2)), this._frameId || (this._frameId = this._map._requestRenderFrame(this._onDragFrame)));
        }, wo.prototype._onDragFrame = function() {
          this._frameId = null;
          var e2 = this._lastMoveEvent;
          if (e2) {
            var i2 = this._map.transform, o2 = this._prevPos, r2 = this._lastPos, a2 = 0.8 * (o2.x - r2.x), n2 = -0.5 * (o2.y - r2.y), s2 = i2.bearing - a2, l2 = i2.pitch - n2, c2 = this._inertia, u2 = c2[c2.length - 1];
            this._drainInertiaBuffer(), c2.push([t.browser.now(), this._map._normalizeBearing(s2, u2[1])]);
            var h2 = i2.bearing;
            if (i2.bearing = s2, this._pitchWithRotate) {
              var p2 = i2.pitch;
              i2.pitch = l2, i2.pitch !== p2 && this._fireEvent("pitch", e2);
            }
            i2.bearing !== h2 && this._fireEvent("rotate", e2), this._fireEvent("move", e2), delete this._lastMoveEvent, this._prevPos = this._lastPos;
          }
        }, wo.prototype._onMouseUp = function(t2) {
          var e2 = "touchend" === t2.type;
          if (e2 && this._startPos === this._lastPos && Date.now() - this._startTime < 300 && this._el.click(), e2 || i.mouseButton(t2) === this._eventButton)
            switch (this._state) {
              case "active":
                this._state = "enabled", i.suppressClick(), this._unbind(), this._deactivate(), this._inertialRotate(t2);
                break;
              case "pending":
                this._state = "enabled", this._unbind();
            }
        }, wo.prototype._onBlur = function(t2) {
          switch (this._state) {
            case "active":
              this._state = "enabled", this._unbind(), this._deactivate(), this._fireEvent("rotateend", t2), this._pitchWithRotate && this._fireEvent("pitchend", t2), this._fireEvent("moveend", t2);
              break;
            case "pending":
              this._state = "enabled", this._unbind();
          }
        }, wo.prototype._unbind = function() {
          t.window.document.removeEventListener("mousemove", this._onMouseMove, { capture: true }), t.window.document.removeEventListener("mouseup", this._onMouseUp), t.window.document.removeEventListener("touchmove", this._onMouseMove, { capture: true }), t.window.document.removeEventListener("touchend", this._onMouseUp), t.window.removeEventListener("blur", this._onBlur), i.enableDrag();
        }, wo.prototype._deactivate = function() {
          this._frameId && (this._map._cancelRenderFrame(this._frameId), this._frameId = null), delete this._lastMoveEvent, delete this._startPos, delete this._prevPos, delete this._lastPos;
        }, wo.prototype._inertialRotate = function(t2) {
          var e2 = this;
          this._fireEvent("rotateend", t2), this._drainInertiaBuffer();
          var i2 = this._map, o2 = i2.getBearing(), r2 = this._inertia, a2 = function() {
            Math.abs(o2) < e2._bearingSnap ? i2.resetNorth({ noMoveStart: true }, { originalEvent: t2 }) : e2._fireEvent("moveend", t2), e2._pitchWithRotate && e2._fireEvent("pitchend", t2);
          };
          if (r2.length < 2)
            a2();
          else {
            var n2 = r2[0], s2 = r2[r2.length - 1], l2 = r2[r2.length - 2], c2 = i2._normalizeBearing(o2, l2[1]), u2 = s2[1] - n2[1], h2 = u2 < 0 ? -1 : 1, p2 = (s2[0] - n2[0]) / 1e3;
            if (0 !== u2 && 0 !== p2) {
              var d2 = Math.abs(u2 * (0.25 / p2));
              d2 > 180 && (d2 = 180);
              var _2 = d2 / 180;
              c2 += h2 * d2 * (_2 / 2), Math.abs(i2._normalizeBearing(c2, 0)) < this._bearingSnap && (c2 = i2._normalizeBearing(0, c2)), i2.rotateTo(c2, { duration: 1e3 * _2, easing: bo, noMoveStart: true }, { originalEvent: t2 });
            } else
              a2();
          }
        }, wo.prototype._fireEvent = function(e2, i2) {
          return this._map.fire(new t.Event(e2, i2 ? { originalEvent: i2 } : {}));
        }, wo.prototype._drainInertiaBuffer = function() {
          for (var e2 = this._inertia, i2 = t.browser.now(); e2.length > 0 && i2 - e2[0][0] > 160; )
            e2.shift();
        };
        var Eo = { linearity: 0.3, easing: t.bezier(0, 0, 0.3, 1), maxSpeed: 1400, deceleration: 2500 }, To = function(e2, i2) {
          this._map = e2, this._el = e2.getCanvasContainer(), this._state = "disabled", this._clickTolerance = i2.clickTolerance || 1, this._inertiaOptions = Eo, t.bindAll(["_onMove", "_onMouseUp", "_onTouchEnd", "_onBlur", "_onDragFrame"], this);
        };
        To.prototype.isEnabled = function() {
          return "disabled" !== this._state;
        }, To.prototype.isActive = function() {
          return "active" === this._state;
        }, To.prototype.enable = function(e2) {
          this.isEnabled() || (this._el.classList.add("mapboxgl-touch-drag-pan"), this._state = "enabled", this._inertiaOptions = t.extend(Eo, e2));
        }, To.prototype.disable = function() {
          if (this.isEnabled())
            switch (this._el.classList.remove("mapboxgl-touch-drag-pan"), this._state) {
              case "active":
                this._state = "disabled", this._unbind(), this._deactivate(), this._fireEvent("dragend"), this._fireEvent("moveend");
                break;
              case "pending":
                this._state = "disabled", this._unbind();
                break;
              default:
                this._state = "disabled";
            }
        }, To.prototype.onMouseDown = function(e2) {
          "enabled" === this._state && (e2.ctrlKey || 0 !== i.mouseButton(e2) || (i.addEventListener(t.window.document, "mousemove", this._onMove, { capture: true }), i.addEventListener(t.window.document, "mouseup", this._onMouseUp), this._start(e2)));
        }, To.prototype.onTouchStart = function(e2) {
          this.isEnabled() && (e2.touches && e2.touches.length > 1 && ("pending" === this._state || "active" === this._state) || (i.addEventListener(t.window.document, "touchmove", this._onMove, { capture: true, passive: false }), i.addEventListener(t.window.document, "touchend", this._onTouchEnd), this._start(e2)));
        }, To.prototype._start = function(e2) {
          t.window.addEventListener("blur", this._onBlur), this._state = "pending", this._startPos = this._mouseDownPos = this._prevPos = this._lastPos = i.mousePos(this._el, e2), this._startTouch = this._lastTouch = t.window.TouchEvent && e2 instanceof t.window.TouchEvent ? i.touchPos(this._el, e2) : null, this._inertia = [[t.browser.now(), this._startPos]];
        }, To.prototype._touchesMatch = function(t2, e2) {
          return !(!t2 || !e2 || t2.length !== e2.length) && t2.every(function(t3, i2) {
            return e2[i2] === t3;
          });
        }, To.prototype._onMove = function(e2) {
          e2.preventDefault();
          var o2 = t.window.TouchEvent && e2 instanceof t.window.TouchEvent ? i.touchPos(this._el, e2) : null, r2 = i.mousePos(this._el, e2);
          (o2 ? this._touchesMatch(this._lastTouch, o2) : this._lastPos.equals(r2)) || "pending" === this._state && r2.dist(this._mouseDownPos) < this._clickTolerance || (this._lastMoveEvent = e2, this._lastPos = r2, this._lastTouch = o2, this._drainInertiaBuffer(), this._inertia.push([t.browser.now(), this._lastPos]), "pending" === this._state && (this._state = "active", this._shouldStart = true), this._frameId || (this._frameId = this._map._requestRenderFrame(this._onDragFrame)));
        }, To.prototype._onDragFrame = function() {
          this._frameId = null;
          var t2 = this._lastMoveEvent;
          if (t2) {
            if (this._map.touchZoomRotate.isActive())
              this._abort(t2);
            else if (this._shouldStart && (this._fireEvent("dragstart", t2), this._fireEvent("movestart", t2), this._shouldStart = false), this.isActive()) {
              var e2 = this._map.transform;
              e2.setLocationAtPoint(e2.pointLocation(this._prevPos), this._lastPos), this._fireEvent("drag", t2), this._fireEvent("move", t2), this._prevPos = this._lastPos, delete this._lastMoveEvent;
            }
          }
        }, To.prototype._onMouseUp = function(t2) {
          if (0 === i.mouseButton(t2))
            switch (this._state) {
              case "active":
                this._state = "enabled", i.suppressClick(), this._unbind(), this._deactivate(), this._inertialPan(t2);
                break;
              case "pending":
                this._state = "enabled", this._unbind();
            }
        }, To.prototype._onTouchEnd = function(t2) {
          if (t2.touches && 0 !== t2.touches.length)
            switch (this._state) {
              case "pending":
              case "active":
                break;
              case "enabled":
                this.onTouchStart(t2);
            }
          else
            switch (this._state) {
              case "active":
                this._state = "enabled", this._unbind(), this._deactivate(), this._inertialPan(t2);
                break;
              case "pending":
                this._state = "enabled", this._unbind();
                break;
              case "enabled":
                this._unbind();
            }
        }, To.prototype._abort = function(e2) {
          switch (this._state) {
            case "active":
              this._state = "enabled", this._shouldStart || (this._fireEvent("dragend", e2), this._fireEvent("moveend", e2)), this._unbind(), this._deactivate(), t.window.TouchEvent && e2 instanceof t.window.TouchEvent && e2.touches.length > 1 && i.addEventListener(t.window.document, "touchend", this._onTouchEnd);
              break;
            case "pending":
              this._state = "enabled", this._unbind();
              break;
            case "enabled":
              this._unbind();
          }
        }, To.prototype._onBlur = function(t2) {
          this._abort(t2);
        }, To.prototype._unbind = function() {
          i.removeEventListener(t.window.document, "touchmove", this._onMove, { capture: true, passive: false }), i.removeEventListener(t.window.document, "touchend", this._onTouchEnd), i.removeEventListener(t.window.document, "mousemove", this._onMove, { capture: true }), i.removeEventListener(t.window.document, "mouseup", this._onMouseUp), i.removeEventListener(t.window, "blur", this._onBlur);
        }, To.prototype._deactivate = function() {
          this._frameId && (this._map._cancelRenderFrame(this._frameId), this._frameId = null), delete this._lastMoveEvent, delete this._startPos, delete this._prevPos, delete this._mouseDownPos, delete this._lastPos, delete this._startTouch, delete this._lastTouch, delete this._shouldStart;
        }, To.prototype._inertialPan = function(t2) {
          this._fireEvent("dragend", t2), this._drainInertiaBuffer();
          var e2 = this._inertia;
          if (e2.length < 2)
            this._fireEvent("moveend", t2);
          else {
            var i2 = e2[e2.length - 1], o2 = e2[0], r2 = i2[1].sub(o2[1]), a2 = (i2[0] - o2[0]) / 1e3;
            if (0 === a2 || i2[1].equals(o2[1]))
              this._fireEvent("moveend", t2);
            else {
              var n2 = this._inertiaOptions, s2 = n2.linearity, l2 = n2.easing, c2 = n2.maxSpeed, u2 = n2.deceleration, h2 = r2.mult(s2 / a2), p2 = h2.mag();
              p2 > c2 && (p2 = c2, h2._unit()._mult(p2));
              var d2 = p2 / (u2 * s2), _2 = h2.mult(-d2 / 2);
              this._map.panBy(_2, { duration: 1e3 * d2, easing: l2, noMoveStart: true }, { originalEvent: t2 });
            }
          }
        }, To.prototype._fireEvent = function(e2, i2) {
          return this._map.fire(new t.Event(e2, i2 ? { originalEvent: i2 } : {}));
        }, To.prototype._drainInertiaBuffer = function() {
          for (var e2 = this._inertia, i2 = t.browser.now(); e2.length > 0 && i2 - e2[0][0] > 160; )
            e2.shift();
        };
        var Io = function(e2) {
          this._map = e2, this._el = e2.getCanvasContainer(), t.bindAll(["_onKeyDown"], this);
        };
        function So(t2) {
          return t2 * (2 - t2);
        }
        Io.prototype.isEnabled = function() {
          return !!this._enabled;
        }, Io.prototype.enable = function() {
          this.isEnabled() || (this._el.addEventListener("keydown", this._onKeyDown, false), this._enabled = true);
        }, Io.prototype.disable = function() {
          this.isEnabled() && (this._el.removeEventListener("keydown", this._onKeyDown), this._enabled = false);
        }, Io.prototype._onKeyDown = function(t2) {
          if (!(t2.altKey || t2.ctrlKey || t2.metaKey)) {
            var e2 = 0, i2 = 0, o2 = 0, r2 = 0, a2 = 0;
            switch (t2.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                e2 = 1;
                break;
              case 189:
              case 109:
              case 173:
                e2 = -1;
                break;
              case 37:
                t2.shiftKey ? i2 = -1 : (t2.preventDefault(), r2 = -1);
                break;
              case 39:
                t2.shiftKey ? i2 = 1 : (t2.preventDefault(), r2 = 1);
                break;
              case 38:
                t2.shiftKey ? o2 = 1 : (t2.preventDefault(), a2 = -1);
                break;
              case 40:
                t2.shiftKey ? o2 = -1 : (a2 = 1, t2.preventDefault());
                break;
              default:
                return;
            }
            var n2 = this._map, s2 = n2.getZoom(), l2 = { duration: 300, delayEndEvents: 500, easing: So, zoom: e2 ? Math.round(s2) + e2 * (t2.shiftKey ? 2 : 1) : s2, bearing: n2.getBearing() + 15 * i2, pitch: n2.getPitch() + 10 * o2, offset: [100 * -r2, 100 * -a2], center: n2.getCenter() };
            n2.easeTo(l2, { originalEvent: t2 });
          }
        };
        var Co = function(e2) {
          this._map = e2, t.bindAll(["_onDblClick", "_onZoomEnd"], this);
        };
        Co.prototype.isEnabled = function() {
          return !!this._enabled;
        }, Co.prototype.isActive = function() {
          return !!this._active;
        }, Co.prototype.enable = function() {
          this.isEnabled() || (this._enabled = true);
        }, Co.prototype.disable = function() {
          this.isEnabled() && (this._enabled = false);
        }, Co.prototype.onTouchStart = function(t2) {
          var e2 = this;
          if (this.isEnabled() && !(t2.points.length > 1))
            if (this._tapped) {
              var i2 = t2.points[0], o2 = this._tappedPoint;
              if (o2 && o2.dist(i2) <= 30) {
                t2.originalEvent.preventDefault();
                var r2 = function() {
                  e2._tapped && e2._zoom(t2), e2._map.off("touchcancel", a2), e2._resetTapped();
                }, a2 = function() {
                  e2._map.off("touchend", r2), e2._resetTapped();
                };
                this._map.once("touchend", r2), this._map.once("touchcancel", a2);
              } else
                this._resetTapped();
            } else
              this._tappedPoint = t2.points[0], this._tapped = setTimeout(function() {
                e2._tapped = null, e2._tappedPoint = null;
              }, 300);
        }, Co.prototype._resetTapped = function() {
          clearTimeout(this._tapped), this._tapped = null, this._tappedPoint = null;
        }, Co.prototype.onDblClick = function(t2) {
          this.isEnabled() && (t2.originalEvent.preventDefault(), this._zoom(t2));
        }, Co.prototype._zoom = function(t2) {
          this._active = true, this._map.on("zoomend", this._onZoomEnd), this._map.zoomTo(this._map.getZoom() + (t2.originalEvent.shiftKey ? -1 : 1), { around: t2.lngLat }, t2);
        }, Co.prototype._onZoomEnd = function() {
          this._active = false, this._map.off("zoomend", this._onZoomEnd);
        };
        var Po = t.bezier(0, 0, 0.15, 1), zo = function(e2) {
          this._map = e2, this._el = e2.getCanvasContainer(), t.bindAll(["_onMove", "_onEnd", "_onTouchFrame"], this);
        };
        zo.prototype.isEnabled = function() {
          return !!this._enabled;
        }, zo.prototype.enable = function(t2) {
          this.isEnabled() || (this._el.classList.add("mapboxgl-touch-zoom-rotate"), this._enabled = true, this._aroundCenter = !!t2 && "center" === t2.around);
        }, zo.prototype.disable = function() {
          this.isEnabled() && (this._el.classList.remove("mapboxgl-touch-zoom-rotate"), this._enabled = false);
        }, zo.prototype.disableRotation = function() {
          this._rotationDisabled = true;
        }, zo.prototype.enableRotation = function() {
          this._rotationDisabled = false;
        }, zo.prototype.isActive = function() {
          return this.isEnabled() && !!this._gestureIntent;
        }, zo.prototype.onStart = function(e2) {
          if (this.isEnabled() && 2 === e2.touches.length) {
            var o2 = i.mousePos(this._el, e2.touches[0]), r2 = i.mousePos(this._el, e2.touches[1]), a2 = o2.add(r2).div(2);
            this._startVec = o2.sub(r2), this._startAround = this._map.transform.pointLocation(a2), this._gestureIntent = void 0, this._inertia = [], i.addEventListener(t.window.document, "touchmove", this._onMove, { passive: false }), i.addEventListener(t.window.document, "touchend", this._onEnd);
          }
        }, zo.prototype._getTouchEventData = function(t2) {
          var e2 = i.mousePos(this._el, t2.touches[0]), o2 = i.mousePos(this._el, t2.touches[1]), r2 = e2.sub(o2);
          return { vec: r2, center: e2.add(o2).div(2), scale: r2.mag() / this._startVec.mag(), bearing: this._rotationDisabled ? 0 : 180 * r2.angleWith(this._startVec) / Math.PI };
        }, zo.prototype._onMove = function(e2) {
          if (2 === e2.touches.length) {
            var i2 = this._getTouchEventData(e2), o2 = i2.vec, r2 = i2.scale, a2 = i2.bearing;
            if (!this._gestureIntent) {
              var n2 = this._rotationDisabled && 1 !== r2 || Math.abs(1 - r2) > 0.15;
              Math.abs(a2) > 10 ? this._gestureIntent = "rotate" : n2 && (this._gestureIntent = "zoom"), this._gestureIntent && (this._map.fire(new t.Event(this._gestureIntent + "start", { originalEvent: e2 })), this._map.fire(new t.Event("movestart", { originalEvent: e2 })), this._startVec = o2);
            }
            this._lastTouchEvent = e2, this._frameId || (this._frameId = this._map._requestRenderFrame(this._onTouchFrame)), e2.preventDefault();
          }
        }, zo.prototype._onTouchFrame = function() {
          this._frameId = null;
          var e2 = this._gestureIntent;
          if (e2) {
            var i2 = this._map.transform;
            this._startScale || (this._startScale = i2.scale, this._startBearing = i2.bearing);
            var o2 = this._getTouchEventData(this._lastTouchEvent), r2 = o2.center, a2 = o2.bearing, n2 = o2.scale, s2 = i2.pointLocation(r2), l2 = i2.locationPoint(s2);
            "rotate" === e2 && (i2.bearing = this._startBearing + a2), i2.zoom = i2.scaleZoom(this._startScale * n2), i2.setLocationAtPoint(this._startAround, l2), this._map.fire(new t.Event(e2, { originalEvent: this._lastTouchEvent })), this._map.fire(new t.Event("move", { originalEvent: this._lastTouchEvent })), this._drainInertiaBuffer(), this._inertia.push([t.browser.now(), n2, r2]);
          }
        }, zo.prototype._onEnd = function(e2) {
          i.removeEventListener(t.window.document, "touchmove", this._onMove, { passive: false }), i.removeEventListener(t.window.document, "touchend", this._onEnd);
          var o2 = this._gestureIntent, r2 = this._startScale;
          if (this._frameId && (this._map._cancelRenderFrame(this._frameId), this._frameId = null), delete this._gestureIntent, delete this._startScale, delete this._startBearing, delete this._lastTouchEvent, o2) {
            this._map.fire(new t.Event(o2 + "end", { originalEvent: e2 })), this._drainInertiaBuffer();
            var a2 = this._inertia, n2 = this._map;
            if (a2.length < 2)
              n2.snapToNorth({}, { originalEvent: e2 });
            else {
              var s2 = a2[a2.length - 1], l2 = a2[0], c2 = n2.transform.scaleZoom(r2 * s2[1]), u2 = n2.transform.scaleZoom(r2 * l2[1]), h2 = c2 - u2, p2 = (s2[0] - l2[0]) / 1e3, d2 = s2[2];
              if (0 !== p2 && c2 !== u2) {
                var _2 = 0.15 * h2 / p2;
                Math.abs(_2) > 2.5 && (_2 = _2 > 0 ? 2.5 : -2.5);
                var f2 = 1e3 * Math.abs(_2 / (12 * 0.15)), m2 = c2 + _2 * f2 / 2e3;
                n2.easeTo({ zoom: m2, duration: f2, easing: Po, around: this._aroundCenter ? n2.getCenter() : n2.unproject(d2), noMoveStart: true }, { originalEvent: e2 });
              } else
                n2.snapToNorth({}, { originalEvent: e2 });
            }
          }
        }, zo.prototype._drainInertiaBuffer = function() {
          for (var e2 = this._inertia, i2 = t.browser.now(); e2.length > 2 && i2 - e2[0][0] > 160; )
            e2.shift();
        };
        var Mo = { scrollZoom: yo, boxZoom: xo, dragRotate: wo, dragPan: To, keyboard: Io, doubleClickZoom: Co, touchZoomRotate: zo };
        var Lo = function(e2) {
          function i2(i3, o2) {
            e2.call(this), this._moving = false, this._zooming = false, this.transform = i3, this._bearingSnap = o2.bearingSnap, t.bindAll(["_renderFrameCallback"], this);
          }
          return e2 && (i2.__proto__ = e2), i2.prototype = Object.create(e2 && e2.prototype), i2.prototype.constructor = i2, i2.prototype.getCenter = function() {
            return new t.LngLat(this.transform.center.lng, this.transform.center.lat);
          }, i2.prototype.setCenter = function(t2, e3) {
            return this.jumpTo({ center: t2 }, e3);
          }, i2.prototype.panBy = function(e3, i3, o2) {
            return e3 = t.Point.convert(e3).mult(-1), this.panTo(this.transform.center, t.extend({ offset: e3 }, i3), o2);
          }, i2.prototype.panTo = function(e3, i3, o2) {
            return this.easeTo(t.extend({ center: e3 }, i3), o2);
          }, i2.prototype.getZoom = function() {
            return this.transform.zoom;
          }, i2.prototype.setZoom = function(t2, e3) {
            return this.jumpTo({ zoom: t2 }, e3), this;
          }, i2.prototype.zoomTo = function(e3, i3, o2) {
            return this.easeTo(t.extend({ zoom: e3 }, i3), o2);
          }, i2.prototype.zoomIn = function(t2, e3) {
            return this.zoomTo(this.getZoom() + 1, t2, e3), this;
          }, i2.prototype.zoomOut = function(t2, e3) {
            return this.zoomTo(this.getZoom() - 1, t2, e3), this;
          }, i2.prototype.getBearing = function() {
            return this.transform.bearing;
          }, i2.prototype.setBearing = function(t2, e3) {
            return this.jumpTo({ bearing: t2 }, e3), this;
          }, i2.prototype.rotateTo = function(e3, i3, o2) {
            return this.easeTo(t.extend({ bearing: e3 }, i3), o2);
          }, i2.prototype.resetNorth = function(e3, i3) {
            return this.rotateTo(0, t.extend({ duration: 1e3 }, e3), i3), this;
          }, i2.prototype.resetNorthPitch = function(e3, i3) {
            return this.easeTo(t.extend({ bearing: 0, pitch: 0, duration: 1e3 }, e3), i3), this;
          }, i2.prototype.snapToNorth = function(t2, e3) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t2, e3) : this;
          }, i2.prototype.getPitch = function() {
            return this.transform.pitch;
          }, i2.prototype.setPitch = function(t2, e3) {
            return this.jumpTo({ pitch: t2 }, e3), this;
          }, i2.prototype.cameraForBounds = function(e3, i3) {
            return e3 = t.LngLatBounds.convert(e3), this._cameraForBoxAndBearing(e3.getNorthWest(), e3.getSouthEast(), 0, i3);
          }, i2.prototype._cameraForBoxAndBearing = function(e3, i3, o2, r2) {
            if ("number" == typeof (r2 = t.extend({ padding: { top: 0, bottom: 0, right: 0, left: 0 }, offset: [0, 0], maxZoom: this.transform.maxZoom }, r2)).padding) {
              var a2 = r2.padding;
              r2.padding = { top: a2, bottom: a2, right: a2, left: a2 };
            }
            if (t.deepEqual(Object.keys(r2.padding).sort(function(t2, e4) {
              return t2 < e4 ? -1 : t2 > e4 ? 1 : 0;
            }), ["bottom", "left", "right", "top"])) {
              var n2 = this.transform, s2 = n2.project(t.LngLat.convert(e3)), l2 = n2.project(t.LngLat.convert(i3)), c2 = s2.rotate(-o2 * Math.PI / 180), u2 = l2.rotate(-o2 * Math.PI / 180), h2 = new t.Point(Math.max(c2.x, u2.x), Math.max(c2.y, u2.y)), p2 = new t.Point(Math.min(c2.x, u2.x), Math.min(c2.y, u2.y)), d2 = h2.sub(p2), _2 = (n2.width - r2.padding.left - r2.padding.right) / d2.x, f2 = (n2.height - r2.padding.top - r2.padding.bottom) / d2.y;
              if (!(f2 < 0 || _2 < 0)) {
                var m2 = Math.min(n2.scaleZoom(n2.scale * Math.min(_2, f2)), r2.maxZoom), g2 = t.Point.convert(r2.offset), v2 = (r2.padding.left - r2.padding.right) / 2, y2 = (r2.padding.top - r2.padding.bottom) / 2, x2 = new t.Point(g2.x + v2, g2.y + y2).mult(n2.scale / n2.zoomScale(m2));
                return { center: n2.unproject(s2.add(l2).div(2).sub(x2)), zoom: m2, bearing: o2 };
              }
              t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            } else
              t.warnOnce("options.padding must be a positive number, or an Object with keys 'bottom', 'left', 'right', 'top'");
          }, i2.prototype.fitBounds = function(t2, e3, i3) {
            return this._fitInternal(this.cameraForBounds(t2, e3), e3, i3);
          }, i2.prototype.fitScreenCoordinates = function(e3, i3, o2, r2, a2) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.Point.convert(e3)), this.transform.pointLocation(t.Point.convert(i3)), o2, r2), r2, a2);
          }, i2.prototype._fitInternal = function(e3, i3, o2) {
            return e3 ? (i3 = t.extend(e3, i3)).linear ? this.easeTo(i3, o2) : this.flyTo(i3, o2) : this;
          }, i2.prototype.jumpTo = function(e3, i3) {
            this.stop();
            var o2 = this.transform, r2 = false, a2 = false, n2 = false;
            return "zoom" in e3 && o2.zoom !== +e3.zoom && (r2 = true, o2.zoom = +e3.zoom), void 0 !== e3.center && (o2.center = t.LngLat.convert(e3.center)), "bearing" in e3 && o2.bearing !== +e3.bearing && (a2 = true, o2.bearing = +e3.bearing), "pitch" in e3 && o2.pitch !== +e3.pitch && (n2 = true, o2.pitch = +e3.pitch), this.fire(new t.Event("movestart", i3)).fire(new t.Event("move", i3)), r2 && this.fire(new t.Event("zoomstart", i3)).fire(new t.Event("zoom", i3)).fire(new t.Event("zoomend", i3)), a2 && this.fire(new t.Event("rotatestart", i3)).fire(new t.Event("rotate", i3)).fire(new t.Event("rotateend", i3)), n2 && this.fire(new t.Event("pitchstart", i3)).fire(new t.Event("pitch", i3)).fire(new t.Event("pitchend", i3)), this.fire(new t.Event("moveend", i3));
          }, i2.prototype.easeTo = function(e3, i3) {
            var o2 = this;
            this.stop(), (false === (e3 = t.extend({ offset: [0, 0], duration: 500, easing: t.ease }, e3)).animate || !e3.essential && t.browser.prefersReducedMotion) && (e3.duration = 0);
            var r2 = this.transform, a2 = this.getZoom(), n2 = this.getBearing(), s2 = this.getPitch(), l2 = "zoom" in e3 ? +e3.zoom : a2, c2 = "bearing" in e3 ? this._normalizeBearing(e3.bearing, n2) : n2, u2 = "pitch" in e3 ? +e3.pitch : s2, h2 = r2.centerPoint.add(t.Point.convert(e3.offset)), p2 = r2.pointLocation(h2), d2 = t.LngLat.convert(e3.center || p2);
            this._normalizeCenter(d2);
            var _2, f2, m2 = r2.project(p2), g2 = r2.project(d2).sub(m2), v2 = r2.zoomScale(l2 - a2);
            return e3.around && (_2 = t.LngLat.convert(e3.around), f2 = r2.locationPoint(_2)), this._zooming = l2 !== a2, this._rotating = n2 !== c2, this._pitching = u2 !== s2, this._prepareEase(i3, e3.noMoveStart), clearTimeout(this._easeEndTimeoutID), this._ease(function(e4) {
              if (o2._zooming && (r2.zoom = t.number(a2, l2, e4)), o2._rotating && (r2.bearing = t.number(n2, c2, e4)), o2._pitching && (r2.pitch = t.number(s2, u2, e4)), _2)
                r2.setLocationAtPoint(_2, f2);
              else {
                var p3 = r2.zoomScale(r2.zoom - a2), d3 = l2 > a2 ? Math.min(2, v2) : Math.max(0.5, v2), y2 = Math.pow(d3, 1 - e4), x2 = r2.unproject(m2.add(g2.mult(e4 * y2)).mult(p3));
                r2.setLocationAtPoint(r2.renderWorldCopies ? x2.wrap() : x2, h2);
              }
              o2._fireMoveEvents(i3);
            }, function() {
              e3.delayEndEvents ? o2._easeEndTimeoutID = setTimeout(function() {
                return o2._afterEase(i3);
              }, e3.delayEndEvents) : o2._afterEase(i3);
            }, e3), this;
          }, i2.prototype._prepareEase = function(e3, i3) {
            this._moving = true, i3 || this.fire(new t.Event("movestart", e3)), this._zooming && this.fire(new t.Event("zoomstart", e3)), this._rotating && this.fire(new t.Event("rotatestart", e3)), this._pitching && this.fire(new t.Event("pitchstart", e3));
          }, i2.prototype._fireMoveEvents = function(e3) {
            this.fire(new t.Event("move", e3)), this._zooming && this.fire(new t.Event("zoom", e3)), this._rotating && this.fire(new t.Event("rotate", e3)), this._pitching && this.fire(new t.Event("pitch", e3));
          }, i2.prototype._afterEase = function(e3) {
            var i3 = this._zooming, o2 = this._rotating, r2 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, i3 && this.fire(new t.Event("zoomend", e3)), o2 && this.fire(new t.Event("rotateend", e3)), r2 && this.fire(new t.Event("pitchend", e3)), this.fire(new t.Event("moveend", e3));
          }, i2.prototype.flyTo = function(e3, i3) {
            var o2 = this;
            if (!e3.essential && t.browser.prefersReducedMotion) {
              var r2 = t.pick(e3, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(r2, i3);
            }
            this.stop(), e3 = t.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.ease }, e3);
            var a2 = this.transform, n2 = this.getZoom(), s2 = this.getBearing(), l2 = this.getPitch(), c2 = "zoom" in e3 ? t.clamp(+e3.zoom, a2.minZoom, a2.maxZoom) : n2, u2 = "bearing" in e3 ? this._normalizeBearing(e3.bearing, s2) : s2, h2 = "pitch" in e3 ? +e3.pitch : l2, p2 = a2.zoomScale(c2 - n2), d2 = a2.centerPoint.add(t.Point.convert(e3.offset)), _2 = a2.pointLocation(d2), f2 = t.LngLat.convert(e3.center || _2);
            this._normalizeCenter(f2);
            var m2 = a2.project(_2), g2 = a2.project(f2).sub(m2), v2 = e3.curve, y2 = Math.max(a2.width, a2.height), x2 = y2 / p2, b2 = g2.mag();
            if ("minZoom" in e3) {
              var w2 = t.clamp(Math.min(e3.minZoom, n2, c2), a2.minZoom, a2.maxZoom), E2 = y2 / a2.zoomScale(w2 - n2);
              v2 = Math.sqrt(E2 / b2 * 2);
            }
            var T2 = v2 * v2;
            function I2(t2) {
              var e4 = (x2 * x2 - y2 * y2 + (t2 ? -1 : 1) * T2 * T2 * b2 * b2) / (2 * (t2 ? x2 : y2) * T2 * b2);
              return Math.log(Math.sqrt(e4 * e4 + 1) - e4);
            }
            function S2(t2) {
              return (Math.exp(t2) - Math.exp(-t2)) / 2;
            }
            function C2(t2) {
              return (Math.exp(t2) + Math.exp(-t2)) / 2;
            }
            var P2 = I2(0), z2 = function(t2) {
              return C2(P2) / C2(P2 + v2 * t2);
            }, M2 = function(t2) {
              return y2 * ((C2(P2) * (S2(e4 = P2 + v2 * t2) / C2(e4)) - S2(P2)) / T2) / b2;
              var e4;
            }, L2 = (I2(1) - P2) / v2;
            if (Math.abs(b2) < 1e-6 || !isFinite(L2)) {
              if (Math.abs(y2 - x2) < 1e-6)
                return this.easeTo(e3, i3);
              var D2 = x2 < y2 ? -1 : 1;
              L2 = Math.abs(Math.log(x2 / y2)) / v2, M2 = function() {
                return 0;
              }, z2 = function(t2) {
                return Math.exp(D2 * v2 * t2);
              };
            }
            if ("duration" in e3)
              e3.duration = +e3.duration;
            else {
              var A2 = "screenSpeed" in e3 ? +e3.screenSpeed / v2 : +e3.speed;
              e3.duration = 1e3 * L2 / A2;
            }
            return e3.maxDuration && e3.duration > e3.maxDuration && (e3.duration = 0), this._zooming = true, this._rotating = s2 !== u2, this._pitching = h2 !== l2, this._prepareEase(i3, false), this._ease(function(e4) {
              var r3 = e4 * L2, p3 = 1 / z2(r3);
              a2.zoom = 1 === e4 ? c2 : n2 + a2.scaleZoom(p3), o2._rotating && (a2.bearing = t.number(s2, u2, e4)), o2._pitching && (a2.pitch = t.number(l2, h2, e4));
              var _3 = 1 === e4 ? f2 : a2.unproject(m2.add(g2.mult(M2(r3))).mult(p3));
              a2.setLocationAtPoint(a2.renderWorldCopies ? _3.wrap() : _3, d2), o2._fireMoveEvents(i3);
            }, function() {
              return o2._afterEase(i3);
            }, e3), this;
          }, i2.prototype.isEasing = function() {
            return !!this._easeFrameId;
          }, i2.prototype.stop = function() {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              var t2 = this._onEaseEnd;
              delete this._onEaseEnd, t2.call(this);
            }
            return this;
          }, i2.prototype._ease = function(e3, i3, o2) {
            false === o2.animate || 0 === o2.duration ? (e3(1), i3()) : (this._easeStart = t.browser.now(), this._easeOptions = o2, this._onEaseFrame = e3, this._onEaseEnd = i3, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }, i2.prototype._renderFrameCallback = function() {
            var e3 = Math.min((t.browser.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(e3)), e3 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, i2.prototype._normalizeBearing = function(e3, i3) {
            e3 = t.wrap(e3, -180, 180);
            var o2 = Math.abs(e3 - i3);
            return Math.abs(e3 - 360 - i3) < o2 && (e3 -= 360), Math.abs(e3 + 360 - i3) < o2 && (e3 += 360), e3;
          }, i2.prototype._normalizeCenter = function(t2) {
            var e3 = this.transform;
            if (e3.renderWorldCopies && !e3.lngRange) {
              var i3 = t2.lng - e3.center.lng;
              t2.lng += i3 > 180 ? -360 : i3 < -180 ? 360 : 0;
            }
          }, i2;
        }(t.Evented), Do = function(e2) {
          void 0 === e2 && (e2 = {}), this.options = e2, t.bindAll(["_updateEditLink", "_updateData", "_updateCompact"], this);
        };
        Do.prototype.getDefaultPosition = function() {
          return "bottom-right";
        }, Do.prototype.onAdd = function(t2) {
          var e2 = this.options && this.options.compact;
          return this._map = t2, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._innerContainer = i.create("div", "mapboxgl-ctrl-attrib-inner", this._container), e2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === e2 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
        }, Do.prototype.onRemove = function() {
          i.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
        }, Do.prototype._updateEditLink = function() {
          var e2 = this._editLink;
          e2 || (e2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
          var i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || t.config.ACCESS_TOKEN }];
          if (e2) {
            var o2 = i2.reduce(function(t2, e3, o3) {
              return e3.value && (t2 += e3.key + "=" + e3.value + (o3 < i2.length - 1 ? "&" : "")), t2;
            }, "?");
            e2.href = t.config.FEEDBACK_URL + "/" + o2 + (this._map._hash ? this._map._hash.getHashString(true) : ""), e2.rel = "noopener nofollow";
          }
        }, Do.prototype._updateData = function(t2) {
          !t2 || "metadata" !== t2.sourceDataType && "style" !== t2.dataType || (this._updateAttributions(), this._updateEditLink());
        }, Do.prototype._updateAttributions = function() {
          if (this._map.style) {
            var t2 = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t2 = t2.concat(this.options.customAttribution.map(function(t3) {
              return "string" != typeof t3 ? "" : t3;
            })) : "string" == typeof this.options.customAttribution && t2.push(this.options.customAttribution)), this._map.style.stylesheet) {
              var e2 = this._map.style.stylesheet;
              this.styleOwner = e2.owner, this.styleId = e2.id;
            }
            var i2 = this._map.style.sourceCaches;
            for (var o2 in i2) {
              var r2 = i2[o2];
              if (r2.used) {
                var a2 = r2.getSource();
                a2.attribution && t2.indexOf(a2.attribution) < 0 && t2.push(a2.attribution);
              }
            }
            t2.sort(function(t3, e3) {
              return t3.length - e3.length;
            });
            var n2 = (t2 = t2.filter(function(e3, i3) {
              for (var o3 = i3 + 1; o3 < t2.length; o3++)
                if (t2[o3].indexOf(e3) >= 0)
                  return false;
              return true;
            })).join(" | ");
            n2 !== this._attribHTML && (this._attribHTML = n2, t2.length ? (this._innerContainer.innerHTML = n2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
          }
        }, Do.prototype._updateCompact = function() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact");
        };
        var Ao = function() {
          t.bindAll(["_updateLogo"], this), t.bindAll(["_updateCompact"], this);
        };
        Ao.prototype.onAdd = function(t2) {
          this._map = t2, this._container = i.create("div", "mapboxgl-ctrl");
          var e2 = i.create("a", "mapboxgl-ctrl-logo");
          return e2.target = "_blank", e2.rel = "noopener nofollow", e2.href = "https://goong.io/", e2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }, Ao.prototype.onRemove = function() {
          i.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
        }, Ao.prototype.getDefaultPosition = function() {
          return "bottom-left";
        }, Ao.prototype._updateLogo = function(t2) {
          t2 && "metadata" !== t2.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
        }, Ao.prototype._logoRequired = function() {
          return true;
        }, Ao.prototype._updateCompact = function() {
          var t2 = this._container.children;
          if (t2.length) {
            var e2 = t2[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? e2.classList.add("mapboxgl-compact") : e2.classList.remove("mapboxgl-compact");
          }
        };
        var Ro = function() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        };
        Ro.prototype.add = function(t2) {
          var e2 = ++this._id;
          return this._queue.push({ callback: t2, id: e2, cancelled: false }), e2;
        }, Ro.prototype.remove = function(t2) {
          for (var e2 = this._currentlyRunning, i2 = 0, o2 = e2 ? this._queue.concat(e2) : this._queue; i2 < o2.length; i2 += 1) {
            var r2 = o2[i2];
            if (r2.id === t2)
              return void (r2.cancelled = true);
          }
        }, Ro.prototype.run = function() {
          var t2 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (var e2 = 0, i2 = t2; e2 < i2.length; e2 += 1) {
            var o2 = i2[e2];
            if (!o2.cancelled && (o2.callback(), this._cleared))
              break;
          }
          this._cleared = false, this._currentlyRunning = false;
        }, Ro.prototype.clear = function() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        };
        var ko = { "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Goong logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm" }, Bo = t.window.HTMLImageElement, Oo = t.window.HTMLElement, Fo = t.window.ImageBitmap, Uo = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, bearingSnap: 7, clickTolerance: 3, hash: false, attributionControl: true, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: true }, No = function(o2) {
          function r2(e2) {
            var r3 = this;
            if (null != (e2 = t.extend({}, Uo, e2)).minZoom && null != e2.maxZoom && e2.minZoom > e2.maxZoom)
              throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != e2.minPitch && null != e2.maxPitch && e2.minPitch > e2.maxPitch)
              throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != e2.minPitch && e2.minPitch < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (null != e2.maxPitch && e2.maxPitch > 60)
              throw new Error("maxPitch must be less than or equal to 60");
            var a3 = new po(e2.minZoom, e2.maxZoom, e2.minPitch, e2.maxPitch, e2.renderWorldCopies);
            if (o2.call(this, a3, e2), this._interactive = e2.interactive, this._maxTileCacheSize = e2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e2.preserveDrawingBuffer, this._antialias = e2.antialias, this._trackResize = e2.trackResize, this._bearingSnap = e2.bearingSnap, this._refreshExpiredTiles = e2.refreshExpiredTiles, this._fadeDuration = e2.fadeDuration, this._crossSourceCollisions = e2.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e2.collectResourceTiming, this._renderTaskQueue = new Ro(), this._controls = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, ko, e2.locale), this._requestManager = new t.RequestManager(e2.transformRequest, e2.accessToken), "string" == typeof e2.container) {
              if (this._container = t.window.document.getElementById(e2.container), !this._container)
                throw new Error("Container '" + e2.container + "' not found.");
            } else {
              if (!(e2.container instanceof Oo))
                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = e2.container;
            }
            if (e2.maxBounds && this.setMaxBounds(e2.maxBounds), t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter)
              throw new Error("Failed to initialize WebGL.");
            this.on("move", function() {
              return r3._update(false);
            }), this.on("moveend", function() {
              return r3._update(false);
            }), this.on("zoom", function() {
              return r3._update(true);
            }), void 0 !== t.window && (t.window.addEventListener("online", this._onWindowOnline, false), t.window.addEventListener("resize", this._onWindowResize, false)), function(t2, e3) {
              var o3 = t2.getCanvasContainer(), r4 = null, a4 = false, n3 = null;
              for (var s2 in Mo)
                t2[s2] = new Mo[s2](t2, e3), e3.interactive && e3[s2] && t2[s2].enable(e3[s2]);
              i.addEventListener(o3, "mouseout", function(e4) {
                t2.fire(new mo("mouseout", t2, e4));
              }), i.addEventListener(o3, "mousedown", function(r5) {
                a4 = true, n3 = i.mousePos(o3, r5);
                var s3 = new mo("mousedown", t2, r5);
                if (t2.fire(s3), s3.defaultPrevented)
                  return;
                e3.interactive && !t2.doubleClickZoom.isActive() && t2.stop();
                t2.boxZoom.onMouseDown(r5), t2.boxZoom.isActive() || t2.dragPan.isActive() || t2.dragRotate.onMouseDown(r5);
                t2.boxZoom.isActive() || t2.dragRotate.isActive() || t2.dragPan.onMouseDown(r5);
              }), i.addEventListener(o3, "mouseup", function(e4) {
                var i2 = t2.dragRotate.isActive();
                r4 && !i2 && t2.fire(new mo("contextmenu", t2, r4));
                r4 = null, a4 = false, t2.fire(new mo("mouseup", t2, e4));
              }), i.addEventListener(o3, "mousemove", function(e4) {
                if (t2.dragPan.isActive())
                  return;
                if (t2.dragRotate.isActive())
                  return;
                var i2 = e4.target;
                for (; i2 && i2 !== o3; )
                  i2 = i2.parentNode;
                if (i2 !== o3)
                  return;
                t2.fire(new mo("mousemove", t2, e4));
              }), i.addEventListener(o3, "mouseover", function(e4) {
                var i2 = e4.target;
                for (; i2 && i2 !== o3; )
                  i2 = i2.parentNode;
                if (i2 !== o3)
                  return;
                t2.fire(new mo("mouseover", t2, e4));
              }), i.addEventListener(o3, "touchstart", function(i2) {
                var o4 = new go("touchstart", t2, i2);
                if (t2.fire(o4), o4.defaultPrevented)
                  return;
                e3.interactive && t2.stop();
                t2.boxZoom.isActive() || t2.dragRotate.isActive() || t2.dragPan.onTouchStart(i2);
                t2.touchZoomRotate.onStart(i2), t2.doubleClickZoom.onTouchStart(o4);
              }, { passive: false }), i.addEventListener(o3, "touchmove", function(e4) {
                t2.fire(new go("touchmove", t2, e4));
              }, { passive: false }), i.addEventListener(o3, "touchend", function(e4) {
                t2.fire(new go("touchend", t2, e4));
              }), i.addEventListener(o3, "touchcancel", function(e4) {
                t2.fire(new go("touchcancel", t2, e4));
              }), i.addEventListener(o3, "click", function(r5) {
                var a5 = i.mousePos(o3, r5);
                (!n3 || a5.equals(n3) || a5.dist(n3) < e3.clickTolerance) && t2.fire(new mo("click", t2, r5));
              }), i.addEventListener(o3, "dblclick", function(e4) {
                var i2 = new mo("dblclick", t2, e4);
                if (t2.fire(i2), i2.defaultPrevented)
                  return;
                t2.doubleClickZoom.onDblClick(i2);
              }), i.addEventListener(o3, "contextmenu", function(e4) {
                var i2 = t2.dragRotate.isActive();
                a4 || i2 ? a4 && (r4 = e4) : t2.fire(new mo("contextmenu", t2, e4));
                (t2.dragRotate.isEnabled() || t2.listens("contextmenu")) && e4.preventDefault();
              }), i.addEventListener(o3, "wheel", function(i2) {
                e3.interactive && t2.stop();
                var o4 = new vo("wheel", t2, i2);
                if (t2.fire(o4), o4.defaultPrevented)
                  return;
                t2.scrollZoom.onWheel(i2);
              }, { passive: false });
            }(this, e2);
            var n2 = "string" == typeof e2.hash && e2.hash || void 0;
            this._hash = e2.hash && new fo(n2).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e2.center, zoom: e2.zoom, bearing: e2.bearing, pitch: e2.pitch }), e2.bounds && (this.resize(), this.fitBounds(e2.bounds, t.extend({}, e2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e2.localIdeographFontFamily, e2.style && this.setStyle(e2.style, { localIdeographFontFamily: e2.localIdeographFontFamily }), e2.attributionControl && this.addControl(new Do({ customAttribution: e2.customAttribution })), this.addControl(new Ao(), e2.logoPosition), this.on("style.load", function() {
              r3.transform.unmodified && r3.jumpTo(r3.style.stylesheet);
            }), this.on("data", function(e3) {
              r3._update("style" === e3.dataType), r3.fire(new t.Event(e3.dataType + "data", e3));
            }), this.on("dataloading", function(e3) {
              r3.fire(new t.Event(e3.dataType + "dataloading", e3));
            });
          }
          o2 && (r2.__proto__ = o2), r2.prototype = Object.create(o2 && o2.prototype), r2.prototype.constructor = r2;
          var a2 = { showTileBoundaries: { configurable: true }, showCollisionBoxes: { configurable: true }, showOverdrawInspector: { configurable: true }, repaint: { configurable: true }, vertices: { configurable: true }, version: { configurable: true } };
          return r2.prototype._getMapId = function() {
            return this._mapId;
          }, r2.prototype.addControl = function(e2, i2) {
            if (void 0 === i2 && e2.getDefaultPosition && (i2 = e2.getDefaultPosition()), void 0 === i2 && (i2 = "top-right"), !e2 || !e2.onAdd)
              return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            var o3 = e2.onAdd(this);
            this._controls.push(e2);
            var r3 = this._controlPositions[i2];
            return -1 !== i2.indexOf("bottom") ? r3.insertBefore(o3, r3.firstChild) : r3.appendChild(o3), this;
          }, r2.prototype.removeControl = function(e2) {
            if (!e2 || !e2.onRemove)
              return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            var i2 = this._controls.indexOf(e2);
            return i2 > -1 && this._controls.splice(i2, 1), e2.onRemove(this), this;
          }, r2.prototype.resize = function(e2) {
            var i2 = this._containerDimensions(), o3 = i2[0], r3 = i2[1];
            return this._resizeCanvas(o3, r3), this.transform.resize(o3, r3), this.painter.resize(o3, r3), this.fire(new t.Event("movestart", e2)).fire(new t.Event("move", e2)).fire(new t.Event("resize", e2)).fire(new t.Event("moveend", e2)), this;
          }, r2.prototype.getBounds = function() {
            return this.transform.getBounds();
          }, r2.prototype.getMaxBounds = function() {
            return this.transform.getMaxBounds();
          }, r2.prototype.setMaxBounds = function(e2) {
            return this.transform.setMaxBounds(t.LngLatBounds.convert(e2)), this._update();
          }, r2.prototype.setMinZoom = function(t2) {
            if ((t2 = null == t2 ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom)
              return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 && this.setZoom(t2), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }, r2.prototype.getMinZoom = function() {
            return this.transform.minZoom;
          }, r2.prototype.setMaxZoom = function(t2) {
            if ((t2 = null == t2 ? 22 : t2) >= this.transform.minZoom)
              return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 && this.setZoom(t2), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }, r2.prototype.getMaxZoom = function() {
            return this.transform.maxZoom;
          }, r2.prototype.setMinPitch = function(t2) {
            if ((t2 = null == t2 ? 0 : t2) < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (t2 >= 0 && t2 <= this.transform.maxPitch)
              return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 && this.setPitch(t2), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }, r2.prototype.getMinPitch = function() {
            return this.transform.minPitch;
          }, r2.prototype.setMaxPitch = function(t2) {
            if ((t2 = null == t2 ? 60 : t2) > 60)
              throw new Error("maxPitch must be less than or equal to 60");
            if (t2 >= this.transform.minPitch)
              return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 && this.setPitch(t2), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }, r2.prototype.getMaxPitch = function() {
            return this.transform.maxPitch;
          }, r2.prototype.getRenderWorldCopies = function() {
            return this.transform.renderWorldCopies;
          }, r2.prototype.setRenderWorldCopies = function(t2) {
            return this.transform.renderWorldCopies = t2, this._update();
          }, r2.prototype.project = function(e2) {
            return this.transform.locationPoint(t.LngLat.convert(e2));
          }, r2.prototype.unproject = function(e2) {
            return this.transform.pointLocation(t.Point.convert(e2));
          }, r2.prototype.isMoving = function() {
            return this._moving || this.dragPan.isActive() || this.dragRotate.isActive() || this.scrollZoom.isActive();
          }, r2.prototype.isZooming = function() {
            return this._zooming || this.scrollZoom.isZooming();
          }, r2.prototype.isRotating = function() {
            return this._rotating || this.dragRotate.isActive();
          }, r2.prototype.on = function(t2, e2, i2) {
            var r3 = this;
            if (void 0 === i2)
              return o2.prototype.on.call(this, t2, e2);
            var a3 = function() {
              var o3;
              if ("mouseenter" === t2 || "mouseover" === t2) {
                var a4 = false;
                return { layer: e2, listener: i2, delegates: { mousemove: function(o4) {
                  var n4 = r3.getLayer(e2) ? r3.queryRenderedFeatures(o4.point, { layers: [e2] }) : [];
                  n4.length ? a4 || (a4 = true, i2.call(r3, new mo(t2, r3, o4.originalEvent, { features: n4 }))) : a4 = false;
                }, mouseout: function() {
                  a4 = false;
                } } };
              }
              if ("mouseleave" === t2 || "mouseout" === t2) {
                var n3 = false;
                return { layer: e2, listener: i2, delegates: { mousemove: function(o4) {
                  (r3.getLayer(e2) ? r3.queryRenderedFeatures(o4.point, { layers: [e2] }) : []).length ? n3 = true : n3 && (n3 = false, i2.call(r3, new mo(t2, r3, o4.originalEvent)));
                }, mouseout: function(e3) {
                  n3 && (n3 = false, i2.call(r3, new mo(t2, r3, e3.originalEvent)));
                } } };
              }
              return { layer: e2, listener: i2, delegates: (o3 = {}, o3[t2] = function(t3) {
                var o4 = r3.getLayer(e2) ? r3.queryRenderedFeatures(t3.point, { layers: [e2] }) : [];
                o4.length && (t3.features = o4, i2.call(r3, t3), delete t3.features);
              }, o3) };
            }();
            for (var n2 in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t2] = this._delegatedListeners[t2] || [], this._delegatedListeners[t2].push(a3), a3.delegates)
              this.on(n2, a3.delegates[n2]);
            return this;
          }, r2.prototype.off = function(t2, e2, i2) {
            if (void 0 === i2)
              return o2.prototype.off.call(this, t2, e2);
            if (this._delegatedListeners && this._delegatedListeners[t2])
              for (var r3 = this._delegatedListeners[t2], a3 = 0; a3 < r3.length; a3++) {
                var n2 = r3[a3];
                if (n2.layer === e2 && n2.listener === i2) {
                  for (var s2 in n2.delegates)
                    this.off(s2, n2.delegates[s2]);
                  return r3.splice(a3, 1), this;
                }
              }
            return this;
          }, r2.prototype.queryRenderedFeatures = function(e2, i2) {
            if (!this.style)
              return [];
            var o3;
            if (void 0 !== i2 || void 0 === e2 || e2 instanceof t.Point || Array.isArray(e2) || (i2 = e2, e2 = void 0), i2 = i2 || {}, (e2 = e2 || [[0, 0], [this.transform.width, this.transform.height]]) instanceof t.Point || "number" == typeof e2[0])
              o3 = [t.Point.convert(e2)];
            else {
              var r3 = t.Point.convert(e2[0]), a3 = t.Point.convert(e2[1]);
              o3 = [r3, new t.Point(a3.x, r3.y), a3, new t.Point(r3.x, a3.y), r3];
            }
            return this.style.queryRenderedFeatures(o3, i2, this.transform);
          }, r2.prototype.querySourceFeatures = function(t2, e2) {
            return this.style.querySourceFeatures(t2, e2);
          }, r2.prototype.setStyle = function(e2, i2) {
            return false !== (i2 = t.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e2 ? (this._diffStyle(e2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(e2, i2));
          }, r2.prototype._getUIString = function(t2) {
            var e2 = this._locale[t2];
            if (null == e2)
              throw new Error("Missing UI string '" + t2 + "'");
            return e2;
          }, r2.prototype._updateStyle = function(t2, e2) {
            return this.style && (this.style.setEventedParent(null), this.style._remove()), t2 ? (this.style = new Ne(this, e2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t2 ? this.style.loadURL(t2) : this.style.loadJSON(t2), this) : (delete this.style, this);
          }, r2.prototype._lazyInitEmptyStyle = function() {
            this.style || (this.style = new Ne(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }, r2.prototype._diffStyle = function(e2, i2) {
            var o3 = this;
            if ("string" == typeof e2) {
              var r3 = this._requestManager.normalizeStyleURL(e2), a3 = this._requestManager.transformRequest(r3, t.ResourceType.Style);
              t.getJSON(a3, function(e3, r4) {
                e3 ? o3.fire(new t.ErrorEvent(e3)) : r4 && o3._updateDiff(r4, i2);
              });
            } else
              "object" == typeof e2 && this._updateDiff(e2, i2);
          }, r2.prototype._updateDiff = function(e2, i2) {
            try {
              this.style.setState(e2) && this._update(true);
            } catch (o3) {
              t.warnOnce("Unable to perform style diff: " + (o3.message || o3.error || o3) + ".  Rebuilding the style from scratch."), this._updateStyle(e2, i2);
            }
          }, r2.prototype.getStyle = function() {
            if (this.style)
              return this.style.serialize();
          }, r2.prototype.isStyleLoaded = function() {
            return this.style ? this.style.loaded() : t.warnOnce("There is no style added to the map.");
          }, r2.prototype.addSource = function(t2, e2) {
            return this._lazyInitEmptyStyle(), this.style.addSource(t2, e2), this._update(true);
          }, r2.prototype.isSourceLoaded = function(e2) {
            var i2 = this.style && this.style.sourceCaches[e2];
            if (void 0 !== i2)
              return i2.loaded();
            this.fire(new t.ErrorEvent(new Error("There is no source with ID '" + e2 + "'")));
          }, r2.prototype.areTilesLoaded = function() {
            var t2 = this.style && this.style.sourceCaches;
            for (var e2 in t2) {
              var i2 = t2[e2]._tiles;
              for (var o3 in i2) {
                var r3 = i2[o3];
                if ("loaded" !== r3.state && "errored" !== r3.state)
                  return false;
              }
            }
            return true;
          }, r2.prototype.addSourceType = function(t2, e2, i2) {
            return this._lazyInitEmptyStyle(), this.style.addSourceType(t2, e2, i2);
          }, r2.prototype.removeSource = function(t2) {
            return this.style.removeSource(t2), this._update(true);
          }, r2.prototype.getSource = function(t2) {
            return this.style.getSource(t2);
          }, r2.prototype.addImage = function(e2, i2, o3) {
            void 0 === o3 && (o3 = {});
            var r3 = o3.pixelRatio;
            void 0 === r3 && (r3 = 1);
            var a3 = o3.sdf;
            void 0 === a3 && (a3 = false);
            var n2 = o3.stretchX, s2 = o3.stretchY, l2 = o3.content;
            this._lazyInitEmptyStyle();
            if (i2 instanceof Bo || Fo && i2 instanceof Fo) {
              var c2 = t.browser.getImageData(i2), u2 = c2.width, h2 = c2.height, p2 = c2.data;
              this.style.addImage(e2, { data: new t.RGBAImage({ width: u2, height: h2 }, p2), pixelRatio: r3, stretchX: n2, stretchY: s2, content: l2, sdf: a3, version: 0 });
            } else {
              if (void 0 === i2.width || void 0 === i2.height)
                return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              var d2 = i2.width, _2 = i2.height, f2 = i2.data, m2 = i2;
              this.style.addImage(e2, { data: new t.RGBAImage({ width: d2, height: _2 }, new Uint8Array(f2)), pixelRatio: r3, stretchX: n2, stretchY: s2, content: l2, sdf: a3, version: 0, userImage: m2 }), m2.onAdd && m2.onAdd(this, e2);
            }
          }, r2.prototype.updateImage = function(e2, i2) {
            var o3 = this.style.getImage(e2);
            if (!o3)
              return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            var r3 = i2 instanceof Bo || Fo && i2 instanceof Fo ? t.browser.getImageData(i2) : i2, a3 = r3.width, n2 = r3.height, s2 = r3.data;
            if (void 0 === a3 || void 0 === n2)
              return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (a3 !== o3.data.width || n2 !== o3.data.height)
              return this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            var l2 = !(i2 instanceof Bo || Fo && i2 instanceof Fo);
            o3.data.replace(s2, l2), this.style.updateImage(e2, o3);
          }, r2.prototype.hasImage = function(e2) {
            return e2 ? !!this.style.getImage(e2) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))), false);
          }, r2.prototype.removeImage = function(t2) {
            this.style.removeImage(t2);
          }, r2.prototype.loadImage = function(e2, i2) {
            t.getImage(this._requestManager.transformRequest(e2, t.ResourceType.Image), i2);
          }, r2.prototype.listImages = function() {
            return this.style.listImages();
          }, r2.prototype.addLayer = function(t2, e2) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(t2, e2), this._update(true);
          }, r2.prototype.moveLayer = function(t2, e2) {
            return this.style.moveLayer(t2, e2), this._update(true);
          }, r2.prototype.removeLayer = function(t2) {
            return this.style.removeLayer(t2), this._update(true);
          }, r2.prototype.getLayer = function(t2) {
            return this.style.getLayer(t2);
          }, r2.prototype.setLayerZoomRange = function(t2, e2, i2) {
            return this.style.setLayerZoomRange(t2, e2, i2), this._update(true);
          }, r2.prototype.setFilter = function(t2, e2, i2) {
            return void 0 === i2 && (i2 = {}), this.style.setFilter(t2, e2, i2), this._update(true);
          }, r2.prototype.getFilter = function(t2) {
            return this.style.getFilter(t2);
          }, r2.prototype.setPaintProperty = function(t2, e2, i2, o3) {
            return void 0 === o3 && (o3 = {}), this.style.setPaintProperty(t2, e2, i2, o3), this._update(true);
          }, r2.prototype.getPaintProperty = function(t2, e2) {
            return this.style.getPaintProperty(t2, e2);
          }, r2.prototype.setLayoutProperty = function(t2, e2, i2, o3) {
            return void 0 === o3 && (o3 = {}), this.style.setLayoutProperty(t2, e2, i2, o3), this._update(true);
          }, r2.prototype.getLayoutProperty = function(t2, e2) {
            return this.style.getLayoutProperty(t2, e2);
          }, r2.prototype.setLight = function(t2, e2) {
            return void 0 === e2 && (e2 = {}), this._lazyInitEmptyStyle(), this.style.setLight(t2, e2), this._update(true);
          }, r2.prototype.getLight = function() {
            return this.style.getLight();
          }, r2.prototype.setFeatureState = function(t2, e2) {
            return this.style.setFeatureState(t2, e2), this._update();
          }, r2.prototype.removeFeatureState = function(t2, e2) {
            return this.style.removeFeatureState(t2, e2), this._update();
          }, r2.prototype.getFeatureState = function(t2) {
            return this.style.getFeatureState(t2);
          }, r2.prototype.getContainer = function() {
            return this._container;
          }, r2.prototype.getCanvasContainer = function() {
            return this._canvasContainer;
          }, r2.prototype.getCanvas = function() {
            return this._canvas;
          }, r2.prototype._containerDimensions = function() {
            var t2 = 0, e2 = 0;
            return this._container && (t2 = this._container.clientWidth || 400, e2 = this._container.clientHeight || 300), [t2, e2];
          }, r2.prototype._detectMissingCSS = function() {
            "rgb(250, 128, 114)" !== t.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && t.warnOnce("This page appears to be missing CSS declarations for Goong GL JS, which may cause the map to display incorrectly. Please ensure your page includes goong-js.css, as described in https://docs.goong.io/javascript/.");
          }, r2.prototype._setupContainer = function() {
            var t2 = this._container;
            t2.classList.add("mapboxgl-map"), (this._missingCSSCanary = i.create("div", "mapboxgl-canary", t2)).style.visibility = "hidden", this._detectMissingCSS();
            var e2 = this._canvasContainer = i.create("div", "mapboxgl-canvas-container", t2);
            this._interactive && e2.classList.add("mapboxgl-interactive"), this._canvas = i.create("canvas", "mapboxgl-canvas", e2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
            var o3 = this._containerDimensions();
            this._resizeCanvas(o3[0], o3[1]);
            var r3 = this._controlContainer = i.create("div", "mapboxgl-control-container", t2), a3 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(function(t3) {
              a3[t3] = i.create("div", "mapboxgl-ctrl-" + t3, r3);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }, r2.prototype._resizeCanvas = function(e2, i2) {
            var o3 = t.browser.devicePixelRatio || 1;
            this._canvas.width = o3 * e2, this._canvas.height = o3 * i2, this._canvas.style.width = e2 + "px", this._canvas.style.height = i2 + "px";
          }, r2.prototype._setupPainter = function() {
            var i2 = t.extend({}, e.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o3 = this._canvas.getContext("webgl", i2) || this._canvas.getContext("experimental-webgl", i2);
            o3 ? (this.painter = new lo(o3, this.transform), t.webpSupported.testSupport(o3)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));
          }, r2.prototype._contextLost = function(e2) {
            e2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event("webglcontextlost", { originalEvent: e2 }));
          }, r2.prototype._contextRestored = function(e2) {
            this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event("webglcontextrestored", { originalEvent: e2 }));
          }, r2.prototype._onMapScroll = function(t2) {
            if (t2.target === this._container)
              return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }, r2.prototype.loaded = function() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }, r2.prototype._update = function(t2) {
            return this.style ? (this._styleDirty = this._styleDirty || t2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }, r2.prototype._requestRenderFrame = function(t2) {
            return this._update(), this._renderTaskQueue.add(t2);
          }, r2.prototype._cancelRenderFrame = function(t2) {
            this._renderTaskQueue.remove(t2);
          }, r2.prototype._render = function() {
            var e2, i2 = this, o3 = 0, r3 = this.painter.context.extTimerQuery;
            this.listens("gpu-timing-frame") && (e2 = r3.createQueryEXT(), r3.beginQueryEXT(r3.TIME_ELAPSED_EXT, e2), o3 = t.browser.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run();
            var a3 = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              var n2 = this.transform.zoom, s2 = t.browser.now();
              this.style.zoomHistory.update(n2, s2);
              var l2 = new t.EvaluationParameters(n2, { now: s2, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), c2 = l2.crossFadingFactor();
              1 === c2 && c2 === this._crossFadingFactor || (a3 = true, this._crossFadingFactor = c2), this.style.update(l2);
            }
            if (this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), gpuTiming: !!this.listens("gpu-timing-layer"), fadeDuration: this._fadeDuration }), this.fire(new t.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new t.Event("load"))), this.style && (this.style.hasTransitions() || a3) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
              var u2 = t.browser.now() - o3;
              r3.endQueryEXT(r3.TIME_ELAPSED_EXT, e2), setTimeout(function() {
                var o4 = r3.getQueryObjectEXT(e2, r3.QUERY_RESULT_EXT) / 1e6;
                r3.deleteQueryEXT(e2), i2.fire(new t.Event("gpu-timing-frame", { cpuTime: u2, gpuTime: o4 }));
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              var h2 = this.painter.collectGpuTimers();
              setTimeout(function() {
                var e3 = i2.painter.queryGpuTimers(h2);
                i2.fire(new t.Event("gpu-timing-layer", { layerTimes: e3 }));
              }, 50);
            }
            return this._sourcesDirty || this._styleDirty || this._placementDirty || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && (this._fullyLoaded || (this._fullyLoaded = true), this.fire(new t.Event("idle"))), this;
          }, r2.prototype.remove = function() {
            this._hash && this._hash.remove();
            for (var e2 = 0, i2 = this._controls; e2 < i2.length; e2 += 1) {
              i2[e2].onRemove(this);
            }
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.setStyle(null), void 0 !== t.window && (t.window.removeEventListener("resize", this._onWindowResize, false), t.window.removeEventListener("online", this._onWindowOnline, false));
            var o3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            o3 && o3.loseContext(), Zo(this._canvasContainer), Zo(this._controlContainer), Zo(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), this.fire(new t.Event("remove"));
          }, r2.prototype.triggerRepaint = function() {
            var e2 = this;
            this.style && !this._frame && (this._frame = t.browser.frame(function(t2) {
              e2._frame = null, e2._render();
            }));
          }, r2.prototype._onWindowOnline = function() {
            this._update();
          }, r2.prototype._onWindowResize = function(t2) {
            this._trackResize && this.resize({ originalEvent: t2 })._update();
          }, a2.showTileBoundaries.get = function() {
            return !!this._showTileBoundaries;
          }, a2.showTileBoundaries.set = function(t2) {
            this._showTileBoundaries !== t2 && (this._showTileBoundaries = t2, this._update());
          }, a2.showCollisionBoxes.get = function() {
            return !!this._showCollisionBoxes;
          }, a2.showCollisionBoxes.set = function(t2) {
            this._showCollisionBoxes !== t2 && (this._showCollisionBoxes = t2, t2 ? this.style._generateCollisionBoxes() : this._update());
          }, a2.showOverdrawInspector.get = function() {
            return !!this._showOverdrawInspector;
          }, a2.showOverdrawInspector.set = function(t2) {
            this._showOverdrawInspector !== t2 && (this._showOverdrawInspector = t2, this._update());
          }, a2.repaint.get = function() {
            return !!this._repaint;
          }, a2.repaint.set = function(t2) {
            this._repaint !== t2 && (this._repaint = t2, this.triggerRepaint());
          }, a2.vertices.get = function() {
            return !!this._vertices;
          }, a2.vertices.set = function(t2) {
            this._vertices = t2, this._update();
          }, r2.prototype._setCacheLimits = function(e2, i2) {
            t.setCacheLimits(e2, i2);
          }, a2.version.get = function() {
            return t.version;
          }, Object.defineProperties(r2.prototype, a2), r2;
        }(Lo);
        function Zo(t2) {
          t2.parentNode && t2.parentNode.removeChild(t2);
        }
        var qo = { showCompass: true, showZoom: true, visualizePitch: false }, jo = function(e2) {
          var o2 = this;
          this.options = t.extend({}, qo, e2), this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", function(t2) {
            return t2.preventDefault();
          }), this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", function(t2) {
            return o2._map.zoomIn({}, { originalEvent: t2 });
          }), i.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", true), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", function(t2) {
            return o2._map.zoomOut({}, { originalEvent: t2 });
          }), i.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", true)), this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", function(t2) {
            o2.options.visualizePitch ? o2._map.resetNorthPitch({}, { originalEvent: t2 }) : o2._map.resetNorth({}, { originalEvent: t2 });
          }), this._compassIcon = i.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", true));
        };
        function Vo(e2, i2, o2) {
          if (e2 = new t.LngLat(e2.lng, e2.lat), i2) {
            var r2 = new t.LngLat(e2.lng - 360, e2.lat), a2 = new t.LngLat(e2.lng + 360, e2.lat), n2 = o2.locationPoint(e2).distSqr(i2);
            o2.locationPoint(r2).distSqr(i2) < n2 ? e2 = r2 : o2.locationPoint(a2).distSqr(i2) < n2 && (e2 = a2);
          }
          for (; Math.abs(e2.lng - o2.center.lng) > 180; ) {
            var s2 = o2.locationPoint(e2);
            if (s2.x >= 0 && s2.y >= 0 && s2.x <= o2.width && s2.y <= o2.height)
              break;
            e2.lng > o2.center.lng ? e2.lng -= 360 : e2.lng += 360;
          }
          return e2;
        }
        jo.prototype._updateZoomButtons = function() {
          var t2 = this._map.getZoom();
          this._zoomInButton.disabled = t2 === this._map.getMaxZoom(), this._zoomOutButton.disabled = t2 === this._map.getMinZoom();
        }, jo.prototype._rotateCompassArrow = function() {
          var t2 = this.options.visualizePitch ? "scale(" + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5) + ") rotateX(" + this._map.transform.pitch + "deg) rotateZ(" + this._map.transform.angle * (180 / Math.PI) + "deg)" : "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)";
          this._compassIcon.style.transform = t2;
        }, jo.prototype.onAdd = function(t2) {
          return this._map = t2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new wo(t2, { button: "left", element: this._compass }), i.addEventListener(this._compass, "mousedown", this._handler.onMouseDown), i.addEventListener(this._compass, "touchstart", this._handler.onMouseDown, { passive: false }), this._handler.enable()), this._container;
        }, jo.prototype.onRemove = function() {
          i.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), i.removeEventListener(this._compass, "mousedown", this._handler.onMouseDown), i.removeEventListener(this._compass, "touchstart", this._handler.onMouseDown, { passive: false }), this._handler.disable(), delete this._handler), delete this._map;
        }, jo.prototype._createButton = function(t2, e2) {
          var o2 = i.create("button", t2, this._container);
          return o2.type = "button", o2.addEventListener("click", e2), o2;
        }, jo.prototype._setButtonTitle = function(t2, e2) {
          var i2 = this._map._getUIString("NavigationControl." + e2);
          t2.title = i2, t2.setAttribute("aria-label", i2);
        };
        var Go = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function Wo(t2, e2, i2) {
          var o2 = t2.classList;
          for (var r2 in Go)
            o2.remove("mapboxgl-" + i2 + "-anchor-" + r2);
          o2.add("mapboxgl-" + i2 + "-anchor-" + e2);
        }
        var Xo, Ho = function(e2) {
          function o2(o3, r2) {
            if (e2.call(this), (o3 instanceof t.window.HTMLElement || r2) && (o3 = t.extend({ element: o3 }, r2)), t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = o3 && o3.anchor || "center", this._color = o3 && o3.color || "#3FB1CE", this._scale = o3 && o3.scale || 1, this._draggable = o3 && o3.draggable || false, this._state = "inactive", this._rotation = o3 && o3.rotation || 0, this._rotationAlignment = o3 && o3.rotationAlignment || "auto", this._pitchAlignment = o3 && o3.pitchAlignment && "auto" !== o3.pitchAlignment ? o3.pitchAlignment : this._rotationAlignment, o3 && o3.element)
              this._element = o3.element, this._offset = t.Point.convert(o3 && o3.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = i.create("div"), this._element.setAttribute("aria-label", "Map marker");
              var a2 = i.createNS("http://www.w3.org/2000/svg", "svg");
              a2.setAttributeNS(null, "display", "block"), a2.setAttributeNS(null, "height", "41px"), a2.setAttributeNS(null, "width", "27px"), a2.setAttributeNS(null, "viewBox", "0 0 27 41");
              var n2 = i.createNS("http://www.w3.org/2000/svg", "g");
              n2.setAttributeNS(null, "stroke", "none"), n2.setAttributeNS(null, "stroke-width", "1"), n2.setAttributeNS(null, "fill", "none"), n2.setAttributeNS(null, "fill-rule", "evenodd");
              var s2 = i.createNS("http://www.w3.org/2000/svg", "g");
              s2.setAttributeNS(null, "fill-rule", "nonzero");
              var l2 = i.createNS("http://www.w3.org/2000/svg", "g");
              l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
              for (var c2 = 0, u2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; c2 < u2.length; c2 += 1) {
                var h2 = u2[c2], p2 = i.createNS("http://www.w3.org/2000/svg", "ellipse");
                p2.setAttributeNS(null, "opacity", "0.04"), p2.setAttributeNS(null, "cx", "10.5"), p2.setAttributeNS(null, "cy", "5.80029008"), p2.setAttributeNS(null, "rx", h2.rx), p2.setAttributeNS(null, "ry", h2.ry), l2.appendChild(p2);
              }
              var d2 = i.createNS("http://www.w3.org/2000/svg", "g");
              d2.setAttributeNS(null, "fill", this._color);
              var _2 = i.createNS("http://www.w3.org/2000/svg", "path");
              _2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), d2.appendChild(_2);
              var f2 = i.createNS("http://www.w3.org/2000/svg", "g");
              f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "fill", "#000000");
              var m2 = i.createNS("http://www.w3.org/2000/svg", "path");
              m2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), f2.appendChild(m2);
              var g2 = i.createNS("http://www.w3.org/2000/svg", "g");
              g2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), g2.setAttributeNS(null, "fill", "#FFFFFF");
              var v2 = i.createNS("http://www.w3.org/2000/svg", "g");
              v2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              var y2 = i.createNS("http://www.w3.org/2000/svg", "circle");
              y2.setAttributeNS(null, "fill", "#000000"), y2.setAttributeNS(null, "opacity", "0.25"), y2.setAttributeNS(null, "cx", "5.5"), y2.setAttributeNS(null, "cy", "5.5"), y2.setAttributeNS(null, "r", "5.4999962");
              var x2 = i.createNS("http://www.w3.org/2000/svg", "circle");
              x2.setAttributeNS(null, "fill", "#FFFFFF"), x2.setAttributeNS(null, "cx", "5.5"), x2.setAttributeNS(null, "cy", "5.5"), x2.setAttributeNS(null, "r", "5.4999962"), v2.appendChild(y2), v2.appendChild(x2), s2.appendChild(l2), s2.appendChild(d2), s2.appendChild(f2), s2.appendChild(g2), s2.appendChild(v2), a2.appendChild(s2), a2.setAttributeNS(null, "height", 41 * this._scale + "px"), a2.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(a2), this._offset = t.Point.convert(o3 && o3.offset || [0, -14]);
            }
            this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", function(t2) {
              t2.preventDefault();
            }), this._element.addEventListener("mousedown", function(t2) {
              t2.preventDefault();
            }), Wo(this._element, this._anchor, "marker"), this._popup = null;
          }
          return e2 && (o2.__proto__ = e2), o2.prototype = Object.create(e2 && e2.prototype), o2.prototype.constructor = o2, o2.prototype.addTo = function(t2) {
            return this.remove(), this._map = t2, t2.getCanvasContainer().appendChild(this._element), t2.on("move", this._update), t2.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }, o2.prototype.remove = function() {
            return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), i.remove(this._element), this._popup && this._popup.remove(), this;
          }, o2.prototype.getLngLat = function() {
            return this._lngLat;
          }, o2.prototype.setLngLat = function(e3) {
            return this._lngLat = t.LngLat.convert(e3), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }, o2.prototype.getElement = function() {
            return this._element;
          }, o2.prototype.setPopup = function(t2) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t2) {
              if (!("offset" in t2.options)) {
                var e3 = Math.sqrt(Math.pow(13.5, 2) / 2);
                t2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [e3, -1 * (24.6 + e3)], "bottom-right": [-e3, -1 * (24.6 + e3)], left: [13.5, -24.6], right: [-13.5, -24.6] } : this._offset;
              }
              this._popup = t2, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }, o2.prototype._onKeyPress = function(t2) {
            var e3 = t2.code, i2 = t2.charCode || t2.keyCode;
            "Space" !== e3 && "Enter" !== e3 && 32 !== i2 && 13 !== i2 || this.togglePopup();
          }, o2.prototype._onMapClick = function(t2) {
            var e3 = t2.originalEvent.target, i2 = this._element;
            this._popup && (e3 === i2 || i2.contains(e3)) && this.togglePopup();
          }, o2.prototype.getPopup = function() {
            return this._popup;
          }, o2.prototype.togglePopup = function() {
            var t2 = this._popup;
            return t2 ? (t2.isOpen() ? t2.remove() : t2.addTo(this._map), this) : this;
          }, o2.prototype._update = function(t2) {
            if (this._map) {
              this._map.transform.renderWorldCopies && (this._lngLat = Vo(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
              var e3 = "";
              "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? e3 = "rotateZ(" + this._rotation + "deg)" : "map" === this._rotationAlignment && (e3 = "rotateZ(" + (this._rotation - this._map.getBearing()) + "deg)");
              var o3 = "";
              "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? o3 = "rotateX(0deg)" : "map" === this._pitchAlignment && (o3 = "rotateX(" + this._map.getPitch() + "deg)"), t2 && "moveend" !== t2.type || (this._pos = this._pos.round()), i.setTransform(this._element, Go[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px) " + o3 + " " + e3);
            }
          }, o2.prototype.getOffset = function() {
            return this._offset;
          }, o2.prototype.setOffset = function(e3) {
            return this._offset = t.Point.convert(e3), this._update(), this;
          }, o2.prototype._onMove = function(e3) {
            this._pos = e3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.Event("dragstart"))), this.fire(new t.Event("drag"));
          }, o2.prototype._onUp = function() {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.Event("dragend")), this._state = "inactive";
          }, o2.prototype._addDragHandler = function(t2) {
            this._element.contains(t2.originalEvent.target) && (t2.preventDefault(), this._positionDelta = t2.point.sub(this._pos).add(this._offset), this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, o2.prototype.setDraggable = function(t2) {
            return this._draggable = !!t2, this._map && (t2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }, o2.prototype.isDraggable = function() {
            return this._draggable;
          }, o2.prototype.setRotation = function(t2) {
            return this._rotation = t2 || 0, this._update(), this;
          }, o2.prototype.getRotation = function() {
            return this._rotation;
          }, o2.prototype.setRotationAlignment = function(t2) {
            return this._rotationAlignment = t2 || "auto", this._update(), this;
          }, o2.prototype.getRotationAlignment = function() {
            return this._rotationAlignment;
          }, o2.prototype.setPitchAlignment = function(t2) {
            return this._pitchAlignment = t2 && "auto" !== t2 ? t2 : this._rotationAlignment, this._update(), this;
          }, o2.prototype.getPitchAlignment = function() {
            return this._pitchAlignment;
          }, o2;
        }(t.Evented), Ko = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showUserLocation: true };
        var Yo = function(e2) {
          function o2(i2) {
            e2.call(this), this.options = t.extend({}, Ko, i2), t.bindAll(["_onSuccess", "_onError", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);
          }
          return e2 && (o2.__proto__ = e2), o2.prototype = Object.create(e2 && e2.prototype), o2.prototype.constructor = o2, o2.prototype.onAdd = function(e3) {
            var o3;
            return this._map = e3, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), o3 = this._setupUI, void 0 !== Xo ? o3(Xo) : void 0 !== t.window.navigator.permissions ? t.window.navigator.permissions.query({ name: "geolocation" }).then(function(t2) {
              Xo = "denied" !== t2.state, o3(Xo);
            }) : (Xo = !!t.window.navigator.geolocation, o3(Xo)), this._container;
          }, o2.prototype.onRemove = function() {
            void 0 !== this._geolocationWatchID && (t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), i.remove(this._container), this._map = void 0;
          }, o2.prototype._isOutOfMapMaxBounds = function(t2) {
            var e3 = this._map.getMaxBounds(), i2 = t2.coords;
            return e3 && (i2.longitude < e3.getWest() || i2.longitude > e3.getEast() || i2.latitude < e3.getSouth() || i2.latitude > e3.getNorth());
          }, o2.prototype._setErrorState = function() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
            }
          }, o2.prototype._onSuccess = function(e3) {
            if (this._isOutOfMapMaxBounds(e3))
              return this._setErrorState(), this.fire(new t.Event("outofmaxbounds", e3)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = e3, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e3), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("geolocate", e3)), this._finish();
          }, o2.prototype._updateCamera = function(e3) {
            var i2 = new t.LngLat(e3.coords.longitude, e3.coords.latitude), o3 = e3.coords.accuracy, r2 = this._map.getBearing(), a2 = t.extend({ bearing: r2 }, this.options.fitBoundsOptions);
            this._map.fitBounds(i2.toBounds(o3), a2, { geolocateSource: true });
          }, o2.prototype._updateMarker = function(t2) {
            t2 ? this._userLocationDotMarker.setLngLat([t2.coords.longitude, t2.coords.latitude]).addTo(this._map) : this._userLocationDotMarker.remove();
          }, o2.prototype._onError = function(e3) {
            if (this.options.trackUserLocation)
              if (1 === e3.code) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                var i2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = i2, this._geolocateButton.setAttribute("aria-label", i2), void 0 !== this._geolocationWatchID && this._clearWatch();
              } else
                this._setErrorState();
            "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("error", e3)), this._finish();
          }, o2.prototype._finish = function() {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, o2.prototype._setupUI = function(e3) {
            var o3 = this;
            if (this._container.addEventListener("contextmenu", function(t2) {
              return t2.preventDefault();
            }), this._geolocateButton = i.create("button", "mapboxgl-ctrl-geolocate", this._container), i.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", true), this._geolocateButton.type = "button", false === e3) {
              t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
              var r2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = true, this._geolocateButton.title = r2, this._geolocateButton.setAttribute("aria-label", r2);
            } else {
              var a2 = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.title = a2, this._geolocateButton.setAttribute("aria-label", a2);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = i.create("div", "mapboxgl-user-location-dot"), this._userLocationDotMarker = new Ho(this._dotElement), this.options.trackUserLocation && (this._watchState = "OFF")), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", function(e4) {
              var i2 = e4.originalEvent && "resize" === e4.originalEvent.type;
              e4.geolocateSource || "ACTIVE_LOCK" !== o3._watchState || i2 || (o3._watchState = "BACKGROUND", o3._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), o3._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), o3.fire(new t.Event("trackuserlocationend")));
            });
          }, o2.prototype.trigger = function() {
            if (!this._setup)
              return t.warnOnce("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new t.Event("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new t.Event("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event("trackuserlocationstart"));
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "BACKGROUND":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  break;
                case "BACKGROUND_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
              }
              "OFF" === this._watchState && void 0 !== this._geolocationWatchID ? this._clearWatch() : void 0 === this._geolocationWatchID && (this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._geolocationWatchID = t.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, this.options.positionOptions));
            } else
              t.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }, o2.prototype._clearWatch = function() {
            t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }, o2;
        }(t.Evented), Jo = { maxWidth: 100, unit: "metric" }, Qo = function(e2) {
          this.options = t.extend({}, Jo, e2), t.bindAll(["_onMove", "setUnit"], this);
        };
        function $o(t2, e2, i2) {
          var o2, r2, a2, n2, s2, l2, c2 = i2 && i2.maxWidth || 100, u2 = t2._container.clientHeight / 2, h2 = (o2 = t2.unproject([0, u2]), r2 = t2.unproject([c2, u2]), a2 = Math.PI / 180, n2 = o2.lat * a2, s2 = r2.lat * a2, l2 = Math.sin(n2) * Math.sin(s2) + Math.cos(n2) * Math.cos(s2) * Math.cos((r2.lng - o2.lng) * a2), 6371e3 * Math.acos(Math.min(l2, 1)));
          if (i2 && "imperial" === i2.unit) {
            var p2 = 3.2808 * h2;
            if (p2 > 5280)
              tr(e2, c2, p2 / 5280, t2._getUIString("ScaleControl.Miles"));
            else
              tr(e2, c2, p2, t2._getUIString("ScaleControl.Feet"));
          } else if (i2 && "nautical" === i2.unit) {
            tr(e2, c2, h2 / 1852, t2._getUIString("ScaleControl.NauticalMiles"));
          } else
            h2 >= 1e3 ? tr(e2, c2, h2 / 1e3, t2._getUIString("ScaleControl.Kilometers")) : tr(e2, c2, h2, t2._getUIString("ScaleControl.Meters"));
        }
        function tr(t2, e2, i2, o2) {
          var r2, a2, n2, s2 = (r2 = i2, a2 = Math.pow(10, ("" + Math.floor(r2)).length - 1), n2 = (n2 = r2 / a2) >= 10 ? 10 : n2 >= 5 ? 5 : n2 >= 3 ? 3 : n2 >= 2 ? 2 : n2 >= 1 ? 1 : function(t3) {
            var e3 = Math.pow(10, Math.ceil(-Math.log(t3) / Math.LN10));
            return Math.round(t3 * e3) / e3;
          }(n2), a2 * n2), l2 = s2 / i2;
          t2.style.width = e2 * l2 + "px", t2.innerHTML = s2 + o2;
        }
        Qo.prototype.getDefaultPosition = function() {
          return "bottom-left";
        }, Qo.prototype._onMove = function() {
          $o(this._map, this._container, this.options);
        }, Qo.prototype.onAdd = function(t2) {
          return this._map = t2, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", t2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }, Qo.prototype.onRemove = function() {
          i.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }, Qo.prototype.setUnit = function(t2) {
          this.options.unit = t2, $o(this._map, this._container, this.options);
        };
        var er = function(e2) {
          this._fullscreen = false, e2 && e2.container && (e2.container instanceof t.window.HTMLElement ? this._container = e2.container : t.warnOnce("Full screen control 'container' must be a DOM element.")), t.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in t.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in t.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in t.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in t.window.document && (this._fullscreenchange = "MSFullscreenChange");
        };
        er.prototype.onAdd = function(e2) {
          return this._map = e2, this._container || (this._container = this._map.getContainer()), this._controlContainer = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
        }, er.prototype.onRemove = function() {
          i.remove(this._controlContainer), this._map = null, t.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }, er.prototype._checkFullscreenSupport = function() {
          return !!(t.window.document.fullscreenEnabled || t.window.document.mozFullScreenEnabled || t.window.document.msFullscreenEnabled || t.window.document.webkitFullscreenEnabled);
        }, er.prototype._setupUI = function() {
          var e2 = this._fullscreenButton = i.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          i.create("span", "mapboxgl-ctrl-icon", e2).setAttribute("aria-hidden", true), e2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), t.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
        }, er.prototype._updateTitle = function() {
          var t2 = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", t2), this._fullscreenButton.title = t2;
        }, er.prototype._getTitle = function() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }, er.prototype._isFullscreen = function() {
          return this._fullscreen;
        }, er.prototype._changeIcon = function() {
          (t.window.document.fullscreenElement || t.window.document.mozFullScreenElement || t.window.document.webkitFullscreenElement || t.window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }, er.prototype._onClickFullscreen = function() {
          this._isFullscreen() ? t.window.document.exitFullscreen ? t.window.document.exitFullscreen() : t.window.document.mozCancelFullScreen ? t.window.document.mozCancelFullScreen() : t.window.document.msExitFullscreen ? t.window.document.msExitFullscreen() : t.window.document.webkitCancelFullScreen && t.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        };
        var ir = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, or = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "), rr = function(e2) {
          function o2(i2) {
            e2.call(this), this.options = t.extend(Object.create(ir), i2), t.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
          }
          return e2 && (o2.__proto__ = e2), o2.prototype = Object.create(e2 && e2.prototype), o2.prototype.constructor = o2, o2.prototype.addTo = function(e3) {
            return this._map && this.remove(), this._map = e3, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.Event("open")), this;
          }, o2.prototype.isOpen = function() {
            return !!this._map;
          }, o2.prototype.remove = function() {
            return this._content && i.remove(this._content), this._container && (i.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.Event("close")), this;
          }, o2.prototype.getLngLat = function() {
            return this._lngLat;
          }, o2.prototype.setLngLat = function(e3) {
            return this._lngLat = t.LngLat.convert(e3), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
          }, o2.prototype.trackPointer = function() {
            return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
          }, o2.prototype.getElement = function() {
            return this._container;
          }, o2.prototype.setText = function(e3) {
            return this.setDOMContent(t.window.document.createTextNode(e3));
          }, o2.prototype.setHTML = function(e3) {
            var i2, o3 = t.window.document.createDocumentFragment(), r2 = t.window.document.createElement("body");
            for (r2.innerHTML = e3; i2 = r2.firstChild; )
              o3.appendChild(i2);
            return this.setDOMContent(o3);
          }, o2.prototype.getMaxWidth = function() {
            return this._container && this._container.style.maxWidth;
          }, o2.prototype.setMaxWidth = function(t2) {
            return this.options.maxWidth = t2, this._update(), this;
          }, o2.prototype.setDOMContent = function(t2) {
            return this._createContent(), this._content.appendChild(t2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }, o2.prototype.addClassName = function(t2) {
            this._container && this._container.classList.add(t2);
          }, o2.prototype.removeClassName = function(t2) {
            this._container && this._container.classList.remove(t2);
          }, o2.prototype.setOffset = function(t2) {
            return this.options.offset = t2, this._update(), this;
          }, o2.prototype.toggleClassName = function(t2) {
            if (this._container)
              return this._container.classList.toggle(t2);
          }, o2.prototype._createContent = function() {
            this._content && i.remove(this._content), this._content = i.create("div", "mapboxgl-popup-content", this._container);
          }, o2.prototype._createCloseButton = function() {
            this.options.closeButton && (this._closeButton = i.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }, o2.prototype._onMouseUp = function(t2) {
            this._update(t2.point);
          }, o2.prototype._onMouseMove = function(t2) {
            this._update(t2.point);
          }, o2.prototype._onDrag = function(t2) {
            this._update(t2.point);
          }, o2.prototype._update = function(e3) {
            var o3 = this, r2 = this._lngLat || this._trackPointer;
            if (this._map && r2 && this._content && (this._container || (this._container = i.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = i.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach(function(t2) {
              return o3._container.classList.add(t2);
            }), this._trackPointer && this._container.classList.add("mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Vo(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || e3)) {
              var a2 = this._pos = this._trackPointer && e3 ? e3 : this._map.project(this._lngLat), n2 = this.options.anchor, s2 = function e4(i2) {
                if (i2) {
                  if ("number" == typeof i2) {
                    var o4 = Math.round(Math.sqrt(0.5 * Math.pow(i2, 2)));
                    return { center: new t.Point(0, 0), top: new t.Point(0, i2), "top-left": new t.Point(o4, o4), "top-right": new t.Point(-o4, o4), bottom: new t.Point(0, -i2), "bottom-left": new t.Point(o4, -o4), "bottom-right": new t.Point(-o4, -o4), left: new t.Point(i2, 0), right: new t.Point(-i2, 0) };
                  }
                  if (i2 instanceof t.Point || Array.isArray(i2)) {
                    var r3 = t.Point.convert(i2);
                    return { center: r3, top: r3, "top-left": r3, "top-right": r3, bottom: r3, "bottom-left": r3, "bottom-right": r3, left: r3, right: r3 };
                  }
                  return { center: t.Point.convert(i2.center || [0, 0]), top: t.Point.convert(i2.top || [0, 0]), "top-left": t.Point.convert(i2["top-left"] || [0, 0]), "top-right": t.Point.convert(i2["top-right"] || [0, 0]), bottom: t.Point.convert(i2.bottom || [0, 0]), "bottom-left": t.Point.convert(i2["bottom-left"] || [0, 0]), "bottom-right": t.Point.convert(i2["bottom-right"] || [0, 0]), left: t.Point.convert(i2.left || [0, 0]), right: t.Point.convert(i2.right || [0, 0]) };
                }
                return e4(new t.Point(0, 0));
              }(this.options.offset);
              if (!n2) {
                var l2, c2 = this._container.offsetWidth, u2 = this._container.offsetHeight;
                l2 = a2.y + s2.bottom.y < u2 ? ["top"] : a2.y > this._map.transform.height - u2 ? ["bottom"] : [], a2.x < c2 / 2 ? l2.push("left") : a2.x > this._map.transform.width - c2 / 2 && l2.push("right"), n2 = 0 === l2.length ? "bottom" : l2.join("-");
              }
              var h2 = a2.add(s2[n2]).round();
              i.setTransform(this._container, Go[n2] + " translate(" + h2.x + "px," + h2.y + "px)"), Wo(this._container, n2, "popup");
            }
          }, o2.prototype._focusFirstElement = function() {
            if (this.options.focusAfterOpen && this._container) {
              var t2 = this._container.querySelector(or);
              t2 && t2.focus();
            }
          }, o2.prototype._onClose = function() {
            this.remove();
          }, o2;
        }(t.Evented);
        var ar = { version: t.version, supported: e, setRTLTextPlugin: t.setRTLTextPlugin, getRTLTextPluginStatus: t.getRTLTextPluginStatus, Map: No, NavigationControl: jo, GeolocateControl: Yo, AttributionControl: Do, ScaleControl: Qo, FullscreenControl: er, Popup: rr, Marker: Ho, Style: Ne, LngLat: t.LngLat, LngLatBounds: t.LngLatBounds, Point: t.Point, MercatorCoordinate: t.MercatorCoordinate, Evented: t.Evented, config: t.config, get accessToken() {
          return t.config.ACCESS_TOKEN;
        }, set accessToken(e2) {
          t.config.ACCESS_TOKEN = e2;
        }, get baseApiUrl() {
          return t.config.API_URL;
        }, set baseApiUrl(e2) {
          t.config.API_URL = e2;
        }, get workerCount() {
          return Rt.workerCount;
        }, set workerCount(t2) {
          Rt.workerCount = t2;
        }, get maxParallelImageRequests() {
          return t.config.MAX_PARALLEL_IMAGE_REQUESTS;
        }, set maxParallelImageRequests(e2) {
          t.config.MAX_PARALLEL_IMAGE_REQUESTS = e2;
        }, clearStorage: function(e2) {
          t.clearTileCache(e2);
        }, workerUrl: "" };
        return ar;
      });
      return goongjs;
    });
  }
});

// node_modules/hammerjs/hammer.js
var require_hammer = __commonJS({
  "node_modules/hammerjs/hammer.js"(exports, module) {
    (function(window2, document2, exportName, undefined2) {
      "use strict";
      var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
      var TEST_ELEMENT = document2.createElement("div");
      var TYPE_FUNCTION = "function";
      var round = Math.round;
      var abs = Math.abs;
      var now = Date.now;
      function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
      }
      function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
        }
        return false;
      }
      function each(obj, iterator, context) {
        var i;
        if (!obj) {
          return;
        }
        if (obj.forEach) {
          obj.forEach(iterator, context);
        } else if (obj.length !== undefined2) {
          i = 0;
          while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
          }
        } else {
          for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
        }
      }
      function deprecate(method, name, message) {
        var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
        return function() {
          var e = new Error("get-stack-trace");
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
          var log = window2.console && (window2.console.warn || window2.console.log);
          if (log) {
            log.call(window2.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
        };
      }
      var assign;
      if (typeof Object.assign !== "function") {
        assign = function assign2(target) {
          if (target === undefined2 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var index2 = 1; index2 < arguments.length; index2++) {
            var source = arguments[index2];
            if (source !== undefined2 && source !== null) {
              for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey)) {
                  output[nextKey] = source[nextKey];
                }
              }
            }
          }
          return output;
        };
      } else {
        assign = Object.assign;
      }
      var extend = deprecate(function extend2(dest, src, merge2) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
          if (!merge2 || merge2 && dest[keys[i]] === undefined2) {
            dest[keys[i]] = src[keys[i]];
          }
          i++;
        }
        return dest;
      }, "extend", "Use `assign`.");
      var merge = deprecate(function merge2(dest, src) {
        return extend(dest, src, true);
      }, "merge", "Use `assign`.");
      function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
          assign(childP, properties);
        }
      }
      function bindFn(fn, context) {
        return function boundFn() {
          return fn.apply(context, arguments);
        };
      }
      function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined2 : undefined2, args);
        }
        return val;
      }
      function ifUndefined(val1, val2) {
        return val1 === undefined2 ? val2 : val1;
      }
      function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
        });
      }
      function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
        });
      }
      function hasParent(node, parent) {
        while (node) {
          if (node == parent) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      }
      function inStr(str, find) {
        return str.indexOf(find) > -1;
      }
      function splitStr(str) {
        return str.trim().split(/\s+/g);
      }
      function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find);
        } else {
          var i = 0;
          while (i < src.length) {
            if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
              return i;
            }
            i++;
          }
          return -1;
        }
      }
      function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
      }
      function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray(values, val) < 0) {
            results.push(src[i]);
          }
          values[i] = val;
          i++;
        }
        if (sort) {
          if (!key) {
            results = results.sort();
          } else {
            results = results.sort(function sortUniqueArray(a, b) {
              return a[key] > b[key];
            });
          }
        }
        return results;
      }
      function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = prefix ? prefix + camelProp : property;
          if (prop in obj) {
            return prop;
          }
          i++;
        }
        return undefined2;
      }
      var _uniqueId = 1;
      function uniqueId() {
        return _uniqueId++;
      }
      function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window2;
      }
      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = "ontouchstart" in window2;
      var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined2;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = "touch";
      var INPUT_TYPE_PEN = "pen";
      var INPUT_TYPE_MOUSE = "mouse";
      var INPUT_TYPE_KINECT = "kinect";
      var COMPUTE_INTERVAL = 25;
      var INPUT_START2 = 1;
      var INPUT_MOVE2 = 2;
      var INPUT_END2 = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ["x", "y"];
      var PROPS_CLIENT_XY = ["clientX", "clientY"];
      function Input2(manager, callback) {
        var self2 = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self2.handler(ev);
          }
        };
        this.init();
      }
      Input2.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() {
        },
        /**
         * bind the events
         */
        init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
         * unbind the events
         */
        destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };
      function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
          Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput2;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type = MouseInput2;
        } else {
          Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
      }
      function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START2 && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END2 | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
          manager.session = {};
        }
        input.eventType = eventType;
        computeInputData(manager, input);
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
      }
      function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
        }
        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
        }
        input.target = target;
      }
      function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START2 || prevInput.eventType === INPUT_END2) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset = session.offsetDelta = {
            x: center.x,
            y: center.y
          };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
      }
      function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;
          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);
          session.lastInterval = input;
        } else {
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
      }
      function simpleCloneInputData(input) {
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
          pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
          };
          i++;
        }
        return {
          timeStamp: now(),
          pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
        };
      }
      function getCenter(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) {
          return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
          };
        }
        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
        }
        return {
          x: round(x / pointersLength),
          y: round(y / pointersLength)
        };
      }
      function getVelocity(deltaTime, x, y) {
        return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
        };
      }
      function getDirection(x, y) {
        if (x === y) {
          return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }
      function getDistance(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
      }
      function getAngle(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
      }
      function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
      }
      function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
      }
      var MOUSE_INPUT_MAP2 = {
        mousedown: INPUT_START2,
        mousemove: INPUT_MOVE2,
        mouseup: INPUT_END2
      };
      var MOUSE_ELEMENT_EVENTS = "mousedown";
      var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
      function MouseInput2() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false;
        Input2.apply(this, arguments);
      }
      inherit(MouseInput2, Input2, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP2[ev.type];
          if (eventType & INPUT_START2 && ev.button === 0) {
            this.pressed = true;
          }
          if (eventType & INPUT_MOVE2 && ev.which !== 1) {
            eventType = INPUT_END2;
          }
          if (!this.pressed) {
            return;
          }
          if (eventType & INPUT_END2) {
            this.pressed = false;
          }
          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START2,
        pointermove: INPUT_MOVE2,
        pointerup: INPUT_END2,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      };
      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
        // see https://twitter.com/jacobrossi/status/480596438489890816
      };
      var POINTER_ELEMENT_EVENTS = "pointerdown";
      var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
      if (window2.MSPointerEvent && !window2.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
      }
      function PointerEventInput2() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input2.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }
      inherit(PointerEventInput2, Input2, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch = pointerType == INPUT_TYPE_TOUCH;
          var storeIndex = inArray(store, ev.pointerId, "pointerId");
          if (eventType & INPUT_START2 && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
              store.push(ev);
              storeIndex = store.length - 1;
            }
          } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
            removePointer = true;
          }
          if (storeIndex < 0) {
            return;
          }
          store[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType,
            srcEvent: ev
          });
          if (removePointer) {
            store.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START2,
        touchmove: INPUT_MOVE2,
        touchend: INPUT_END2,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
      var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input2.apply(this, arguments);
      }
      inherit(SingleTouchInput, Input2, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
          if (type === INPUT_START2) {
            this.started = true;
          }
          if (!this.started) {
            return;
          }
          var touches = normalizeSingleTouches.call(this, ev, type);
          if (type & (INPUT_END2 | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END2 | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), "identifier", true);
        }
        return [all, changed];
      }
      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START2,
        touchmove: INPUT_MOVE2,
        touchend: INPUT_END2,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input2.apply(this, arguments);
      }
      inherit(TouchInput, Input2, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
            return;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START2 | INPUT_MOVE2) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
        });
        if (type === INPUT_START2) {
          i = 0;
          while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
          }
        }
        i = 0;
        while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
          }
          if (type & (INPUT_END2 | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
          }
          i++;
        }
        if (!changedTargetTouches.length) {
          return;
        }
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
          changedTargetTouches
        ];
      }
      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;
      function TouchMouseInput() {
        Input2.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput2(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
      }
      inherit(TouchMouseInput, Input2, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          }
          if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
          }
          this.callback(manager, inputEvent, inputData);
        },
        /**
         * remove the event listeners
         */
        destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });
      function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START2) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
        }
      }
      function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
          var lastTouch = { x: touch.clientX, y: touch.clientY };
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
              lts.splice(i, 1);
            }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
      }
      function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
          }
        }
        return false;
      }
      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
      var TOUCH_ACTION_COMPUTE = "compute";
      var TOUCH_ACTION_AUTO = "auto";
      var TOUCH_ACTION_MANIPULATION = "manipulation";
      var TOUCH_ACTION_NONE = "none";
      var TOUCH_ACTION_PAN_X = "pan-x";
      var TOUCH_ACTION_PAN_Y = "pan-y";
      var TOUCH_ACTION_MAP = getTouchActionProps();
      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }
      TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value) {
          if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
          }
          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function() {
          this.set(this.manager.options.touchAction);
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(" "));
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;
          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }
          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
          if (hasNone) {
            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;
            if (isTapPointer && isTapMovement && isTapTouchTime) {
              return;
            }
          }
          if (hasPanX && hasPanY) {
            return;
          }
          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };
      function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
        }
        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
      }
      function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
          return false;
        }
        var touchMap = {};
        var cssSupports = window2.CSS && window2.CSS.supports;
        ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
          touchMap[val] = cssSupports ? window2.CSS.supports("touch-action", val) : true;
        });
        return touchMap;
      }
      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;
      function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null;
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }
      Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options) {
          assign(this.options, options);
          this.manager && this.manager.touchAction.update();
          return this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
            return this;
          }
          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }
          return this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
            return this;
          }
          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }
          return this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index2 = inArray(this.requireFail, otherRecognizer);
          if (index2 > -1) {
            this.requireFail.splice(index2, 1);
          }
          return this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
          return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
          var self2 = this;
          var state = this.state;
          function emit(event) {
            self2.manager.emit(event, input);
          }
          if (state < STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
          emit(self2.options.event);
          if (input.additionalEvent) {
            emit(input.additionalEvent);
          }
          if (state >= STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
          if (this.canEmit()) {
            return this.emit(input);
          }
          this.state = STATE_FAILED;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
          var i = 0;
          while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }
            i++;
          }
          return true;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var inputDataClone = assign({}, inputData);
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          }
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }
          this.state = this.process(inputDataClone);
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) {
        },
        // jshint ignore:line
        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() {
        },
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() {
        }
      };
      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return "cancel";
        } else if (state & STATE_ENDED) {
          return "end";
        } else if (state & STATE_CHANGED) {
          return "move";
        } else if (state & STATE_BEGAN) {
          return "start";
        }
        return "";
      }
      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return "down";
        } else if (direction == DIRECTION_UP) {
          return "up";
        } else if (direction == DIRECTION_LEFT) {
          return "left";
        } else if (direction == DIRECTION_RIGHT) {
          return "right";
        }
        return "";
      }
      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
          return manager.get(otherRecognizer);
        }
        return otherRecognizer;
      }
      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }
      inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
          var state = this.state;
          var eventType = input.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid2 = this.attrTest(input);
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid2)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid2) {
            if (eventType & INPUT_END2) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
          }
          return STATE_FAILED;
        }
      });
      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }
      inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
        },
        directionTest: function(input) {
          var options = this.options;
          var hasMoved = true;
          var distance = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;
          if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
              direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x != this.pX;
              distance = Math.abs(input.deltaX);
            } else {
              direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y != this.pY;
              distance = Math.abs(input.deltaY);
            }
          }
          input.direction = direction;
          return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
          this.pX = input.deltaX;
          this.pY = input.deltaY;
          var direction = directionStr(input.direction);
          if (direction) {
            input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
        }
      });
      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
          if (input.scale !== 1) {
            var inOut = input.scale < 1 ? "in" : "out";
            input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
        }
      });
      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }
      inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: "press",
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9
          // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;
          this._input = input;
          if (!validMovement || !validPointers || input.eventType & (INPUT_END2 | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input.eventType & INPUT_START2) {
            this.reset();
            this._timer = setTimeoutContext(function() {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.time, this);
          } else if (input.eventType & INPUT_END2) {
            return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }
          if (input && input.eventType & INPUT_END2) {
            this.manager.emit(this.options.event + "up", input);
          } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });
      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: "swipe",
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;
          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
          }
          return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END2;
        },
        emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }
          this.manager.emit(this.options.event, input);
        }
      });
      function TapRecognizer() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }
      inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10
          // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;
          this.reset();
          if (input.eventType & INPUT_START2 && this.count === 0) {
            return this.failTimeout();
          }
          if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END2) {
              return this.failTimeout();
            }
            var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;
            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }
            this._input = input;
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options.interval, this);
                return STATE_BEGAN;
              }
            }
          }
          return STATE_FAILED;
        },
        failTimeout: function() {
          this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function() {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager3(element, options);
      }
      Hammer.VERSION = "2.0.7";
      Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, { enable: false }],
          [PinchRecognizer, { enable: false }, ["rotate"]],
          [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
          [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
          [TapRecognizer],
          [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
          [PressRecognizer]
        ],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: "none",
          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: "none",
          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: "none",
          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: "none",
          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: "none",
          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;
      function Manager3(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function(item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }
      Manager3.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options) {
          assign(this.options, options);
          if (options.touchAction) {
            this.touchAction.update();
          }
          if (options.inputTarget) {
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
          }
          return this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
            return;
          }
          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers;
          var curRecognizer = session.curRecognizer;
          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }
          var i = 0;
          while (i < recognizers.length) {
            recognizer = recognizers[i];
            if (session.stopped !== FORCED_STOP && // 1
            (!curRecognizer || recognizer == curRecognizer || // 2
            recognizer.canRecognizeWith(curRecognizer))) {
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            }
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
          }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }
          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
              return recognizers[i];
            }
          }
          return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
          if (invokeArrayArg(recognizer, "add", this)) {
            return this;
          }
          var existing = this.get(recognizer.options.event);
          if (existing) {
            this.remove(existing);
          }
          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
          if (invokeArrayArg(recognizer, "remove", this)) {
            return this;
          }
          recognizer = this.get(recognizer);
          if (recognizer) {
            var recognizers = this.recognizers;
            var index2 = inArray(recognizers, recognizer);
            if (index2 !== -1) {
              recognizers.splice(index2, 1);
              this.touchAction.update();
            }
          }
          return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events, handler) {
          if (events === undefined2) {
            return;
          }
          if (handler === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
          });
          return this;
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events, handler) {
          if (events === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
            if (!handler) {
              delete handlers[event];
            } else {
              handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
          });
          return this;
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data) {
          if (this.options.domEvents) {
            triggerDomEvent(event, data);
          }
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
            return;
          }
          data.type = event;
          data.preventDefault = function() {
            data.srcEvent.preventDefault();
          };
          var i = 0;
          while (i < handlers.length) {
            handlers[i](data);
            i++;
          }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };
      function toggleCssProps(manager, add3) {
        var element = manager.element;
        if (!element.style) {
          return;
        }
        var prop;
        each(manager.options.cssProps, function(value, name) {
          prop = prefixed(element.style, name);
          if (add3) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
          } else {
            element.style[prop] = manager.oldCssProps[prop] || "";
          }
        });
        if (!add3) {
          manager.oldCssProps = {};
        }
      }
      function triggerDomEvent(event, data) {
        var gestureEvent = document2.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
      }
      assign(Hammer, {
        INPUT_START: INPUT_START2,
        INPUT_MOVE: INPUT_MOVE2,
        INPUT_END: INPUT_END2,
        INPUT_CANCEL,
        STATE_POSSIBLE,
        STATE_BEGAN,
        STATE_CHANGED,
        STATE_ENDED,
        STATE_RECOGNIZED,
        STATE_CANCELLED,
        STATE_FAILED,
        DIRECTION_NONE,
        DIRECTION_LEFT,
        DIRECTION_RIGHT,
        DIRECTION_UP,
        DIRECTION_DOWN,
        DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL,
        DIRECTION_ALL,
        Manager: Manager3,
        Input: Input2,
        TouchAction,
        TouchInput,
        MouseInput: MouseInput2,
        PointerEventInput: PointerEventInput2,
        TouchMouseInput,
        SingleTouchInput,
        Recognizer,
        AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each,
        merge,
        extend,
        assign,
        inherit,
        bindFn,
        prefixed
      });
      var freeGlobal = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
      freeGlobal.Hammer = Hammer;
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Hammer;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = Hammer;
      } else {
        window2[exportName] = Hammer;
      }
    })(window, document, "Hammer");
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

// node_modules/@goongmaps/goong-map-react/dist/esm/components/interactive-map.js
var React3 = __toESM(require_react());
var import_react4 = __toESM(require_react());
var PropTypes3 = __toESM(require_prop_types());

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t)
          return;
        f = false;
      } else
        for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
          ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u))
          return;
      } finally {
        if (o)
          throw n;
      }
    }
    return a;
  }
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

// node_modules/@goongmaps/goong-map-react/dist/esm/components/static-map.js
var React2 = __toESM(require_react());
var import_react3 = __toESM(require_react());
var PropTypes2 = __toESM(require_prop_types());

// node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// node_modules/gl-matrix/esm/vec4.js
function create() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
var forEach = function() {
  var vec = create();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// node_modules/@math.gl/web-mercator/dist/esm/math-utils.js
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function transformVector(matrix, vector) {
  const result = transformMat4([], vector, matrix);
  scale(result, result, 1 / result[3]);
  return result;
}
function mod(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function lerp(start, end, step) {
  return step * end + (1 - step) * start;
}
function clamp(x, min, max) {
  return x < min ? min : x > max ? max : x;
}
function ieLog2(x) {
  return Math.log(x) * Math.LOG2E;
}
var log2 = Math.log2 || ieLog2;

// node_modules/gl-matrix/esm/mat4.js
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
  var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}

// node_modules/gl-matrix/esm/vec2.js
function create2() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function scale3(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function length(a) {
  var x = a[0], y = a[1];
  return Math.hypot(x, y);
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function lerp2(out, a, b, t) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
var sub = subtract;
var forEach2 = function() {
  var vec = create2();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

// node_modules/gl-matrix/esm/vec3.js
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function multiply2(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
var mul = multiply2;
var forEach3 = function() {
  var vec = create3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// node_modules/@math.gl/web-mercator/dist/esm/assert.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "@math.gl/web-mercator: assertion failed.");
  }
}

// node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
var EARTH_CIRCUMFERENCE = 4003e4;
var MAX_LATITUDE = 85.051129;
var DEFAULT_ALTITUDE = 1.5;
function zoomToScale(zoom) {
  return Math.pow(2, zoom);
}
function scaleToZoom(scale4) {
  return log2(scale4);
}
function lngLatToWorld(lngLat) {
  const [lng, lat] = lngLat;
  assert(Number.isFinite(lng));
  assert(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
  const lambda2 = lng * DEGREES_TO_RADIANS;
  const phi2 = lat * DEGREES_TO_RADIANS;
  const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);
  const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}
function worldToLngLat(xy) {
  const [x, y] = xy;
  const lambda2 = x / TILE_SIZE * (2 * PI) - PI;
  const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}
function getDistanceScales(options) {
  const {
    latitude,
    longitude,
    highPrecision = false
  } = options;
  assert(Number.isFinite(latitude) && Number.isFinite(longitude));
  const worldSize = TILE_SIZE;
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  const unitsPerDegreeX = worldSize / 360;
  const unitsPerDegreeY = unitsPerDegreeX / latCosine;
  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
  const result = {
    unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],
    metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],
    unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],
    degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]
  };
  if (highPrecision) {
    const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
    const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
    const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
  }
  return result;
}
function getViewMatrix(options) {
  const {
    height,
    pitch,
    bearing,
    altitude,
    scale: scale4,
    center
  } = options;
  const vm = createMat4();
  translate(vm, vm, [0, 0, -altitude]);
  rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);
  rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);
  const relativeScale = scale4 / height;
  scale2(vm, vm, [relativeScale, relativeScale, relativeScale]);
  if (center) {
    translate(vm, vm, negate2([], center));
  }
  return vm;
}
function getProjectionParameters(options) {
  const {
    width,
    height,
    altitude,
    pitch = 0,
    offset,
    center,
    scale: scale4,
    nearZMultiplier = 1,
    farZMultiplier = 1
  } = options;
  let {
    fovy = altitudeToFovy(DEFAULT_ALTITUDE)
  } = options;
  if (altitude !== void 0) {
    fovy = altitudeToFovy(altitude);
  }
  const fovRadians = fovy * DEGREES_TO_RADIANS;
  const pitchRadians = pitch * DEGREES_TO_RADIANS;
  const focalDistance = fovyToAltitude(fovy);
  let cameraToSeaLevelDistance = focalDistance;
  if (center) {
    cameraToSeaLevelDistance += center[2] * scale4 / Math.cos(pitchRadians) / height;
  }
  const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
  const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
  const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
  const horizonDistance = cameraToSeaLevelDistance * 10;
  const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
  return {
    fov: fovRadians,
    aspect: width / height,
    focalDistance,
    near: nearZMultiplier,
    far: farZ
  };
}
function getProjectionMatrix(options) {
  const {
    fov,
    aspect,
    near,
    far
  } = getProjectionParameters(options);
  const projectionMatrix = perspective([], fov, aspect, near, far);
  return projectionMatrix;
}
function altitudeToFovy(altitude) {
  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;
}
function fovyToAltitude(fovy) {
  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS);
}
function worldToPixels(xyz, pixelProjectionMatrix) {
  const [x, y, z = 0] = xyz;
  assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
  return transformVector(pixelProjectionMatrix, [x, y, z, 1]);
}
function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
  const [x, y, z] = xyz;
  assert(Number.isFinite(x) && Number.isFinite(y), "invalid pixel coordinate");
  if (Number.isFinite(z)) {
    const coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);
    return coord;
  }
  const coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);
  const coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);
  const z0 = coord0[2];
  const z1 = coord1[2];
  const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return lerp2([], coord0, coord1, t);
}

// node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js
function fitBounds(options) {
  const {
    width,
    height,
    bounds,
    minExtent = 0,
    maxZoom = 24,
    offset = [0, 0]
  } = options;
  const [[west, south], [east, north]] = bounds;
  const padding = getPaddingObject(options.padding);
  const nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);
  const se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);
  const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];
  const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
  assert(targetSize[0] > 0 && targetSize[1] > 0);
  const scaleX = targetSize[0] / size[0];
  const scaleY = targetSize[1] / size[1];
  const offsetX = (padding.right - padding.left) / 2 / scaleX;
  const offsetY = (padding.top - padding.bottom) / 2 / scaleY;
  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
  const centerLngLat = worldToLngLat(center);
  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));
  assert(Number.isFinite(zoom));
  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom
  };
}
function getPaddingObject(padding = 0) {
  if (typeof padding === "number") {
    return {
      top: padding,
      bottom: padding,
      left: padding,
      right: padding
    };
  }
  assert(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
  return padding;
}

// node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js
var DEGREES_TO_RADIANS2 = Math.PI / 180;
function getBounds(viewport, z = 0) {
  const {
    width,
    height,
    unproject
  } = viewport;
  const unprojectOps = {
    targetZ: z
  };
  const bottomLeft = unproject([0, height], unprojectOps);
  const bottomRight = unproject([width, height], unprojectOps);
  let topLeft;
  let topRight;
  const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS2 : Math.atan(0.5 / viewport.altitude);
  const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS2;
  if (halfFov > angleToGround - 0.01) {
    topLeft = unprojectOnFarPlane(viewport, 0, z);
    topRight = unprojectOnFarPlane(viewport, width, z);
  } else {
    topLeft = unproject([0, 0], unprojectOps);
    topRight = unproject([width, 0], unprojectOps);
  }
  return [bottomLeft, bottomRight, topRight, topLeft];
}
function unprojectOnFarPlane(viewport, x, targetZ) {
  const {
    pixelUnprojectionMatrix
  } = viewport;
  const coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);
  const coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);
  const z = targetZ * viewport.distanceScales.unitsPerMeter[2];
  const t = (z - coord0[2]) / (coord1[2] - coord0[2]);
  const coord = lerp2([], coord0, coord1, t);
  const result = worldToLngLat(coord);
  result.push(targetZ);
  return result;
}

// node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js
var WebMercatorViewport = class _WebMercatorViewport {
  constructor(props = {
    width: 1,
    height: 1
  }) {
    _defineProperty(this, "latitude", void 0);
    _defineProperty(this, "longitude", void 0);
    _defineProperty(this, "zoom", void 0);
    _defineProperty(this, "pitch", void 0);
    _defineProperty(this, "bearing", void 0);
    _defineProperty(this, "altitude", void 0);
    _defineProperty(this, "fovy", void 0);
    _defineProperty(this, "meterOffset", void 0);
    _defineProperty(this, "center", void 0);
    _defineProperty(this, "width", void 0);
    _defineProperty(this, "height", void 0);
    _defineProperty(this, "scale", void 0);
    _defineProperty(this, "distanceScales", void 0);
    _defineProperty(this, "viewMatrix", void 0);
    _defineProperty(this, "projectionMatrix", void 0);
    _defineProperty(this, "viewProjectionMatrix", void 0);
    _defineProperty(this, "pixelProjectionMatrix", void 0);
    _defineProperty(this, "pixelUnprojectionMatrix", void 0);
    _defineProperty(this, "equals", (viewport) => {
      if (!(viewport instanceof _WebMercatorViewport)) {
        return false;
      }
      return viewport.width === this.width && viewport.height === this.height && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);
    });
    _defineProperty(this, "project", (lngLatZ, options = {}) => {
      const {
        topLeft = true
      } = options;
      const worldPosition = this.projectPosition(lngLatZ);
      const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
      const [x, y] = coord;
      const y2 = topLeft ? y : this.height - y;
      return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];
    });
    _defineProperty(this, "unproject", (xyz, options = {}) => {
      const {
        topLeft = true,
        targetZ = void 0
      } = options;
      const [x, y, z] = xyz;
      const y2 = topLeft ? y : this.height - y;
      const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
      const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
      const [X, Y, Z] = this.unprojectPosition(coord);
      if (Number.isFinite(z)) {
        return [X, Y, Z];
      }
      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    });
    _defineProperty(this, "projectPosition", (xyz) => {
      const [X, Y] = lngLatToWorld(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
      return [X, Y, Z];
    });
    _defineProperty(this, "unprojectPosition", (xyz) => {
      const [X, Y] = worldToLngLat(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
      return [X, Y, Z];
    });
    let {
      width,
      height,
      altitude = null,
      fovy = null
    } = props;
    const {
      latitude = 0,
      longitude = 0,
      zoom = 0,
      pitch = 0,
      bearing = 0,
      position = null,
      nearZMultiplier = 0.02,
      farZMultiplier = 1.01
    } = props;
    width = width || 1;
    height = height || 1;
    if (fovy === null && altitude === null) {
      altitude = DEFAULT_ALTITUDE;
      fovy = altitudeToFovy(altitude);
    } else if (fovy === null) {
      fovy = altitudeToFovy(altitude);
    } else if (altitude === null) {
      altitude = fovyToAltitude(fovy);
    }
    const scale4 = zoomToScale(zoom);
    altitude = Math.max(0.75, altitude);
    const distanceScales = getDistanceScales({
      longitude,
      latitude
    });
    const center = lngLatToWorld([longitude, latitude]);
    center.push(0);
    if (position) {
      add2(center, center, mul([], position, distanceScales.unitsPerMeter));
    }
    this.projectionMatrix = getProjectionMatrix({
      width,
      height,
      scale: scale4,
      center,
      pitch,
      fovy,
      nearZMultiplier,
      farZMultiplier
    });
    this.viewMatrix = getViewMatrix({
      height,
      scale: scale4,
      center,
      pitch,
      bearing,
      altitude
    });
    this.width = width;
    this.height = height;
    this.scale = scale4;
    this.latitude = latitude;
    this.longitude = longitude;
    this.zoom = zoom;
    this.pitch = pitch;
    this.bearing = bearing;
    this.altitude = altitude;
    this.fovy = fovy;
    this.center = center;
    this.meterOffset = position || [0, 0, 0];
    this.distanceScales = distanceScales;
    this._initMatrices();
    Object.freeze(this);
  }
  _initMatrices() {
    const {
      width,
      height,
      projectionMatrix,
      viewMatrix
    } = this;
    const vpm = createMat4();
    multiply(vpm, vpm, projectionMatrix);
    multiply(vpm, vpm, viewMatrix);
    this.viewProjectionMatrix = vpm;
    const m = createMat4();
    scale2(m, m, [width / 2, -height / 2, 1]);
    translate(m, m, [1, -1, 0]);
    multiply(m, m, vpm);
    const mInverse = invert(createMat4(), m);
    if (!mInverse) {
      throw new Error("Pixel project matrix not invertible");
    }
    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;
  }
  projectFlat(lngLat) {
    return lngLatToWorld(lngLat);
  }
  unprojectFlat(xy) {
    return worldToLngLat(xy);
  }
  getMapCenterByLngLatPosition({
    lngLat,
    pos
  }) {
    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);
    const toLocation = lngLatToWorld(lngLat);
    const translate2 = add([], toLocation, negate([], fromLocation));
    const newCenter = add([], this.center, translate2);
    return worldToLngLat(newCenter);
  }
  fitBounds(bounds, options = {}) {
    const {
      width,
      height
    } = this;
    const {
      longitude,
      latitude,
      zoom
    } = fitBounds(Object.assign({
      width,
      height,
      bounds
    }, options));
    return new _WebMercatorViewport({
      width,
      height,
      longitude,
      latitude,
      zoom
    });
  }
  getBounds(options) {
    const corners = this.getBoundingRegion(options);
    const west = Math.min(...corners.map((p) => p[0]));
    const east = Math.max(...corners.map((p) => p[0]));
    const south = Math.min(...corners.map((p) => p[1]));
    const north = Math.max(...corners.map((p) => p[1]));
    return [[west, south], [east, north]];
  }
  getBoundingRegion(options = {}) {
    return getBounds(this, options.z || 0);
  }
  getLocationAtPoint({
    lngLat,
    pos
  }) {
    return this.getMapCenterByLngLatPosition({
      lngLat,
      pos
    });
  }
};

// node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js
var TILE_SIZE2 = 512;
function normalizeViewportProps(props) {
  const {
    width,
    height,
    pitch = 0
  } = props;
  let {
    longitude,
    latitude,
    zoom,
    bearing = 0
  } = props;
  if (longitude < -180 || longitude > 180) {
    longitude = mod(longitude + 180, 360) - 180;
  }
  if (bearing < -180 || bearing > 180) {
    bearing = mod(bearing + 180, 360) - 180;
  }
  const minZoom = log2(height / TILE_SIZE2);
  if (zoom <= minZoom) {
    zoom = minZoom;
    latitude = 0;
  } else {
    const halfHeightPixels = height / 2 / Math.pow(2, zoom);
    const minLatitude = worldToLngLat([0, halfHeightPixels])[1];
    if (latitude < minLatitude) {
      latitude = minLatitude;
    } else {
      const maxLatitude = worldToLngLat([0, TILE_SIZE2 - halfHeightPixels])[1];
      if (latitude > maxLatitude) {
        latitude = maxLatitude;
      }
    }
  }
  return {
    width,
    height,
    longitude,
    latitude,
    zoom,
    pitch,
    bearing
  };
}

// node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js
var EPSILON2 = 0.01;
var VIEWPORT_TRANSITION_PROPS = ["longitude", "latitude", "zoom"];
var DEFAULT_OPTS = {
  curve: 1.414,
  speed: 1.2
};
function flyToViewport(startProps, endProps, t, options) {
  const {
    startZoom,
    startCenterXY,
    uDelta,
    w0,
    u1,
    S,
    rho,
    rho2,
    r0
  } = getFlyToTransitionParams(startProps, endProps, options);
  if (u1 < EPSILON2) {
    const viewport = {};
    for (const key of VIEWPORT_TRANSITION_PROPS) {
      const startValue = startProps[key];
      const endValue = endProps[key];
      viewport[key] = lerp(startValue, endValue, t);
    }
    return viewport;
  }
  const s = t * S;
  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);
  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;
  const scaleIncrement = 1 / w;
  const newZoom = startZoom + scaleToZoom(scaleIncrement);
  const newCenterWorld = scale3([], uDelta, u);
  add(newCenterWorld, newCenterWorld, startCenterXY);
  const newCenter = worldToLngLat(newCenterWorld);
  return {
    longitude: newCenter[0],
    latitude: newCenter[1],
    zoom: newZoom
  };
}
function getFlyToDuration(startProps, endProps, options) {
  const opts = {
    ...DEFAULT_OPTS,
    ...options
  };
  const {
    screenSpeed,
    speed,
    maxDuration
  } = opts;
  const {
    S,
    rho
  } = getFlyToTransitionParams(startProps, endProps, opts);
  const length2 = 1e3 * S;
  let duration;
  if (Number.isFinite(screenSpeed)) {
    duration = length2 / (screenSpeed / rho);
  } else {
    duration = length2 / speed;
  }
  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;
}
function getFlyToTransitionParams(startProps, endProps, opts) {
  opts = Object.assign({}, DEFAULT_OPTS, opts);
  const rho = opts.curve;
  const startZoom = startProps.zoom;
  const startCenter = [startProps.longitude, startProps.latitude];
  const startScale = zoomToScale(startZoom);
  const endZoom = endProps.zoom;
  const endCenter = [endProps.longitude, endProps.latitude];
  const scale4 = zoomToScale(endZoom - startZoom);
  const startCenterXY = lngLatToWorld(startCenter);
  const endCenterXY = lngLatToWorld(endCenter);
  const uDelta = sub([], endCenterXY, startCenterXY);
  const w0 = Math.max(startProps.width, startProps.height);
  const w1 = w0 / scale4;
  const u1 = length(uDelta) * startScale;
  const _u1 = Math.max(u1, EPSILON2);
  const rho2 = rho * rho;
  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
  const S = (r1 - r0) / rho;
  return {
    startZoom,
    startCenterXY,
    uDelta,
    w0,
    u1,
    S,
    rho,
    rho2,
    r0,
    r1
  };
}

// node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return (
    /** @class */
    function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index2 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index2];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value) {
        var index2 = getIndex(this.__entries__, key);
        if (~index2) {
          this.__entries__[index2][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index2 = getIndex(entries, key);
        if (~index2) {
          entries.splice(index2, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index2 = observers2.indexOf(observer);
      if (~index2) {
        observers2.splice(index2, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
      var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }()
);
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
function createRectInit(x, y, width, height) {
  return { x, y, width, height };
}
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }()
);
var ResizeObserverEntry = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserverEntry2(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target, contentRect });
    }
    return ResizeObserverEntry2;
  }()
);
var ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target)) {
        return;
      }
      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target)) {
        return;
      }
      observations.delete(target);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }()
);
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return ResizeObserver2;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver.prototype[method] = function() {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();
var ResizeObserver_es_default = index;

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

// node_modules/@goongmaps/goong-map-react/dist/esm/goong/goong.js
var PropTypes = __toESM(require_prop_types());

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/globals.js
var window_ = typeof window !== "undefined" ? window : global;
var document_ = typeof document !== "undefined" ? document : {};

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/style-utils.js
function ownKeys(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var refProps = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
function normalizeStyle(style) {
  if (!style) {
    return null;
  }
  if (typeof style === "string") {
    return style;
  }
  if (style.toJS) {
    style = style.toJS();
  }
  var layerIndex = {};
  var _iterator = _createForOfIteratorHelper(style.layers), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var layer = _step.value;
      layerIndex[layer.id] = layer;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var layers = style.layers.map(function(layer2) {
    var layerRef = layerIndex[layer2.ref];
    var normalizedLayer = null;
    if ("interactive" in layer2) {
      normalizedLayer = _objectSpread({}, layer2);
      delete normalizedLayer.interactive;
    }
    if (layerRef) {
      normalizedLayer = normalizedLayer || _objectSpread({}, layer2);
      delete normalizedLayer.ref;
      var _iterator2 = _createForOfIteratorHelper(refProps), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var propName = _step2.value;
          if (propName in layerRef) {
            normalizedLayer[propName] = layerRef[propName];
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    return normalizedLayer || layer2;
  });
  return _objectSpread(_objectSpread({}, style), {}, {
    layers
  });
}

// node_modules/@goongmaps/goong-map-react/dist/esm/goong/goong.js
function noop() {
}
function defaultOnError(event) {
  if (event) {
    console.error(event.error);
  }
}
var propTypes = {
  container: PropTypes.object,
  gl: PropTypes.object,
  goongApiAccessToken: PropTypes.string,
  goongApiUrl: PropTypes.string,
  attributionControl: PropTypes.bool,
  preserveDrawingBuffer: PropTypes.bool,
  reuseMaps: PropTypes.bool,
  transformRequest: PropTypes.func,
  mapOptions: PropTypes.object,
  mapStyle: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
  preventStyleDiffing: PropTypes.bool,
  visible: PropTypes.bool,
  asyncRender: PropTypes.bool,
  onLoad: PropTypes.func,
  onError: PropTypes.func,
  width: PropTypes.number,
  height: PropTypes.number,
  viewState: PropTypes.object,
  longitude: PropTypes.number,
  latitude: PropTypes.number,
  zoom: PropTypes.number,
  bearing: PropTypes.number,
  pitch: PropTypes.number,
  altitude: PropTypes.number
};
var defaultProps = {
  container: document_.body,
  goongApiAccessToken: getAccessToken(),
  goongApiUrl: "https://tiles.goong.io",
  preserveDrawingBuffer: false,
  attributionControl: true,
  reuseMaps: false,
  mapOptions: {},
  mapStyle: "https://tiles.goong.io/assets/goong_map_web.json",
  preventStyleDiffing: false,
  visible: true,
  asyncRender: false,
  onLoad: noop,
  onError: defaultOnError,
  width: 0,
  height: 0,
  longitude: 0,
  latitude: 0,
  zoom: 0,
  bearing: 0,
  pitch: 0,
  altitude: 1.5
};
function getAccessToken() {
  var accessToken = null;
  if (typeof window !== "undefined" && window.location) {
    var match = window.location.search.match(/api_key=([^&\/]*)/);
    accessToken = match && match[1];
  }
  if (!accessToken && typeof process !== "undefined") {
    accessToken = accessToken || process.env.GoongAccessToken || process.env.REACT_APP_GOONG_ACCESS_TOKEN;
  }
  return accessToken || "no-token";
}
function checkPropTypes2(props) {
  var component = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "component";
  if (props.debug) {
    PropTypes.checkPropTypes(propTypes, props, "prop", component);
  }
}
var Goong = function() {
  function Goong2(props) {
    var _this = this;
    _classCallCheck(this, Goong2);
    _defineProperty(this, "props", defaultProps);
    _defineProperty(this, "width", 0);
    _defineProperty(this, "height", 0);
    _defineProperty(this, "_fireLoadEvent", function() {
      _this.props.onLoad({
        type: "load",
        target: _this._map
      });
    });
    if (!props.mapboxgl) {
      throw new Error("Goong JS not available");
    }
    this.mapboxgl = props.mapboxgl;
    if (!Goong2.initialized) {
      Goong2.initialized = true;
      this._checkStyleSheet(this.mapboxgl.version);
    }
    this._initialize(props);
  }
  _createClass(Goong2, [{
    key: "finalize",
    value: function finalize() {
      this._destroy();
      return this;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this._update(this.props, props);
      return this;
    }
  }, {
    key: "redraw",
    value: function redraw() {
      var map = this._map;
      if (map.style) {
        if (map._frame) {
          map._frame.cancel();
          map._frame = null;
        }
        map._render();
      }
    }
  }, {
    key: "getMap",
    value: function getMap() {
      return this._map;
    }
  }, {
    key: "_reuse",
    value: function _reuse(props) {
      this._map = Goong2.savedMap;
      var oldContainer = this._map.getContainer();
      var newContainer = props.container;
      newContainer.classList.add("mapboxgl-map");
      if (oldContainer !== newContainer) {
        while (oldContainer.childNodes.length > 0) {
          newContainer.appendChild(oldContainer.childNodes[0]);
        }
      }
      this._map._container = newContainer;
      Goong2.savedMap = null;
      if (props.mapStyle) {
        this._map.setStyle(normalizeStyle(props.mapStyle), {
          diff: false
        });
      }
      if (this._map.isStyleLoaded()) {
        this._fireLoadEvent();
      } else {
        this._map.once("styledata", this._fireLoadEvent);
      }
    }
  }, {
    key: "_create",
    value: function _create(props) {
      if (props.reuseMaps && Goong2.savedMap) {
        this._reuse(props);
      } else {
        if (props.gl) {
          var getContext = HTMLCanvasElement.prototype.getContext;
          HTMLCanvasElement.prototype.getContext = function() {
            HTMLCanvasElement.prototype.getContext = getContext;
            return props.gl;
          };
        }
        var mapOptions = {
          container: props.container,
          center: [0, 0],
          zoom: 8,
          pitch: 0,
          bearing: 0,
          maxZoom: 24,
          style: normalizeStyle(props.mapStyle),
          interactive: false,
          trackResize: false,
          attributionControl: props.attributionControl,
          preserveDrawingBuffer: props.preserveDrawingBuffer
        };
        if (props.transformRequest) {
          mapOptions.transformRequest = props.transformRequest;
        }
        this._map = new this.mapboxgl.Map(Object.assign({}, mapOptions, props.mapOptions));
        this._map.once("load", props.onLoad);
        this._map.on("error", props.onError);
      }
      return this;
    }
  }, {
    key: "_destroy",
    value: function _destroy() {
      if (!this._map) {
        return;
      }
      if (this.props.reuseMaps && !Goong2.savedMap) {
        Goong2.savedMap = this._map;
        this._map.off("load", this.props.onLoad);
        this._map.off("error", this.props.onError);
        this._map.off("styledata", this._fireLoadEvent);
      } else {
        this._map.remove();
      }
      this._map = null;
    }
  }, {
    key: "_initialize",
    value: function _initialize(props) {
      var _this2 = this;
      props = Object.assign({}, defaultProps, props);
      checkPropTypes2(props, "Goong");
      this.mapboxgl.accessToken = props.goongApiAccessToken || defaultProps.goongApiAccessToken;
      this.mapboxgl.baseApiUrl = props.goongApiUrl;
      this._create(props);
      var _props = props, container = _props.container;
      Object.defineProperty(container, "offsetWidth", {
        configurable: true,
        get: function get() {
          return _this2.width;
        }
      });
      Object.defineProperty(container, "clientWidth", {
        configurable: true,
        get: function get() {
          return _this2.width;
        }
      });
      Object.defineProperty(container, "offsetHeight", {
        configurable: true,
        get: function get() {
          return _this2.height;
        }
      });
      Object.defineProperty(container, "clientHeight", {
        configurable: true,
        get: function get() {
          return _this2.height;
        }
      });
      var canvas = this._map.getCanvas();
      if (canvas) {
        canvas.style.outline = "none";
      }
      this._updateMapViewport({}, props);
      this._updateMapSize({}, props);
      this.props = props;
    }
  }, {
    key: "_update",
    value: function _update(oldProps, newProps) {
      if (!this._map) {
        return;
      }
      newProps = Object.assign({}, this.props, newProps);
      checkPropTypes2(newProps, "Goong");
      var viewportChanged = this._updateMapViewport(oldProps, newProps);
      var sizeChanged = this._updateMapSize(oldProps, newProps);
      this._updateMapStyle(oldProps, newProps);
      if (!newProps.asyncRender && (viewportChanged || sizeChanged)) {
        this.redraw();
      }
      this.props = newProps;
    }
  }, {
    key: "_updateMapStyle",
    value: function _updateMapStyle(oldProps, newProps) {
      var styleChanged = oldProps.mapStyle !== newProps.mapStyle;
      if (styleChanged) {
        this._map.setStyle(normalizeStyle(newProps.mapStyle), {
          diff: !newProps.preventStyleDiffing
        });
      }
    }
  }, {
    key: "_updateMapSize",
    value: function _updateMapSize(oldProps, newProps) {
      var sizeChanged = oldProps.width !== newProps.width || oldProps.height !== newProps.height;
      if (sizeChanged) {
        this.width = newProps.width;
        this.height = newProps.height;
        this._map.resize();
      }
      return sizeChanged;
    }
  }, {
    key: "_updateMapViewport",
    value: function _updateMapViewport(oldProps, newProps) {
      var oldViewState = this._getViewState(oldProps);
      var newViewState = this._getViewState(newProps);
      var viewportChanged = newViewState.latitude !== oldViewState.latitude || newViewState.longitude !== oldViewState.longitude || newViewState.zoom !== oldViewState.zoom || newViewState.pitch !== oldViewState.pitch || newViewState.bearing !== oldViewState.bearing || newViewState.altitude !== oldViewState.altitude;
      if (viewportChanged) {
        this._map.jumpTo(this._viewStateToMapboxProps(newViewState));
        if (newViewState.altitude !== oldViewState.altitude) {
          this._map.transform.altitude = newViewState.altitude;
        }
      }
      return viewportChanged;
    }
  }, {
    key: "_getViewState",
    value: function _getViewState(props) {
      var _ref = props.viewState || props, longitude = _ref.longitude, latitude = _ref.latitude, zoom = _ref.zoom, _ref$pitch = _ref.pitch, pitch = _ref$pitch === void 0 ? 0 : _ref$pitch, _ref$bearing = _ref.bearing, bearing = _ref$bearing === void 0 ? 0 : _ref$bearing, _ref$altitude = _ref.altitude, altitude = _ref$altitude === void 0 ? 1.5 : _ref$altitude;
      return {
        longitude,
        latitude,
        zoom,
        pitch,
        bearing,
        altitude
      };
    }
  }, {
    key: "_checkStyleSheet",
    value: function _checkStyleSheet() {
      var goongVersion = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "1.0.6";
      if (typeof document_ === "undefined") {
        return;
      }
      try {
        var testElement = document_.createElement("div");
        testElement.className = "mapboxgl-map";
        testElement.style.display = "none";
        document_.body.appendChild(testElement);
        var isCssLoaded = window.getComputedStyle(testElement).position !== "static";
        if (!isCssLoaded) {
          var link = document_.createElement("link");
          link.setAttribute("rel", "stylesheet");
          link.setAttribute("type", "text/css");
          link.setAttribute("href", "https://cdn.jsdelivr.net/npm/@goongmaps/goong-js@".concat(goongVersion, "/dist/goong-js.css"));
          document_.head.appendChild(link);
        }
      } catch (error) {
      }
    }
  }, {
    key: "_viewStateToMapboxProps",
    value: function _viewStateToMapboxProps(viewState) {
      return {
        center: [viewState.longitude, viewState.latitude],
        zoom: viewState.zoom,
        bearing: viewState.bearing,
        pitch: viewState.pitch
      };
    }
  }]);
  return Goong2;
}();
_defineProperty(Goong, "initialized", false);
_defineProperty(Goong, "propTypes", propTypes);
_defineProperty(Goong, "defaultProps", defaultProps);
_defineProperty(Goong, "savedMap", null);

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/goongmap.browser.js
var import_goong_js = __toESM(require_goong_js());

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/math-utils.js
var EPSILON3 = 1e-7;
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value);
}
function equals2(a, b) {
  if (a === b) {
    return true;
  }
  if (isArray(a) && isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }
    for (var i = 0; i < a.length; ++i) {
      if (!equals2(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  return Math.abs(a - b) <= EPSILON3;
}
function clamp2(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function lerp3(a, b, t) {
  if (isArray(a)) {
    return a.map(function(ai, i) {
      return lerp3(ai, b[i], t);
    });
  }
  return t * b + (1 - t) * a;
}

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/assert.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "react-map-gl: assertion failed.");
  }
}

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/map-state.js
function ownKeys2(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var MAPBOX_LIMITS = {
  minZoom: 0,
  maxZoom: 24,
  minPitch: 0,
  maxPitch: 85
};
var DEFAULT_STATE = {
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};
var PITCH_MOUSE_THRESHOLD = 5;
var PITCH_ACCEL = 1.2;
var MapState = function() {
  function MapState2(_ref) {
    var width = _ref.width, height = _ref.height, latitude = _ref.latitude, longitude = _ref.longitude, zoom = _ref.zoom, _ref$bearing = _ref.bearing, bearing = _ref$bearing === void 0 ? DEFAULT_STATE.bearing : _ref$bearing, _ref$pitch = _ref.pitch, pitch = _ref$pitch === void 0 ? DEFAULT_STATE.pitch : _ref$pitch, _ref$altitude = _ref.altitude, altitude = _ref$altitude === void 0 ? DEFAULT_STATE.altitude : _ref$altitude, _ref$maxZoom = _ref.maxZoom, maxZoom = _ref$maxZoom === void 0 ? MAPBOX_LIMITS.maxZoom : _ref$maxZoom, _ref$minZoom = _ref.minZoom, minZoom = _ref$minZoom === void 0 ? MAPBOX_LIMITS.minZoom : _ref$minZoom, _ref$maxPitch = _ref.maxPitch, maxPitch = _ref$maxPitch === void 0 ? MAPBOX_LIMITS.maxPitch : _ref$maxPitch, _ref$minPitch = _ref.minPitch, minPitch = _ref$minPitch === void 0 ? MAPBOX_LIMITS.minPitch : _ref$minPitch, transitionDuration = _ref.transitionDuration, transitionEasing3 = _ref.transitionEasing, transitionInterpolator = _ref.transitionInterpolator, transitionInterruption = _ref.transitionInterruption, startPanLngLat = _ref.startPanLngLat, startZoomLngLat = _ref.startZoomLngLat, startRotatePos = _ref.startRotatePos, startBearing = _ref.startBearing, startPitch = _ref.startPitch, startZoom = _ref.startZoom;
    _classCallCheck(this, MapState2);
    assert2(Number.isFinite(width), "`width` must be supplied");
    assert2(Number.isFinite(height), "`height` must be supplied");
    assert2(Number.isFinite(longitude), "`longitude` must be supplied");
    assert2(Number.isFinite(latitude), "`latitude` must be supplied");
    assert2(Number.isFinite(zoom), "`zoom` must be supplied");
    this._viewportProps = this._applyConstraints({
      width,
      height,
      latitude,
      longitude,
      zoom,
      bearing,
      pitch,
      altitude,
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
      transitionDuration,
      transitionEasing: transitionEasing3,
      transitionInterpolator,
      transitionInterruption
    });
    this._state = {
      startPanLngLat,
      startZoomLngLat,
      startRotatePos,
      startBearing,
      startPitch,
      startZoom
    };
  }
  _createClass(MapState2, [{
    key: "getViewportProps",
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: "getState",
    value: function getState() {
      return this._state;
    }
  }, {
    key: "panStart",
    value: function panStart(_ref2) {
      var pos = _ref2.pos;
      return this._getUpdatedMapState({
        startPanLngLat: this._unproject(pos)
      });
    }
  }, {
    key: "pan",
    value: function pan(_ref3) {
      var pos = _ref3.pos, startPos = _ref3.startPos;
      var startPanLngLat = this._state.startPanLngLat || this._unproject(startPos);
      if (!startPanLngLat) {
        return this;
      }
      var _this$_calculateNewLn = this._calculateNewLngLat({
        startPanLngLat,
        pos
      }), _this$_calculateNewLn2 = _slicedToArray(_this$_calculateNewLn, 2), longitude = _this$_calculateNewLn2[0], latitude = _this$_calculateNewLn2[1];
      return this._getUpdatedMapState({
        longitude,
        latitude
      });
    }
  }, {
    key: "panEnd",
    value: function panEnd() {
      return this._getUpdatedMapState({
        startPanLngLat: null
      });
    }
  }, {
    key: "rotateStart",
    value: function rotateStart(_ref4) {
      var pos = _ref4.pos;
      return this._getUpdatedMapState({
        startRotatePos: pos,
        startBearing: this._viewportProps.bearing,
        startPitch: this._viewportProps.pitch
      });
    }
  }, {
    key: "rotate",
    value: function rotate(_ref5) {
      var pos = _ref5.pos, _ref5$deltaAngleX = _ref5.deltaAngleX, deltaAngleX = _ref5$deltaAngleX === void 0 ? 0 : _ref5$deltaAngleX, _ref5$deltaAngleY = _ref5.deltaAngleY, deltaAngleY = _ref5$deltaAngleY === void 0 ? 0 : _ref5$deltaAngleY;
      var _this$_state = this._state, startRotatePos = _this$_state.startRotatePos, startBearing = _this$_state.startBearing, startPitch = _this$_state.startPitch;
      if (!Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {
        return this;
      }
      var newRotation;
      if (pos) {
        newRotation = this._calculateNewPitchAndBearing(_objectSpread2(_objectSpread2({}, this._getRotationParams(pos, startRotatePos)), {}, {
          startBearing,
          startPitch
        }));
      } else {
        newRotation = {
          bearing: startBearing + deltaAngleX,
          pitch: startPitch + deltaAngleY
        };
      }
      return this._getUpdatedMapState(newRotation);
    }
  }, {
    key: "rotateEnd",
    value: function rotateEnd() {
      return this._getUpdatedMapState({
        startBearing: null,
        startPitch: null
      });
    }
  }, {
    key: "zoomStart",
    value: function zoomStart(_ref6) {
      var pos = _ref6.pos;
      return this._getUpdatedMapState({
        startZoomLngLat: this._unproject(pos),
        startZoom: this._viewportProps.zoom
      });
    }
  }, {
    key: "zoom",
    value: function zoom(_ref7) {
      var pos = _ref7.pos, startPos = _ref7.startPos, scale4 = _ref7.scale;
      assert2(scale4 > 0, "`scale` must be a positive number");
      var _this$_state2 = this._state, startZoom = _this$_state2.startZoom, startZoomLngLat = _this$_state2.startZoomLngLat;
      if (!Number.isFinite(startZoom)) {
        startZoom = this._viewportProps.zoom;
        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
      }
      assert2(startZoomLngLat, "`startZoomLngLat` prop is required for zoom behavior to calculate where to position the map.");
      var zoom2 = this._calculateNewZoom({
        scale: scale4,
        startZoom: startZoom || 0
      });
      var zoomedViewport = new WebMercatorViewport(Object.assign({}, this._viewportProps, {
        zoom: zoom2
      }));
      var _zoomedViewport$getMa = zoomedViewport.getMapCenterByLngLatPosition({
        lngLat: startZoomLngLat,
        pos
      }), _zoomedViewport$getMa2 = _slicedToArray(_zoomedViewport$getMa, 2), longitude = _zoomedViewport$getMa2[0], latitude = _zoomedViewport$getMa2[1];
      return this._getUpdatedMapState({
        zoom: zoom2,
        longitude,
        latitude
      });
    }
  }, {
    key: "zoomEnd",
    value: function zoomEnd() {
      return this._getUpdatedMapState({
        startZoomLngLat: null,
        startZoom: null
      });
    }
  }, {
    key: "_getUpdatedMapState",
    value: function _getUpdatedMapState(newProps) {
      return new MapState2(Object.assign({}, this._viewportProps, this._state, newProps));
    }
  }, {
    key: "_applyConstraints",
    value: function _applyConstraints(props) {
      var maxZoom = props.maxZoom, minZoom = props.minZoom, zoom = props.zoom;
      props.zoom = clamp2(zoom, minZoom, maxZoom);
      var maxPitch = props.maxPitch, minPitch = props.minPitch, pitch = props.pitch;
      props.pitch = clamp2(pitch, minPitch, maxPitch);
      Object.assign(props, normalizeViewportProps(props));
      return props;
    }
  }, {
    key: "_unproject",
    value: function _unproject(pos) {
      var viewport = new WebMercatorViewport(this._viewportProps);
      return pos && viewport.unproject(pos);
    }
  }, {
    key: "_calculateNewLngLat",
    value: function _calculateNewLngLat(_ref8) {
      var startPanLngLat = _ref8.startPanLngLat, pos = _ref8.pos;
      var viewport = new WebMercatorViewport(this._viewportProps);
      return viewport.getMapCenterByLngLatPosition({
        lngLat: startPanLngLat,
        pos
      });
    }
  }, {
    key: "_calculateNewZoom",
    value: function _calculateNewZoom(_ref9) {
      var scale4 = _ref9.scale, startZoom = _ref9.startZoom;
      var _this$_viewportProps = this._viewportProps, maxZoom = _this$_viewportProps.maxZoom, minZoom = _this$_viewportProps.minZoom;
      var zoom = startZoom + Math.log2(scale4);
      return clamp2(zoom, minZoom, maxZoom);
    }
  }, {
    key: "_calculateNewPitchAndBearing",
    value: function _calculateNewPitchAndBearing(_ref10) {
      var deltaScaleX = _ref10.deltaScaleX, deltaScaleY = _ref10.deltaScaleY, startBearing = _ref10.startBearing, startPitch = _ref10.startPitch;
      deltaScaleY = clamp2(deltaScaleY, -1, 1);
      var _this$_viewportProps2 = this._viewportProps, minPitch = _this$_viewportProps2.minPitch, maxPitch = _this$_viewportProps2.maxPitch;
      var bearing = startBearing + 180 * deltaScaleX;
      var pitch = startPitch;
      if (deltaScaleY > 0) {
        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
      } else if (deltaScaleY < 0) {
        pitch = startPitch - deltaScaleY * (minPitch - startPitch);
      }
      return {
        pitch,
        bearing
      };
    }
  }, {
    key: "_getRotationParams",
    value: function _getRotationParams(pos, startPos) {
      var deltaX = pos[0] - startPos[0];
      var deltaY = pos[1] - startPos[1];
      var centerY = pos[1];
      var startY = startPos[1];
      var _this$_viewportProps3 = this._viewportProps, width = _this$_viewportProps3.width, height = _this$_viewportProps3.height;
      var deltaScaleX = deltaX / width;
      var deltaScaleY = 0;
      if (deltaY > 0) {
        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
        }
      } else if (deltaY < 0) {
        if (startY > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = 1 - centerY / startY;
        }
      }
      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));
      return {
        deltaScaleX,
        deltaScaleY
      };
    }
  }]);
  return MapState2;
}();

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/map-constraints.js
function decapitalize(s) {
  return s[0].toLowerCase() + s.slice(1);
}
function checkVisibilityConstraints(props) {
  var constraints = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : MAPBOX_LIMITS;
  for (var constraintName in constraints) {
    var type = constraintName.slice(0, 3);
    var propName = decapitalize(constraintName.slice(3));
    if (type === "min" && props[propName] < constraints[constraintName]) {
      return false;
    }
    if (type === "max" && props[propName] > constraints[constraintName]) {
      return false;
    }
  }
  return true;
}

// node_modules/@goongmaps/goong-map-react/dist/esm/components/map-context.js
var React = __toESM(require_react());
var import_react = __toESM(require_react());
function ownKeys3(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var MapContext = (0, import_react.createContext)({
  viewport: null,
  map: null,
  container: null,
  onViewportChange: null,
  onViewStateChange: null,
  eventManager: null
});
var MapContextProvider = MapContext.Provider;
function WrappedProvider(_ref) {
  var value = _ref.value, children = _ref.children;
  var _useState = (0, import_react.useState)(null), _useState2 = _slicedToArray(_useState, 2), map = _useState2[0], setMap = _useState2[1];
  var context = (0, import_react.useContext)(MapContext);
  value = _objectSpread3(_objectSpread3({
    setMap
  }, context), {}, {
    map: context && context.map || map
  }, value);
  return React.createElement(MapContextProvider, {
    value
  }, children);
}
MapContext.Provider = WrappedProvider;
var map_context_default = MapContext;

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/use-isomorphic-layout-effect.js
var import_react2 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react2.useLayoutEffect : import_react2.useEffect;
var use_isomorphic_layout_effect_default = useIsomorphicLayoutEffect;

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/terrain.js
function getTerrainElevation(map, _ref) {
  var longitude = _ref.longitude, latitude = _ref.latitude;
  if (map && map.queryTerrainElevation) {
    return map.queryTerrainElevation([longitude, latitude]) || 0;
  }
  return 0;
}

// node_modules/@goongmaps/goong-map-react/dist/esm/components/static-map.js
function ownKeys4(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys4(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var TOKEN_DOC_URL = "https://visgl.github.io/react-map-gl/docs/get-started/mapbox-tokens";
var NO_TOKEN_WARNING = "A valid API access token is required to use Mapbox data";
function noop2() {
}
function getViewport(_ref) {
  var map = _ref.map, props = _ref.props, width = _ref.width, height = _ref.height;
  var viewportProps = _objectSpread4(_objectSpread4(_objectSpread4({}, props), props.viewState), {}, {
    width,
    height
  });
  viewportProps.position = [0, 0, getTerrainElevation(map, viewportProps)];
  return new WebMercatorViewport(viewportProps);
}
var UNAUTHORIZED_ERROR_CODE = 401;
var CONTAINER_STYLE = {
  position: "absolute",
  width: "100%",
  height: "100%",
  overflow: "hidden"
};
var propTypes2 = Object.assign({}, Goong.propTypes, {
  width: PropTypes2.oneOfType([PropTypes2.number, PropTypes2.string]),
  height: PropTypes2.oneOfType([PropTypes2.number, PropTypes2.string]),
  onResize: PropTypes2.func,
  disableTokenWarning: PropTypes2.bool,
  visible: PropTypes2.bool,
  className: PropTypes2.string,
  style: PropTypes2.object,
  visibilityConstraints: PropTypes2.object
});
var defaultProps2 = Object.assign({}, Goong.defaultProps, {
  disableTokenWarning: false,
  visible: true,
  onResize: noop2,
  className: "",
  style: null,
  visibilityConstraints: MAPBOX_LIMITS
});
function NoTokenWarning() {
  var style = {
    position: "absolute",
    left: 0,
    top: 0
  };
  return React2.createElement("div", {
    key: "warning",
    id: "no-token-warning",
    style
  }, React2.createElement("h3", {
    key: "header"
  }, NO_TOKEN_WARNING), React2.createElement("div", {
    key: "text"
  }, "For information on setting up your basemap, read"), React2.createElement("a", {
    key: "link",
    href: TOKEN_DOC_URL
  }, "Note on Map Tokens"));
}
function getRefHandles(mapboxRef) {
  return {
    getMap: function getMap() {
      return mapboxRef.current && mapboxRef.current.getMap();
    },
    queryRenderedFeatures: function queryRenderedFeatures(geometry) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var map = mapboxRef.current && mapboxRef.current.getMap();
      return map && map.queryRenderedFeatures(geometry, options);
    }
  };
}
var StaticMap = (0, import_react3.forwardRef)(function(props, ref) {
  var _useState = (0, import_react3.useState)(true), _useState2 = _slicedToArray(_useState, 2), accessTokenValid = _useState2[0], setTokenState = _useState2[1];
  var _useState3 = (0, import_react3.useState)({
    width: 0,
    height: 0
  }), _useState4 = _slicedToArray(_useState3, 2), size = _useState4[0], setSize = _useState4[1];
  var mapboxRef = (0, import_react3.useRef)(null);
  var mapDivRef = (0, import_react3.useRef)(null);
  var containerRef = (0, import_react3.useRef)(null);
  var overlayRef = (0, import_react3.useRef)(null);
  var context = (0, import_react3.useContext)(map_context_default);
  use_isomorphic_layout_effect_default(function() {
    if (!StaticMap.supported()) {
      return void 0;
    }
    var mapbox = new Goong(_objectSpread4(_objectSpread4(_objectSpread4({}, props), size), {}, {
      mapboxgl: import_goong_js.default,
      container: mapDivRef.current,
      onError: function onError(evt) {
        var statusCode = evt.error && evt.error.status || evt.status;
        if (statusCode === UNAUTHORIZED_ERROR_CODE && accessTokenValid) {
          console.error(NO_TOKEN_WARNING);
          setTokenState(false);
        }
        props.onError(evt);
      }
    }));
    mapboxRef.current = mapbox;
    if (context && context.setMap) {
      context.setMap(mapbox.getMap());
    }
    var resizeObserver = new ResizeObserver_es_default(function(entries) {
      if (entries[0].contentRect) {
        var _entries$0$contentRec = entries[0].contentRect, _width = _entries$0$contentRec.width, _height = _entries$0$contentRec.height;
        setSize({
          width: _width,
          height: _height
        });
        props.onResize({
          width: _width,
          height: _height
        });
      }
    });
    resizeObserver.observe(containerRef.current);
    return function() {
      mapbox.finalize();
      mapboxRef.current = null;
      resizeObserver.disconnect();
    };
  }, []);
  use_isomorphic_layout_effect_default(function() {
    if (mapboxRef.current) {
      mapboxRef.current.setProps(_objectSpread4(_objectSpread4({}, props), size));
    }
  });
  var map = mapboxRef.current && mapboxRef.current.getMap();
  (0, import_react3.useImperativeHandle)(ref, function() {
    return getRefHandles(mapboxRef);
  }, []);
  var preventScroll = (0, import_react3.useCallback)(function(_ref2) {
    var target = _ref2.target;
    if (target === overlayRef.current) {
      target.scrollTo(0, 0);
    }
  }, []);
  var overlays = map && React2.createElement(MapContextProvider, {
    value: _objectSpread4(_objectSpread4({}, context), {}, {
      viewport: context.viewport || getViewport(_objectSpread4({
        map,
        props
      }, size)),
      map,
      container: context.container || containerRef.current
    })
  }, React2.createElement("div", {
    key: "map-overlays",
    className: "overlays",
    ref: overlayRef,
    style: CONTAINER_STYLE,
    onScroll: preventScroll
  }, props.children));
  var className = props.className, width = props.width, height = props.height, style = props.style, visibilityConstraints = props.visibilityConstraints;
  var mapContainerStyle = Object.assign({
    position: "relative"
  }, style, {
    width,
    height
  });
  var visible = props.visible && checkVisibilityConstraints(props.viewState || props, visibilityConstraints);
  var mapStyle = Object.assign({}, CONTAINER_STYLE, {
    visibility: visible ? "inherit" : "hidden"
  });
  return React2.createElement("div", {
    key: "map-container",
    ref: containerRef,
    style: mapContainerStyle
  }, React2.createElement("div", {
    key: "map-mapbox",
    ref: mapDivRef,
    style: mapStyle,
    className
  }), overlays, !accessTokenValid && !props.disableTokenWarning && React2.createElement(NoTokenWarning, null));
});
StaticMap.supported = function() {
  return import_goong_js.default && import_goong_js.default.supported();
};
StaticMap.propTypes = propTypes2;
StaticMap.defaultProps = defaultProps2;
var static_map_default = StaticMap;

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/transition/transition-interpolator.js
function _createForOfIteratorHelper2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray3(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray3(o, minLen);
}
function _arrayLikeToArray3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var TransitionInterpolator = function() {
  function TransitionInterpolator2() {
    _classCallCheck(this, TransitionInterpolator2);
    _defineProperty(this, "propNames", []);
  }
  _createClass(TransitionInterpolator2, [{
    key: "arePropsEqual",
    value: function arePropsEqual(currentProps, nextProps) {
      var _iterator = _createForOfIteratorHelper2(this.propNames || []), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var key = _step.value;
          if (!equals2(currentProps[key], nextProps[key])) {
            return false;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return true;
    }
  }, {
    key: "initializeProps",
    value: function initializeProps(startProps, endProps) {
      return {
        start: startProps,
        end: endProps
      };
    }
  }, {
    key: "interpolateProps",
    value: function interpolateProps(startProps, endProps, t) {
      assert2(false, "interpolateProps is not implemented");
    }
  }, {
    key: "getDuration",
    value: function getDuration(startProps, endProps) {
      return endProps.transitionDuration;
    }
  }]);
  return TransitionInterpolator2;
}();

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/transition/transition-utils.js
var WRAPPED_ANGULAR_PROPS = {
  longitude: 1,
  bearing: 1
};
function isValid(prop) {
  return Number.isFinite(prop) || Array.isArray(prop);
}
function isWrappedAngularProp(propName) {
  return propName in WRAPPED_ANGULAR_PROPS;
}
function getEndValueByShortestPath(propName, startValue, endValue) {
  if (isWrappedAngularProp(propName) && Math.abs(endValue - startValue) > 180) {
    endValue = endValue < 0 ? endValue + 360 : endValue - 360;
  }
  return endValue;
}

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/transition/viewport-fly-to-interpolator.js
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var VIEWPORT_TRANSITION_PROPS2 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
var REQUIRED_PROPS = ["latitude", "longitude", "zoom", "width", "height"];
var LINEARLY_INTERPOLATED_PROPS = ["bearing", "pitch"];
var DEFAULT_OPTS2 = {
  speed: 1.2,
  curve: 1.414
};
var ViewportFlyToInterpolator = function(_TransitionInterpolat) {
  _inherits(ViewportFlyToInterpolator2, _TransitionInterpolat);
  var _super = _createSuper(ViewportFlyToInterpolator2);
  function ViewportFlyToInterpolator2() {
    var _this;
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, ViewportFlyToInterpolator2);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), "propNames", VIEWPORT_TRANSITION_PROPS2);
    _this.props = Object.assign({}, DEFAULT_OPTS2, props);
    return _this;
  }
  _createClass(ViewportFlyToInterpolator2, [{
    key: "initializeProps",
    value: function initializeProps(startProps, endProps) {
      var startViewportProps = {};
      var endViewportProps = {};
      for (var _i = 0, _REQUIRED_PROPS = REQUIRED_PROPS; _i < _REQUIRED_PROPS.length; _i++) {
        var key = _REQUIRED_PROPS[_i];
        var startValue = startProps[key];
        var endValue = endProps[key];
        assert2(isValid(startValue) && isValid(endValue), "".concat(key, " must be supplied for transition"));
        startViewportProps[key] = startValue;
        endViewportProps[key] = getEndValueByShortestPath(key, startValue, endValue);
      }
      for (var _i2 = 0, _LINEARLY_INTERPOLATE = LINEARLY_INTERPOLATED_PROPS; _i2 < _LINEARLY_INTERPOLATE.length; _i2++) {
        var _key = _LINEARLY_INTERPOLATE[_i2];
        var _startValue = startProps[_key] || 0;
        var _endValue = endProps[_key] || 0;
        startViewportProps[_key] = _startValue;
        endViewportProps[_key] = getEndValueByShortestPath(_key, _startValue, _endValue);
      }
      return {
        start: startViewportProps,
        end: endViewportProps
      };
    }
  }, {
    key: "interpolateProps",
    value: function interpolateProps(startProps, endProps, t) {
      var viewport = flyToViewport(startProps, endProps, t, this.props);
      for (var _i3 = 0, _LINEARLY_INTERPOLATE2 = LINEARLY_INTERPOLATED_PROPS; _i3 < _LINEARLY_INTERPOLATE2.length; _i3++) {
        var key = _LINEARLY_INTERPOLATE2[_i3];
        viewport[key] = lerp3(startProps[key], endProps[key], t);
      }
      return viewport;
    }
  }, {
    key: "getDuration",
    value: function getDuration(startProps, endProps) {
      var transitionDuration = endProps.transitionDuration;
      if (transitionDuration === "auto") {
        transitionDuration = getFlyToDuration(startProps, endProps, this.props);
      }
      return transitionDuration;
    }
  }]);
  return ViewportFlyToInterpolator2;
}(TransitionInterpolator);

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/transition/linear-interpolator.js
function _createForOfIteratorHelper3(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray4(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray4(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray4(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray4(o, minLen);
}
function _arrayLikeToArray4(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createSuper2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var VIEWPORT_TRANSITION_PROPS3 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
var LinearInterpolator = function(_TransitionInterpolat) {
  _inherits(LinearInterpolator2, _TransitionInterpolat);
  var _super = _createSuper2(LinearInterpolator2);
  function LinearInterpolator2() {
    var _this;
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, LinearInterpolator2);
    _this = _super.call(this);
    if (Array.isArray(opts)) {
      opts = {
        transitionProps: opts
      };
    }
    _this.propNames = opts.transitionProps || VIEWPORT_TRANSITION_PROPS3;
    if (opts.around) {
      _this.around = opts.around;
    }
    return _this;
  }
  _createClass(LinearInterpolator2, [{
    key: "initializeProps",
    value: function initializeProps(startProps, endProps) {
      var startViewportProps = {};
      var endViewportProps = {};
      if (this.around) {
        startViewportProps.around = this.around;
        var aroundLngLat = new WebMercatorViewport(startProps).unproject(this.around);
        Object.assign(endViewportProps, endProps, {
          around: new WebMercatorViewport(endProps).project(aroundLngLat),
          aroundLngLat
        });
      }
      var _iterator = _createForOfIteratorHelper3(this.propNames), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var key = _step.value;
          var startValue = startProps[key];
          var endValue = endProps[key];
          assert2(isValid(startValue) && isValid(endValue), "".concat(key, " must be supplied for transition"));
          startViewportProps[key] = startValue;
          endViewportProps[key] = getEndValueByShortestPath(key, startValue, endValue);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return {
        start: startViewportProps,
        end: endViewportProps
      };
    }
  }, {
    key: "interpolateProps",
    value: function interpolateProps(startProps, endProps, t) {
      var viewport = {};
      var _iterator2 = _createForOfIteratorHelper3(this.propNames), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var key = _step2.value;
          viewport[key] = lerp3(startProps[key], endProps[key], t);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (endProps.around) {
        var _WebMercatorViewport$ = new WebMercatorViewport(Object.assign({}, endProps, viewport)).getMapCenterByLngLatPosition({
          lngLat: endProps.aroundLngLat,
          pos: lerp3(startProps.around, endProps.around, t)
        }), _WebMercatorViewport$2 = _slicedToArray(_WebMercatorViewport$, 2), longitude = _WebMercatorViewport$2[0], latitude = _WebMercatorViewport$2[1];
        viewport.longitude = longitude;
        viewport.latitude = latitude;
      }
      return viewport;
    }
  }]);
  return LinearInterpolator2;
}(TransitionInterpolator);

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/transition-manager.js
var noop3 = function noop4() {
};
function cropEasingFunction(easing, x0) {
  var y0 = easing(x0);
  return function(t) {
    return 1 / (1 - y0) * (easing(t * (1 - x0) + x0) - y0);
  };
}
var TRANSITION_EVENTS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3,
  UPDATE: 4
};
var DEFAULT_PROPS = {
  transitionDuration: 0,
  transitionEasing: function transitionEasing(t) {
    return t;
  },
  transitionInterpolator: new LinearInterpolator(),
  transitionInterruption: TRANSITION_EVENTS.BREAK,
  onTransitionStart: noop3,
  onTransitionInterrupt: noop3,
  onTransitionEnd: noop3
};
var TransitionManager = function() {
  function TransitionManager2() {
    var _this = this;
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, TransitionManager2);
    _defineProperty(this, "_animationFrame", null);
    _defineProperty(this, "_onTransitionFrame", function() {
      _this._animationFrame = requestAnimationFrame(_this._onTransitionFrame);
      _this._updateViewport();
    });
    this.props = null;
    this.onViewportChange = opts.onViewportChange || noop3;
    this.onStateChange = opts.onStateChange || noop3;
    this.time = opts.getTime || Date.now;
  }
  _createClass(TransitionManager2, [{
    key: "getViewportInTransition",
    value: function getViewportInTransition() {
      return this._animationFrame ? this.state.propsInTransition : null;
    }
  }, {
    key: "processViewportChange",
    value: function processViewportChange(nextProps) {
      var currentProps = this.props;
      this.props = nextProps;
      if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
        return false;
      }
      if (this._isTransitionEnabled(nextProps)) {
        var startProps = Object.assign({}, currentProps);
        var endProps = Object.assign({}, nextProps);
        if (this._isTransitionInProgress()) {
          currentProps.onTransitionInterrupt();
          if (this.state.interruption === TRANSITION_EVENTS.SNAP_TO_END) {
            Object.assign(startProps, this.state.endProps);
          } else {
            Object.assign(startProps, this.state.propsInTransition);
          }
          if (this.state.interruption === TRANSITION_EVENTS.UPDATE) {
            var currentTime = this.time();
            var x0 = (currentTime - this.state.startTime) / this.state.duration;
            endProps.transitionDuration = this.state.duration - (currentTime - this.state.startTime);
            endProps.transitionEasing = cropEasingFunction(this.state.easing, x0);
            endProps.transitionInterpolator = startProps.transitionInterpolator;
          }
        }
        endProps.onTransitionStart();
        this._triggerTransition(startProps, endProps);
        return true;
      }
      if (this._isTransitionInProgress()) {
        currentProps.onTransitionInterrupt();
        this._endTransition();
      }
      return false;
    }
  }, {
    key: "_isTransitionInProgress",
    value: function _isTransitionInProgress() {
      return Boolean(this._animationFrame);
    }
  }, {
    key: "_isTransitionEnabled",
    value: function _isTransitionEnabled(props) {
      var transitionDuration = props.transitionDuration, transitionInterpolator = props.transitionInterpolator;
      return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
    }
  }, {
    key: "_isUpdateDueToCurrentTransition",
    value: function _isUpdateDueToCurrentTransition(props) {
      if (this.state.propsInTransition) {
        return this.state.interpolator.arePropsEqual(props, this.state.propsInTransition);
      }
      return false;
    }
  }, {
    key: "_shouldIgnoreViewportChange",
    value: function _shouldIgnoreViewportChange(currentProps, nextProps) {
      if (!currentProps) {
        return true;
      }
      if (this._isTransitionInProgress()) {
        return this.state.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
      }
      if (this._isTransitionEnabled(nextProps)) {
        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
      }
      return true;
    }
  }, {
    key: "_triggerTransition",
    value: function _triggerTransition(startProps, endProps) {
      assert2(this._isTransitionEnabled(endProps));
      if (this._animationFrame) {
        cancelAnimationFrame(this._animationFrame);
      }
      var transitionInterpolator = endProps.transitionInterpolator;
      var duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
      if (duration === 0) {
        return;
      }
      var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endProps);
      var interactionState = {
        inTransition: true,
        isZooming: startProps.zoom !== endProps.zoom,
        isPanning: startProps.longitude !== endProps.longitude || startProps.latitude !== endProps.latitude,
        isRotating: startProps.bearing !== endProps.bearing || startProps.pitch !== endProps.pitch
      };
      this.state = {
        duration,
        easing: endProps.transitionEasing,
        interpolator: endProps.transitionInterpolator,
        interruption: endProps.transitionInterruption,
        startTime: this.time(),
        startProps: initialProps.start,
        endProps: initialProps.end,
        animation: null,
        propsInTransition: {}
      };
      this._onTransitionFrame();
      this.onStateChange(interactionState);
    }
  }, {
    key: "_endTransition",
    value: function _endTransition() {
      if (this._animationFrame) {
        cancelAnimationFrame(this._animationFrame);
        this._animationFrame = null;
      }
      this.onStateChange({
        inTransition: false,
        isZooming: false,
        isPanning: false,
        isRotating: false
      });
    }
  }, {
    key: "_updateViewport",
    value: function _updateViewport() {
      var currentTime = this.time();
      var _this$state = this.state, startTime = _this$state.startTime, duration = _this$state.duration, easing = _this$state.easing, interpolator = _this$state.interpolator, startProps = _this$state.startProps, endProps = _this$state.endProps;
      var shouldEnd = false;
      var t = (currentTime - startTime) / duration;
      if (t >= 1) {
        t = 1;
        shouldEnd = true;
      }
      t = easing(t);
      var viewport = interpolator.interpolateProps(startProps, endProps, t);
      var mapState = new MapState(Object.assign({}, this.props, viewport));
      this.state.propsInTransition = mapState.getViewportProps();
      this.onViewportChange(this.state.propsInTransition, this.props);
      if (shouldEnd) {
        this._endTransition();
        this.props.onTransitionEnd();
      }
    }
  }]);
  return TransitionManager2;
}();
_defineProperty(TransitionManager, "defaultProps", DEFAULT_PROPS);

// node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
var hammerjs = __toESM(require_hammer());

// node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js
var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};
function some(array2, predict) {
  for (let i = 0; i < array2.length; i++) {
    if (predict(array2[i])) {
      return true;
    }
  }
  return false;
}
function enhancePointerEventInput(PointerEventInput2) {
  const oldHandler = PointerEventInput2.prototype.handler;
  PointerEventInput2.prototype.handler = function handler(ev) {
    const store = this.store;
    if (ev.button > 0 && ev.type === "pointerdown") {
      if (!some(store, (e) => e.pointerId === ev.pointerId)) {
        store.push(ev);
      }
    }
    oldHandler.call(this, ev);
  };
}
function enhanceMouseInput(MouseInput2) {
  MouseInput2.prototype.handler = function handler(ev) {
    let eventType = MOUSE_INPUT_MAP[ev.type];
    if (eventType & INPUT_START && ev.button >= 0) {
      this.pressed = true;
    }
    if (eventType & INPUT_MOVE && ev.which === 0) {
      eventType = INPUT_END;
    }
    if (!this.pressed) {
      return;
    }
    if (eventType & INPUT_END) {
      this.pressed = false;
    }
    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: "mouse",
      srcEvent: ev
    });
  };
}

// node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
enhancePointerEventInput(hammerjs.PointerEventInput);
enhanceMouseInput(hammerjs.MouseInput);
var Manager2 = hammerjs.Manager;
var hammer_browser_default = hammerjs;

// node_modules/mjolnir.js/dist/esm/inputs/input.js
var Input = class {
  constructor(element, callback, options) {
    this.element = element;
    this.callback = callback;
    this.options = { enable: true, ...options };
  }
};

// node_modules/mjolnir.js/dist/esm/constants.js
var RECOGNIZERS = hammer_browser_default ? [
  [hammer_browser_default.Pan, { event: "tripan", pointers: 3, threshold: 0, enable: false }],
  [hammer_browser_default.Rotate, { enable: false }],
  [hammer_browser_default.Pinch, { enable: false }],
  [hammer_browser_default.Swipe, { enable: false }],
  [hammer_browser_default.Pan, { threshold: 0, enable: false }],
  [hammer_browser_default.Press, { enable: false }],
  [hammer_browser_default.Tap, { event: "doubletap", taps: 2, enable: false }],
  // TODO - rename to 'tap' and 'singletap' in the next major release
  [hammer_browser_default.Tap, { event: "anytap", enable: false }],
  [hammer_browser_default.Tap, { enable: false }]
] : null;
var RECOGNIZER_COMPATIBLE_MAP = {
  tripan: ["rotate", "pinch", "pan"],
  rotate: ["pinch"],
  pinch: ["pan"],
  pan: ["press", "doubletap", "anytap", "tap"],
  doubletap: ["anytap"],
  anytap: ["tap"]
};
var RECOGNIZER_FALLBACK_MAP = {
  doubletap: ["tap"]
};
var BASIC_EVENT_ALIASES = {
  pointerdown: "pointerdown",
  pointermove: "pointermove",
  pointerup: "pointerup",
  touchstart: "pointerdown",
  touchmove: "pointermove",
  touchend: "pointerup",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup"
};
var INPUT_EVENT_TYPES = {
  KEY_EVENTS: ["keydown", "keyup"],
  MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
  WHEEL_EVENTS: [
    // Chrome, Safari
    "wheel",
    // IE
    "mousewheel"
  ]
};
var EVENT_RECOGNIZER_MAP = {
  tap: "tap",
  anytap: "anytap",
  doubletap: "doubletap",
  press: "press",
  pinch: "pinch",
  pinchin: "pinch",
  pinchout: "pinch",
  pinchstart: "pinch",
  pinchmove: "pinch",
  pinchend: "pinch",
  pinchcancel: "pinch",
  rotate: "rotate",
  rotatestart: "rotate",
  rotatemove: "rotate",
  rotateend: "rotate",
  rotatecancel: "rotate",
  tripan: "tripan",
  tripanstart: "tripan",
  tripanmove: "tripan",
  tripanup: "tripan",
  tripandown: "tripan",
  tripanleft: "tripan",
  tripanright: "tripan",
  tripanend: "tripan",
  tripancancel: "tripan",
  pan: "pan",
  panstart: "pan",
  panmove: "pan",
  panup: "pan",
  pandown: "pan",
  panleft: "pan",
  panright: "pan",
  panend: "pan",
  pancancel: "pan",
  swipe: "swipe",
  swipeleft: "swipe",
  swiperight: "swipe",
  swipeup: "swipe",
  swipedown: "swipe"
};
var GESTURE_EVENT_ALIASES = {
  click: "tap",
  anyclick: "anytap",
  dblclick: "doubletap",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup",
  mouseover: "pointerover",
  mouseout: "pointerout",
  mouseleave: "pointerleave"
};

// node_modules/mjolnir.js/dist/esm/utils/globals.js
var userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
var window_2 = typeof window !== "undefined" ? window : global;
var passiveSupported = false;
try {
  const options = {
    // This function will be called when the browser
    // attempts to access the passive property.
    get passive() {
      passiveSupported = true;
      return true;
    }
  };
  window_2.addEventListener("test", null, options);
  window_2.removeEventListener("test", null);
} catch (err) {
  passiveSupported = false;
}

// node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js
var firefox = userAgent.indexOf("firefox") !== -1;
var { WHEEL_EVENTS } = INPUT_EVENT_TYPES;
var EVENT_TYPE = "wheel";
var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
var WHEEL_DELTA_PER_LINE = 40;
var SHIFT_MULTIPLIER = 0.25;
var WheelInput = class extends Input {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = (event) => {
      if (!this.options.enable) {
        return;
      }
      let value = event.deltaY;
      if (window_2.WheelEvent) {
        if (firefox && event.deltaMode === window_2.WheelEvent.DOM_DELTA_PIXEL) {
          value /= window_2.devicePixelRatio;
        }
        if (event.deltaMode === window_2.WheelEvent.DOM_DELTA_LINE) {
          value *= WHEEL_DELTA_PER_LINE;
        }
      }
      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
      }
      if (event.shiftKey && value) {
        value = value * SHIFT_MULTIPLIER;
      }
      this.callback({
        type: EVENT_TYPE,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        delta: -value,
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    };
    this.events = (this.options.events || []).concat(WHEEL_EVENTS);
    this.events.forEach((event) => element.addEventListener(event, this.handleEvent, passiveSupported ? { passive: false } : false));
  }
  destroy() {
    this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === EVENT_TYPE) {
      this.options.enable = enabled;
    }
  }
};

// node_modules/mjolnir.js/dist/esm/inputs/move-input.js
var { MOUSE_EVENTS } = INPUT_EVENT_TYPES;
var MOVE_EVENT_TYPE = "pointermove";
var OVER_EVENT_TYPE = "pointerover";
var OUT_EVENT_TYPE = "pointerout";
var ENTER_EVENT_TYPE = "pointerenter";
var LEAVE_EVENT_TYPE = "pointerleave";
var MoveInput = class extends Input {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = (event) => {
      this.handleOverEvent(event);
      this.handleOutEvent(event);
      this.handleEnterEvent(event);
      this.handleLeaveEvent(event);
      this.handleMoveEvent(event);
    };
    this.pressed = false;
    const { enable } = this.options;
    this.enableMoveEvent = enable;
    this.enableLeaveEvent = enable;
    this.enableEnterEvent = enable;
    this.enableOutEvent = enable;
    this.enableOverEvent = enable;
    this.events = (this.options.events || []).concat(MOUSE_EVENTS);
    this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
  }
  destroy() {
    this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === MOVE_EVENT_TYPE) {
      this.enableMoveEvent = enabled;
    }
    if (eventType === OVER_EVENT_TYPE) {
      this.enableOverEvent = enabled;
    }
    if (eventType === OUT_EVENT_TYPE) {
      this.enableOutEvent = enabled;
    }
    if (eventType === ENTER_EVENT_TYPE) {
      this.enableEnterEvent = enabled;
    }
    if (eventType === LEAVE_EVENT_TYPE) {
      this.enableLeaveEvent = enabled;
    }
  }
  handleOverEvent(event) {
    if (this.enableOverEvent) {
      if (event.type === "mouseover") {
        this._emit(OVER_EVENT_TYPE, event);
      }
    }
  }
  handleOutEvent(event) {
    if (this.enableOutEvent) {
      if (event.type === "mouseout") {
        this._emit(OUT_EVENT_TYPE, event);
      }
    }
  }
  handleEnterEvent(event) {
    if (this.enableEnterEvent) {
      if (event.type === "mouseenter") {
        this._emit(ENTER_EVENT_TYPE, event);
      }
    }
  }
  handleLeaveEvent(event) {
    if (this.enableLeaveEvent) {
      if (event.type === "mouseleave") {
        this._emit(LEAVE_EVENT_TYPE, event);
      }
    }
  }
  handleMoveEvent(event) {
    if (this.enableMoveEvent) {
      switch (event.type) {
        case "mousedown":
          if (event.button >= 0) {
            this.pressed = true;
          }
          break;
        case "mousemove":
          if (event.which === 0) {
            this.pressed = false;
          }
          if (!this.pressed) {
            this._emit(MOVE_EVENT_TYPE, event);
          }
          break;
        case "mouseup":
          this.pressed = false;
          break;
        default:
      }
    }
  }
  _emit(type, event) {
    this.callback({
      type,
      center: {
        x: event.clientX,
        y: event.clientY
      },
      srcEvent: event,
      pointerType: "mouse",
      target: event.target
    });
  }
};

// node_modules/mjolnir.js/dist/esm/inputs/key-input.js
var { KEY_EVENTS } = INPUT_EVENT_TYPES;
var DOWN_EVENT_TYPE = "keydown";
var UP_EVENT_TYPE = "keyup";
var KeyInput = class extends Input {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = (event) => {
      const targetElement = event.target || event.srcElement;
      if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") {
        return;
      }
      if (this.enableDownEvent && event.type === "keydown") {
        this.callback({
          type: DOWN_EVENT_TYPE,
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
      if (this.enableUpEvent && event.type === "keyup") {
        this.callback({
          type: UP_EVENT_TYPE,
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
    };
    this.enableDownEvent = this.options.enable;
    this.enableUpEvent = this.options.enable;
    this.events = (this.options.events || []).concat(KEY_EVENTS);
    element.tabIndex = this.options.tabIndex || 0;
    element.style.outline = "none";
    this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
  }
  destroy() {
    this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === DOWN_EVENT_TYPE) {
      this.enableDownEvent = enabled;
    }
    if (eventType === UP_EVENT_TYPE) {
      this.enableUpEvent = enabled;
    }
  }
};

// node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js
var EVENT_TYPE2 = "contextmenu";
var ContextmenuInput = class extends Input {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = (event) => {
      if (!this.options.enable) {
        return;
      }
      this.callback({
        type: EVENT_TYPE2,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    };
    element.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === EVENT_TYPE2) {
      this.options.enable = enabled;
    }
  }
};

// node_modules/mjolnir.js/dist/esm/utils/event-utils.js
var DOWN_EVENT = 1;
var MOVE_EVENT = 2;
var UP_EVENT = 4;
var MOUSE_EVENTS2 = {
  pointerdown: DOWN_EVENT,
  pointermove: MOVE_EVENT,
  pointerup: UP_EVENT,
  mousedown: DOWN_EVENT,
  mousemove: MOVE_EVENT,
  mouseup: UP_EVENT
};
var MOUSE_EVENT_WHICH_LEFT = 1;
var MOUSE_EVENT_WHICH_MIDDLE = 2;
var MOUSE_EVENT_WHICH_RIGHT = 3;
var MOUSE_EVENT_BUTTON_LEFT = 0;
var MOUSE_EVENT_BUTTON_MIDDLE = 1;
var MOUSE_EVENT_BUTTON_RIGHT = 2;
var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
function whichButtons(event) {
  const eventType = MOUSE_EVENTS2[event.srcEvent.type];
  if (!eventType) {
    return null;
  }
  const { buttons, button, which } = event.srcEvent;
  let leftButton = false;
  let middleButton = false;
  let rightButton = false;
  if (
    // button is up, need to find out which one was pressed before
    eventType === UP_EVENT || // moving but does not support `buttons` API
    eventType === MOVE_EVENT && !Number.isFinite(buttons)
  ) {
    leftButton = which === MOUSE_EVENT_WHICH_LEFT;
    middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
    rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
  } else if (eventType === MOVE_EVENT) {
    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
  } else if (eventType === DOWN_EVENT) {
    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
  }
  return { leftButton, middleButton, rightButton };
}
function getOffsetPosition(event, rootElement) {
  const center = event.center;
  if (!center) {
    return null;
  }
  const rect = rootElement.getBoundingClientRect();
  const scaleX = rect.width / rootElement.offsetWidth || 1;
  const scaleY = rect.height / rootElement.offsetHeight || 1;
  const offsetCenter = {
    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,
    y: (center.y - rect.top - rootElement.clientTop) / scaleY
  };
  return { center, offsetCenter };
}

// node_modules/mjolnir.js/dist/esm/utils/event-registrar.js
var DEFAULT_OPTIONS = {
  srcElement: "root",
  priority: 0
};
var EventRegistrar = class {
  constructor(eventManager) {
    this.handleEvent = (event) => {
      if (this.isEmpty()) {
        return;
      }
      const mjolnirEvent = this._normalizeEvent(event);
      let target = event.srcEvent.target;
      while (target && target !== mjolnirEvent.rootElement) {
        this._emit(mjolnirEvent, target);
        if (mjolnirEvent.handled) {
          return;
        }
        target = target.parentNode;
      }
      this._emit(mjolnirEvent, "root");
    };
    this.eventManager = eventManager;
    this.handlers = [];
    this.handlersByElement = /* @__PURE__ */ new Map();
    this._active = false;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(type, handler, options, once = false, passive = false) {
    const { handlers, handlersByElement } = this;
    let opts = DEFAULT_OPTIONS;
    if (typeof options === "string" || options && options.addEventListener) {
      opts = { ...DEFAULT_OPTIONS, srcElement: options };
    } else if (options) {
      opts = { ...DEFAULT_OPTIONS, ...options };
    }
    let entries = handlersByElement.get(opts.srcElement);
    if (!entries) {
      entries = [];
      handlersByElement.set(opts.srcElement, entries);
    }
    const entry = {
      type,
      handler,
      srcElement: opts.srcElement,
      priority: opts.priority
    };
    if (once) {
      entry.once = true;
    }
    if (passive) {
      entry.passive = true;
    }
    handlers.push(entry);
    this._active = this._active || !entry.passive;
    let insertPosition = entries.length - 1;
    while (insertPosition >= 0) {
      if (entries[insertPosition].priority >= entry.priority) {
        break;
      }
      insertPosition--;
    }
    entries.splice(insertPosition + 1, 0, entry);
  }
  remove(type, handler) {
    const { handlers, handlersByElement } = this;
    for (let i = handlers.length - 1; i >= 0; i--) {
      const entry = handlers[i];
      if (entry.type === type && entry.handler === handler) {
        handlers.splice(i, 1);
        const entries = handlersByElement.get(entry.srcElement);
        entries.splice(entries.indexOf(entry), 1);
        if (entries.length === 0) {
          handlersByElement.delete(entry.srcElement);
        }
      }
    }
    this._active = handlers.some((entry) => !entry.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(event, srcElement) {
    const entries = this.handlersByElement.get(srcElement);
    if (entries) {
      let immediatePropagationStopped = false;
      const stopPropagation = () => {
        event.handled = true;
      };
      const stopImmediatePropagation = () => {
        event.handled = true;
        immediatePropagationStopped = true;
      };
      const entriesToRemove = [];
      for (let i = 0; i < entries.length; i++) {
        const { type, handler, once } = entries[i];
        handler({
          ...event,
          // @ts-ignore
          type,
          stopPropagation,
          stopImmediatePropagation
        });
        if (once) {
          entriesToRemove.push(entries[i]);
        }
        if (immediatePropagationStopped) {
          break;
        }
      }
      for (let i = 0; i < entriesToRemove.length; i++) {
        const { type, handler } = entriesToRemove[i];
        this.remove(type, handler);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(event) {
    const rootElement = this.eventManager.getElement();
    return {
      ...event,
      ...whichButtons(event),
      ...getOffsetPosition(event, rootElement),
      preventDefault: () => {
        event.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: false,
      rootElement
    };
  }
};

// node_modules/mjolnir.js/dist/esm/event-manager.js
var DEFAULT_OPTIONS2 = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  recognizerOptions: {},
  // Manager class
  Manager: Manager2,
  // allow browser default touch action
  // https://github.com/uber/react-map-gl/issues/506
  touchAction: "none",
  tabIndex: 0
};
var EventManager = class {
  constructor(element = null, options) {
    this._onBasicInput = (event) => {
      const { srcEvent } = event;
      const alias = BASIC_EVENT_ALIASES[srcEvent.type];
      if (alias) {
        this.manager.emit(alias, event);
      }
    };
    this._onOtherEvent = (event) => {
      this.manager.emit(event.type, event);
    };
    this.options = { ...DEFAULT_OPTIONS2, ...options };
    this.events = /* @__PURE__ */ new Map();
    this.setElement(element);
    const { events } = this.options;
    if (events) {
      this.on(events);
    }
  }
  getElement() {
    return this.element;
  }
  setElement(element) {
    if (this.element) {
      this.destroy();
    }
    this.element = element;
    if (!element) {
      return;
    }
    const { options } = this;
    const ManagerClass = options.Manager;
    this.manager = new ManagerClass(element, {
      touchAction: options.touchAction,
      recognizers: options.recognizers || RECOGNIZERS
    }).on("hammer.input", this._onBasicInput);
    if (!options.recognizers) {
      Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach((name) => {
        const recognizer = this.manager.get(name);
        if (recognizer) {
          RECOGNIZER_COMPATIBLE_MAP[name].forEach((otherName) => {
            recognizer.recognizeWith(otherName);
          });
        }
      });
    }
    for (const recognizerName in options.recognizerOptions) {
      const recognizer = this.manager.get(recognizerName);
      if (recognizer) {
        const recognizerOption = options.recognizerOptions[recognizerName];
        delete recognizerOption.enable;
        recognizer.set(recognizerOption);
      }
    }
    this.wheelInput = new WheelInput(element, this._onOtherEvent, {
      enable: false
    });
    this.moveInput = new MoveInput(element, this._onOtherEvent, {
      enable: false
    });
    this.keyInput = new KeyInput(element, this._onOtherEvent, {
      enable: false,
      tabIndex: options.tabIndex
    });
    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
      enable: false
    });
    for (const [eventAlias, eventRegistrar] of this.events) {
      if (!eventRegistrar.isEmpty()) {
        this._toggleRecognizer(eventRegistrar.recognizerName, true);
        this.manager.on(eventAlias, eventRegistrar.handleEvent);
      }
    }
  }
  // Tear down internal event management implementations.
  destroy() {
    if (this.element) {
      this.wheelInput.destroy();
      this.moveInput.destroy();
      this.keyInput.destroy();
      this.contextmenuInput.destroy();
      this.manager.destroy();
      this.wheelInput = null;
      this.moveInput = null;
      this.keyInput = null;
      this.contextmenuInput = null;
      this.manager = null;
      this.element = null;
    }
  }
  /** Register an event handler function to be called on `event` */
  on(event, handler, opts) {
    this._addEventHandler(event, handler, opts, false);
  }
  once(event, handler, opts) {
    this._addEventHandler(event, handler, opts, true);
  }
  watch(event, handler, opts) {
    this._addEventHandler(event, handler, opts, false, true);
  }
  off(event, handler) {
    this._removeEventHandler(event, handler);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(name, enabled) {
    const { manager } = this;
    if (!manager) {
      return;
    }
    const recognizer = manager.get(name);
    if (recognizer && recognizer.options.enable !== enabled) {
      recognizer.set({ enable: enabled });
      const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];
      if (fallbackRecognizers && !this.options.recognizers) {
        fallbackRecognizers.forEach((otherName) => {
          const otherRecognizer = manager.get(otherName);
          if (enabled) {
            otherRecognizer.requireFailure(name);
            recognizer.dropRequireFailure(otherName);
          } else {
            otherRecognizer.dropRequireFailure(name);
          }
        });
      }
    }
    this.wheelInput.enableEventType(name, enabled);
    this.moveInput.enableEventType(name, enabled);
    this.keyInput.enableEventType(name, enabled);
    this.contextmenuInput.enableEventType(name, enabled);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(event, handler, opts, once, passive) {
    if (typeof event !== "string") {
      opts = handler;
      for (const eventName in event) {
        this._addEventHandler(eventName, event[eventName], opts, once, passive);
      }
      return;
    }
    const { manager, events } = this;
    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
    let eventRegistrar = events.get(eventAlias);
    if (!eventRegistrar) {
      eventRegistrar = new EventRegistrar(this);
      events.set(eventAlias, eventRegistrar);
      eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
      if (manager) {
        manager.on(eventAlias, eventRegistrar.handleEvent);
      }
    }
    eventRegistrar.add(event, handler, opts, once, passive);
    if (!eventRegistrar.isEmpty()) {
      this._toggleRecognizer(eventRegistrar.recognizerName, true);
    }
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(event, handler) {
    if (typeof event !== "string") {
      for (const eventName in event) {
        this._removeEventHandler(eventName, event[eventName]);
      }
      return;
    }
    const { events } = this;
    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
    const eventRegistrar = events.get(eventAlias);
    if (!eventRegistrar) {
      return;
    }
    eventRegistrar.remove(event, handler);
    if (eventRegistrar.isEmpty()) {
      const { recognizerName } = eventRegistrar;
      let isRecognizerUsed = false;
      for (const eh of events.values()) {
        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
          isRecognizerUsed = true;
          break;
        }
      }
      if (!isRecognizerUsed) {
        this._toggleRecognizer(recognizerName, false);
      }
    }
  }
};

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/map-controller.js
function ownKeys5(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys5(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var NO_TRANSITION_PROPS = {
  transitionDuration: 0
};
var LINEAR_TRANSITION_PROPS = {
  transitionDuration: 300,
  transitionEasing: function transitionEasing2(t) {
    return t;
  },
  transitionInterpolator: new LinearInterpolator(),
  transitionInterruption: TRANSITION_EVENTS.BREAK
};
var DEFAULT_INERTIA = 300;
var INERTIA_EASING = function INERTIA_EASING2(t) {
  return 1 - (1 - t) * (1 - t);
};
var EVENT_TYPES = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
  DOUBLE_TAP: ["doubletap"],
  KEYBOARD: ["keydown"]
};
var MapController = function() {
  function MapController2() {
    var _this = this;
    _classCallCheck(this, MapController2);
    _defineProperty(this, "events", []);
    _defineProperty(this, "scrollZoom", true);
    _defineProperty(this, "dragPan", true);
    _defineProperty(this, "dragRotate", true);
    _defineProperty(this, "doubleClickZoom", true);
    _defineProperty(this, "touchZoom", true);
    _defineProperty(this, "touchRotate", false);
    _defineProperty(this, "keyboard", true);
    _defineProperty(this, "_interactionState", {
      isDragging: false
    });
    _defineProperty(this, "_events", {});
    _defineProperty(this, "_setInteractionState", function(newState) {
      Object.assign(_this._interactionState, newState);
      if (_this.onStateChange) {
        _this.onStateChange(_this._interactionState);
      }
    });
    _defineProperty(this, "_onTransition", function(newViewport, oldViewport) {
      _this.onViewportChange(newViewport, _this._interactionState, oldViewport);
    });
    this.handleEvent = this.handleEvent.bind(this);
    this._transitionManager = new TransitionManager({
      onViewportChange: this._onTransition,
      onStateChange: this._setInteractionState
    });
  }
  _createClass(MapController2, [{
    key: "handleEvent",
    value: function handleEvent(event) {
      this.mapState = this.getMapState();
      var eventStartBlocked = this._eventStartBlocked;
      switch (event.type) {
        case "panstart":
          return eventStartBlocked ? false : this._onPanStart(event);
        case "panmove":
          return this._onPan(event);
        case "panend":
          return this._onPanEnd(event);
        case "pinchstart":
          return eventStartBlocked ? false : this._onPinchStart(event);
        case "pinchmove":
          return this._onPinch(event);
        case "pinchend":
          return this._onPinchEnd(event);
        case "tripanstart":
          return eventStartBlocked ? false : this._onTriplePanStart(event);
        case "tripanmove":
          return this._onTriplePan(event);
        case "tripanend":
          return this._onTriplePanEnd(event);
        case "doubletap":
          return this._onDoubleTap(event);
        case "wheel":
          return this._onWheel(event);
        case "keydown":
          return this._onKeyDown(event);
        default:
          return false;
      }
    }
  }, {
    key: "getCenter",
    value: function getCenter(event) {
      var _event$offsetCenter = event.offsetCenter, x = _event$offsetCenter.x, y = _event$offsetCenter.y;
      return [x, y];
    }
  }, {
    key: "isFunctionKeyPressed",
    value: function isFunctionKeyPressed(event) {
      var srcEvent = event.srcEvent;
      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
  }, {
    key: "blockEvents",
    value: function blockEvents(timeout) {
      var _this2 = this;
      var timer = setTimeout(function() {
        if (_this2._eventStartBlocked === timer) {
          _this2._eventStartBlocked = null;
        }
      }, timeout);
      this._eventStartBlocked = timer;
    }
  }, {
    key: "updateViewport",
    value: function updateViewport2(newMapState, extraProps, interactionState) {
      var oldViewport = this.mapState instanceof MapState ? this.mapState.getViewportProps() : this.mapState;
      var newViewport = _objectSpread5(_objectSpread5({}, newMapState.getViewportProps()), extraProps);
      var viewStateChanged = Object.keys(newViewport).some(function(key) {
        return oldViewport[key] !== newViewport[key];
      });
      this._state = newMapState.getState();
      this._setInteractionState(interactionState);
      if (viewStateChanged) {
        this.onViewportChange(newViewport, this._interactionState, oldViewport);
      }
    }
  }, {
    key: "getMapState",
    value: function getMapState(overrides) {
      return new MapState(_objectSpread5(_objectSpread5(_objectSpread5({}, this.mapStateProps), this._state), overrides));
    }
  }, {
    key: "isDragging",
    value: function isDragging() {
      return this._interactionState.isDragging;
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var onViewportChange = options.onViewportChange, onStateChange = options.onStateChange, _options$eventManager = options.eventManager, eventManager = _options$eventManager === void 0 ? this.eventManager : _options$eventManager, _options$isInteractiv = options.isInteractive, isInteractive = _options$isInteractiv === void 0 ? true : _options$isInteractiv, _options$scrollZoom = options.scrollZoom, scrollZoom = _options$scrollZoom === void 0 ? this.scrollZoom : _options$scrollZoom, _options$dragPan = options.dragPan, dragPan = _options$dragPan === void 0 ? this.dragPan : _options$dragPan, _options$dragRotate = options.dragRotate, dragRotate = _options$dragRotate === void 0 ? this.dragRotate : _options$dragRotate, _options$doubleClickZ = options.doubleClickZoom, doubleClickZoom = _options$doubleClickZ === void 0 ? this.doubleClickZoom : _options$doubleClickZ, _options$touchZoom = options.touchZoom, touchZoom = _options$touchZoom === void 0 ? this.touchZoom : _options$touchZoom, _options$touchRotate = options.touchRotate, touchRotate = _options$touchRotate === void 0 ? this.touchRotate : _options$touchRotate, _options$keyboard = options.keyboard, keyboard = _options$keyboard === void 0 ? this.keyboard : _options$keyboard;
      this.onViewportChange = onViewportChange;
      this.onStateChange = onStateChange;
      var prevOptions = this.mapStateProps || {};
      var dimensionChanged = prevOptions.height !== options.height || prevOptions.width !== options.width;
      this.mapStateProps = options;
      if (dimensionChanged) {
        this.mapState = prevOptions;
        this.updateViewport(new MapState(options));
      }
      this._transitionManager.processViewportChange(options);
      if (this.eventManager !== eventManager) {
        this.eventManager = eventManager;
        this._events = {};
        this.toggleEvents(this.events, true);
      }
      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && Boolean(scrollZoom));
      this.toggleEvents(EVENT_TYPES.PAN, isInteractive && Boolean(dragPan || dragRotate));
      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && Boolean(touchZoom || touchRotate));
      this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && Boolean(touchRotate));
      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && Boolean(doubleClickZoom));
      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && Boolean(keyboard));
      this.scrollZoom = scrollZoom;
      this.dragPan = dragPan;
      this.dragRotate = dragRotate;
      this.doubleClickZoom = doubleClickZoom;
      this.touchZoom = touchZoom;
      this.touchRotate = touchRotate;
      this.keyboard = keyboard;
    }
  }, {
    key: "toggleEvents",
    value: function toggleEvents(eventNames, enabled) {
      var _this3 = this;
      if (this.eventManager) {
        eventNames.forEach(function(eventName) {
          if (_this3._events[eventName] !== enabled) {
            _this3._events[eventName] = enabled;
            if (enabled) {
              _this3.eventManager.on(eventName, _this3.handleEvent);
            } else {
              _this3.eventManager.off(eventName, _this3.handleEvent);
            }
          }
        });
      }
    }
  }, {
    key: "_onPanStart",
    value: function _onPanStart(event) {
      var pos = this.getCenter(event);
      this._panRotate = this.isFunctionKeyPressed(event) || event.rightButton;
      var newMapState = this._panRotate ? this.mapState.rotateStart({
        pos
      }) : this.mapState.panStart({
        pos
      });
      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
      return true;
    }
  }, {
    key: "_onPan",
    value: function _onPan(event) {
      if (!this.isDragging()) {
        return false;
      }
      return this._panRotate ? this._onPanRotate(event) : this._onPanMove(event);
    }
  }, {
    key: "_onPanEnd",
    value: function _onPanEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      return this._panRotate ? this._onPanRotateEnd(event) : this._onPanMoveEnd(event);
    }
  }, {
    key: "_onPanMove",
    value: function _onPanMove(event) {
      if (!this.dragPan) {
        return false;
      }
      var pos = this.getCenter(event);
      var newMapState = this.mapState.pan({
        pos
      });
      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {
        isPanning: true
      });
      return true;
    }
  }, {
    key: "_onPanMoveEnd",
    value: function _onPanMoveEnd(event) {
      if (this.dragPan) {
        var _this$dragPan$inertia = this.dragPan.inertia, inertia = _this$dragPan$inertia === void 0 ? DEFAULT_INERTIA : _this$dragPan$inertia;
        if (inertia && event.velocity) {
          var pos = this.getCenter(event);
          var endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
          var newControllerState = this.mapState.pan({
            pos: endPos
          }).panEnd();
          this.updateViewport(newControllerState, _objectSpread5(_objectSpread5({}, LINEAR_TRANSITION_PROPS), {}, {
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          }), {
            isDragging: false,
            isPanning: true
          });
          return true;
        }
      }
      var newMapState = this.mapState.panEnd();
      this.updateViewport(newMapState, null, {
        isDragging: false,
        isPanning: false
      });
      return true;
    }
  }, {
    key: "_onPanRotate",
    value: function _onPanRotate(event) {
      if (!this.dragRotate) {
        return false;
      }
      var pos = this.getCenter(event);
      var newMapState = this.mapState.rotate({
        pos
      });
      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {
        isRotating: true
      });
      return true;
    }
  }, {
    key: "_onPanRotateEnd",
    value: function _onPanRotateEnd(event) {
      if (this.dragRotate) {
        var _this$dragRotate$iner = this.dragRotate.inertia, inertia = _this$dragRotate$iner === void 0 ? DEFAULT_INERTIA : _this$dragRotate$iner;
        if (inertia && event.velocity) {
          var pos = this.getCenter(event);
          var endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
          var newControllerState = this.mapState.rotate({
            pos: endPos
          }).rotateEnd();
          this.updateViewport(newControllerState, _objectSpread5(_objectSpread5({}, LINEAR_TRANSITION_PROPS), {}, {
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          }), {
            isDragging: false,
            isRotating: true
          });
          return true;
        }
      }
      var newMapState = this.mapState.panEnd();
      this.updateViewport(newMapState, null, {
        isDragging: false,
        isRotating: false
      });
      return true;
    }
  }, {
    key: "_onWheel",
    value: function _onWheel(event) {
      if (!this.scrollZoom) {
        return false;
      }
      var _this$scrollZoom = this.scrollZoom, _this$scrollZoom$spee = _this$scrollZoom.speed, speed = _this$scrollZoom$spee === void 0 ? 0.01 : _this$scrollZoom$spee, _this$scrollZoom$smoo = _this$scrollZoom.smooth, smooth = _this$scrollZoom$smoo === void 0 ? false : _this$scrollZoom$smoo;
      event.preventDefault();
      var pos = this.getCenter(event);
      var delta = event.delta;
      var scale4 = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
      if (delta < 0 && scale4 !== 0) {
        scale4 = 1 / scale4;
      }
      var newMapState = this.mapState.zoom({
        pos,
        scale: scale4
      });
      this.updateViewport(newMapState, _objectSpread5(_objectSpread5({}, LINEAR_TRANSITION_PROPS), {}, {
        transitionInterpolator: new LinearInterpolator({
          around: pos
        }),
        transitionDuration: smooth ? 250 : 1
      }), {
        isPanning: true,
        isZooming: true
      });
      return true;
    }
  }, {
    key: "_onPinchStart",
    value: function _onPinchStart(event) {
      var pos = this.getCenter(event);
      var newMapState = this.mapState.zoomStart({
        pos
      }).rotateStart({
        pos
      });
      this._startPinchRotation = event.rotation;
      this._lastPinchEvent = event;
      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
      return true;
    }
  }, {
    key: "_onPinch",
    value: function _onPinch(event) {
      if (!this.isDragging()) {
        return false;
      }
      if (!this.touchZoom && !this.touchRotate) {
        return false;
      }
      var newMapState = this.mapState;
      if (this.touchZoom) {
        var scale4 = event.scale;
        var pos = this.getCenter(event);
        newMapState = newMapState.zoom({
          pos,
          scale: scale4
        });
      }
      if (this.touchRotate) {
        var rotation = event.rotation;
        newMapState = newMapState.rotate({
          deltaAngleX: this._startPinchRotation - rotation
        });
      }
      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isPanning: Boolean(this.touchZoom),
        isZooming: Boolean(this.touchZoom),
        isRotating: Boolean(this.touchRotate)
      });
      this._lastPinchEvent = event;
      return true;
    }
  }, {
    key: "_onPinchEnd",
    value: function _onPinchEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      if (this.touchZoom) {
        var _this$touchZoom$inert = this.touchZoom.inertia, inertia = _this$touchZoom$inert === void 0 ? DEFAULT_INERTIA : _this$touchZoom$inert;
        var _lastPinchEvent = this._lastPinchEvent;
        if (inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
          var pos = this.getCenter(event);
          var _newMapState = this.mapState.rotateEnd();
          var z = Math.log2(event.scale);
          var velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
          var endScale = Math.pow(2, z + velocityZ * inertia / 2);
          _newMapState = _newMapState.zoom({
            pos,
            scale: endScale
          }).zoomEnd();
          this.updateViewport(_newMapState, _objectSpread5(_objectSpread5({}, LINEAR_TRANSITION_PROPS), {}, {
            transitionInterpolator: new LinearInterpolator({
              around: pos
            }),
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          }), {
            isDragging: false,
            isPanning: Boolean(this.touchZoom),
            isZooming: Boolean(this.touchZoom),
            isRotating: false
          });
          this.blockEvents(inertia);
          return true;
        }
      }
      var newMapState = this.mapState.zoomEnd().rotateEnd();
      this._state.startPinchRotation = 0;
      this.updateViewport(newMapState, null, {
        isDragging: false,
        isPanning: false,
        isZooming: false,
        isRotating: false
      });
      this._startPinchRotation = null;
      this._lastPinchEvent = null;
      return true;
    }
  }, {
    key: "_onTriplePanStart",
    value: function _onTriplePanStart(event) {
      var pos = this.getCenter(event);
      var newMapState = this.mapState.rotateStart({
        pos
      });
      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
      return true;
    }
  }, {
    key: "_onTriplePan",
    value: function _onTriplePan(event) {
      if (!this.isDragging()) {
        return false;
      }
      if (!this.touchRotate) {
        return false;
      }
      var pos = this.getCenter(event);
      pos[0] -= event.deltaX;
      var newMapState = this.mapState.rotate({
        pos
      });
      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {
        isRotating: true
      });
      return true;
    }
  }, {
    key: "_onTriplePanEnd",
    value: function _onTriplePanEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      if (this.touchRotate) {
        var _this$touchRotate$ine = this.touchRotate.inertia, inertia = _this$touchRotate$ine === void 0 ? DEFAULT_INERTIA : _this$touchRotate$ine;
        if (inertia && event.velocityY) {
          var pos = this.getCenter(event);
          var endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
          var _newMapState2 = this.mapState.rotate({
            pos: endPos
          });
          this.updateViewport(_newMapState2, _objectSpread5(_objectSpread5({}, LINEAR_TRANSITION_PROPS), {}, {
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          }), {
            isDragging: false,
            isRotating: true
          });
          this.blockEvents(inertia);
          return false;
        }
      }
      var newMapState = this.mapState.rotateEnd();
      this.updateViewport(newMapState, null, {
        isDragging: false,
        isRotating: false
      });
      return true;
    }
  }, {
    key: "_onDoubleTap",
    value: function _onDoubleTap(event) {
      if (!this.doubleClickZoom) {
        return false;
      }
      var pos = this.getCenter(event);
      var isZoomOut = this.isFunctionKeyPressed(event);
      var newMapState = this.mapState.zoom({
        pos,
        scale: isZoomOut ? 0.5 : 2
      });
      this.updateViewport(newMapState, Object.assign({}, LINEAR_TRANSITION_PROPS, {
        transitionInterpolator: new LinearInterpolator({
          around: pos
        })
      }), {
        isZooming: true
      });
      return true;
    }
  }, {
    key: "_onKeyDown",
    value: function _onKeyDown(event) {
      if (!this.keyboard) {
        return false;
      }
      var funcKey = this.isFunctionKeyPressed(event);
      var _this$keyboard = this.keyboard, _this$keyboard$zoomSp = _this$keyboard.zoomSpeed, zoomSpeed = _this$keyboard$zoomSp === void 0 ? 2 : _this$keyboard$zoomSp, _this$keyboard$moveSp = _this$keyboard.moveSpeed, moveSpeed = _this$keyboard$moveSp === void 0 ? 100 : _this$keyboard$moveSp, _this$keyboard$rotate = _this$keyboard.rotateSpeedX, rotateSpeedX = _this$keyboard$rotate === void 0 ? 15 : _this$keyboard$rotate, _this$keyboard$rotate2 = _this$keyboard.rotateSpeedY, rotateSpeedY = _this$keyboard$rotate2 === void 0 ? 10 : _this$keyboard$rotate2;
      var mapStateProps = this.mapStateProps;
      var newMapState;
      switch (event.srcEvent.keyCode) {
        case 189:
          if (funcKey) {
            newMapState = this.getMapState({
              zoom: mapStateProps.zoom - Math.log2(zoomSpeed) - 1
            });
          } else {
            newMapState = this.getMapState({
              zoom: mapStateProps.zoom - Math.log2(zoomSpeed)
            });
          }
          break;
        case 187:
          if (funcKey) {
            newMapState = this.getMapState({
              zoom: mapStateProps.zoom + Math.log2(zoomSpeed) + 1
            });
          } else {
            newMapState = this.getMapState({
              zoom: mapStateProps.zoom + Math.log2(zoomSpeed)
            });
          }
          break;
        case 37:
          if (funcKey) {
            newMapState = this.getMapState({
              bearing: mapStateProps.bearing - rotateSpeedX
            });
          } else {
            newMapState = this.mapState.pan({
              pos: [moveSpeed, 0],
              startPos: [0, 0]
            });
          }
          break;
        case 39:
          if (funcKey) {
            newMapState = this.getMapState({
              bearing: mapStateProps.bearing + rotateSpeedX
            });
          } else {
            newMapState = this.mapState.pan({
              pos: [-moveSpeed, 0],
              startPos: [0, 0]
            });
          }
          break;
        case 38:
          if (funcKey) {
            newMapState = this.getMapState({
              pitch: mapStateProps.pitch + rotateSpeedY
            });
          } else {
            newMapState = this.mapState.pan({
              pos: [0, moveSpeed],
              startPos: [0, 0]
            });
          }
          break;
        case 40:
          if (funcKey) {
            newMapState = this.getMapState({
              pitch: mapStateProps.pitch - rotateSpeedY
            });
          } else {
            newMapState = this.mapState.pan({
              pos: [0, -moveSpeed],
              startPos: [0, 0]
            });
          }
          break;
        default:
          return false;
      }
      return this.updateViewport(newMapState, LINEAR_TRANSITION_PROPS);
    }
  }]);
  return MapController2;
}();

// node_modules/@goongmaps/goong-map-react/dist/esm/components/interactive-map.js
function ownKeys6(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys6(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var propTypes3 = Object.assign({}, static_map_default.propTypes, {
  maxZoom: PropTypes3.number,
  minZoom: PropTypes3.number,
  maxPitch: PropTypes3.number,
  minPitch: PropTypes3.number,
  onViewStateChange: PropTypes3.func,
  onViewportChange: PropTypes3.func,
  onInteractionStateChange: PropTypes3.func,
  transitionDuration: PropTypes3.oneOfType([PropTypes3.number, PropTypes3.string]),
  transitionInterpolator: PropTypes3.object,
  transitionInterruption: PropTypes3.number,
  transitionEasing: PropTypes3.func,
  onTransitionStart: PropTypes3.func,
  onTransitionInterrupt: PropTypes3.func,
  onTransitionEnd: PropTypes3.func,
  scrollZoom: PropTypes3.oneOfType([PropTypes3.bool, PropTypes3.object]),
  dragPan: PropTypes3.oneOfType([PropTypes3.bool, PropTypes3.object]),
  dragRotate: PropTypes3.oneOfType([PropTypes3.bool, PropTypes3.object]),
  doubleClickZoom: PropTypes3.bool,
  touchZoom: PropTypes3.oneOfType([PropTypes3.bool, PropTypes3.object]),
  touchRotate: PropTypes3.oneOfType([PropTypes3.bool, PropTypes3.object]),
  keyboard: PropTypes3.oneOfType([PropTypes3.bool, PropTypes3.object]),
  onHover: PropTypes3.func,
  onClick: PropTypes3.func,
  onDblClick: PropTypes3.func,
  onContextMenu: PropTypes3.func,
  onMouseDown: PropTypes3.func,
  onMouseMove: PropTypes3.func,
  onMouseUp: PropTypes3.func,
  onTouchStart: PropTypes3.func,
  onTouchMove: PropTypes3.func,
  onTouchEnd: PropTypes3.func,
  onMouseEnter: PropTypes3.func,
  onMouseLeave: PropTypes3.func,
  onMouseOut: PropTypes3.func,
  onWheel: PropTypes3.func,
  touchAction: PropTypes3.string,
  eventRecognizerOptions: PropTypes3.object,
  clickRadius: PropTypes3.number,
  interactiveLayerIds: PropTypes3.array,
  getCursor: PropTypes3.func,
  controller: PropTypes3.instanceOf(MapController)
});
var getDefaultCursor = function getDefaultCursor2(_ref) {
  var isDragging = _ref.isDragging, isHovering = _ref.isHovering;
  return isDragging ? "grabbing" : isHovering ? "pointer" : "grab";
};
var defaultProps3 = Object.assign({}, static_map_default.defaultProps, MAPBOX_LIMITS, TransitionManager.defaultProps, {
  onViewStateChange: null,
  onViewportChange: null,
  onClick: null,
  onNativeClick: null,
  onHover: null,
  onContextMenu: function onContextMenu(event) {
    return event.preventDefault();
  },
  scrollZoom: true,
  dragPan: true,
  dragRotate: true,
  doubleClickZoom: true,
  touchZoom: true,
  touchRotate: false,
  keyboard: true,
  touchAction: "none",
  eventRecognizerOptions: {},
  clickRadius: 0,
  getCursor: getDefaultCursor
});
function normalizeEvent(event) {
  if (event.lngLat || !event.offsetCenter) {
    return event;
  }
  var _event$offsetCenter = event.offsetCenter, x = _event$offsetCenter.x, y = _event$offsetCenter.y;
  if (!Number.isFinite(x) || !Number.isFinite(y)) {
    return event;
  }
  var pos = [x, y];
  event.point = pos;
  var viewport = this.viewport;
  var location = viewport.unproject(pos, {
    targetZ: viewport.meterOffset[2]
  });
  event.lngLat = [location[0], location[1]];
  return event;
}
function getFeatures(pos) {
  var map = this.map;
  if (!map || !pos) {
    return null;
  }
  var queryParams = {};
  var size = this.props.clickRadius;
  if (this.props.interactiveLayerIds) {
    queryParams.layers = this.props.interactiveLayerIds;
  }
  try {
    return map.queryRenderedFeatures(size ? [[pos[0] - size, pos[1] + size], [pos[0] + size, pos[1] - size]] : pos, queryParams);
  } catch (_unused) {
    return null;
  }
}
function onEvent(callbackName, event) {
  var func11 = this.props[callbackName];
  if (func11) {
    func11(normalizeEvent.call(this, event));
  }
}
function onPointerDown(event) {
  onEvent.call(this, event.pointerType === "touch" ? "onTouchStart" : "onMouseDown", event);
}
function onPointerUp(event) {
  onEvent.call(this, event.pointerType === "touch" ? "onTouchEnd" : "onMouseUp", event);
}
function onPointerMove(event) {
  onEvent.call(this, event.pointerType === "touch" ? "onTouchMove" : "onMouseMove", event);
  if (!this.state.isDragging) {
    var _this$props = this.props, onHover = _this$props.onHover, interactiveLayerIds = _this$props.interactiveLayerIds;
    var features;
    event = normalizeEvent.call(this, event);
    if (interactiveLayerIds || onHover) {
      features = getFeatures.call(this, event.point);
    }
    var isHovering = Boolean(interactiveLayerIds && features && features.length > 0);
    var isEntering = isHovering && !this.state.isHovering;
    var isExiting = !isHovering && this.state.isHovering;
    if (onHover || isEntering) {
      event.features = features;
      if (onHover) {
        onHover(event);
      }
    }
    if (isEntering) {
      onEvent.call(this, "onMouseEnter", event);
    }
    if (isExiting) {
      onEvent.call(this, "onMouseLeave", event);
    }
    if (isEntering || isExiting) {
      this.setState({
        isHovering
      });
    }
  }
}
function onPointerClick(event) {
  var _this$props2 = this.props, onClick2 = _this$props2.onClick, onNativeClick = _this$props2.onNativeClick, onDblClick = _this$props2.onDblClick, doubleClickZoom = _this$props2.doubleClickZoom;
  var callbacks = [];
  var isDoubleClickEnabled = onDblClick || doubleClickZoom;
  switch (event.type) {
    case "anyclick":
      callbacks.push(onNativeClick);
      if (!isDoubleClickEnabled) {
        callbacks.push(onClick2);
      }
      break;
    case "click":
      if (isDoubleClickEnabled) {
        callbacks.push(onClick2);
      }
      break;
    default:
  }
  callbacks = callbacks.filter(Boolean);
  if (callbacks.length) {
    event = normalizeEvent.call(this, event);
    event.features = getFeatures.call(this, event.point);
    callbacks.forEach(function(cb) {
      return cb(event);
    });
  }
}
function getRefHandles2(staticMapRef) {
  return {
    getMap: staticMapRef.current && staticMapRef.current.getMap,
    queryRenderedFeatures: staticMapRef.current && staticMapRef.current.queryRenderedFeatures
  };
}
var InteractiveMap = (0, import_react4.forwardRef)(function(props, ref) {
  var parentContext = (0, import_react4.useContext)(map_context_default);
  var controller = (0, import_react4.useMemo)(function() {
    return props.controller || new MapController();
  }, []);
  var eventManager = (0, import_react4.useMemo)(function() {
    return new EventManager(null, {
      touchAction: props.touchAction,
      recognizerOptions: props.eventRecognizerOptions
    });
  }, []);
  var eventCanvasRef = (0, import_react4.useRef)(null);
  var staticMapRef = (0, import_react4.useRef)(null);
  var _thisRef = (0, import_react4.useRef)({
    width: 0,
    height: 0,
    state: {
      isHovering: false,
      isDragging: false
    }
  });
  var thisRef = _thisRef.current;
  thisRef.props = props;
  thisRef.map = staticMapRef.current && staticMapRef.current.getMap();
  thisRef.setState = function(newState) {
    thisRef.state = _objectSpread6(_objectSpread6({}, thisRef.state), newState);
    eventCanvasRef.current.style.cursor = props.getCursor(thisRef.state);
  };
  var inRender = true;
  var viewportUpdateRequested;
  var stateUpdateRequested;
  var handleViewportChange = function handleViewportChange2(viewState, interactionState, oldViewState) {
    if (inRender) {
      viewportUpdateRequested = [viewState, interactionState, oldViewState];
      return;
    }
    var _thisRef$props = thisRef.props, onViewStateChange = _thisRef$props.onViewStateChange, onViewportChange = _thisRef$props.onViewportChange;
    Object.defineProperty(viewState, "position", {
      get: function get() {
        return [0, 0, getTerrainElevation(thisRef.map, viewState)];
      }
    });
    if (onViewStateChange) {
      onViewStateChange({
        viewState,
        interactionState,
        oldViewState
      });
    }
    if (onViewportChange) {
      onViewportChange(viewState, interactionState, oldViewState);
    }
  };
  (0, import_react4.useImperativeHandle)(ref, function() {
    return getRefHandles2(staticMapRef);
  }, []);
  var context = (0, import_react4.useMemo)(function() {
    return _objectSpread6(_objectSpread6({}, parentContext), {}, {
      eventManager,
      container: parentContext.container || eventCanvasRef.current
    });
  }, [parentContext, eventCanvasRef.current]);
  context.onViewportChange = handleViewportChange;
  context.viewport = parentContext.viewport || getViewport(thisRef);
  thisRef.viewport = context.viewport;
  var handleInteractionStateChange = function handleInteractionStateChange2(interactionState) {
    var _interactionState$isD = interactionState.isDragging, isDragging = _interactionState$isD === void 0 ? false : _interactionState$isD;
    if (isDragging !== thisRef.state.isDragging) {
      thisRef.setState({
        isDragging
      });
    }
    if (inRender) {
      stateUpdateRequested = interactionState;
      return;
    }
    var onInteractionStateChange = thisRef.props.onInteractionStateChange;
    if (onInteractionStateChange) {
      onInteractionStateChange(interactionState);
    }
  };
  var updateControllerOpts = function updateControllerOpts2() {
    if (thisRef.width && thisRef.height) {
      controller.setOptions(_objectSpread6(_objectSpread6(_objectSpread6({}, thisRef.props), thisRef.props.viewState), {}, {
        isInteractive: Boolean(thisRef.props.onViewStateChange || thisRef.props.onViewportChange),
        onViewportChange: handleViewportChange,
        onStateChange: handleInteractionStateChange,
        eventManager,
        width: thisRef.width,
        height: thisRef.height
      }));
    }
  };
  var onResize = function onResize2(_ref2) {
    var width2 = _ref2.width, height2 = _ref2.height;
    thisRef.width = width2;
    thisRef.height = height2;
    updateControllerOpts();
    thisRef.props.onResize({
      width: width2,
      height: height2
    });
  };
  (0, import_react4.useEffect)(function() {
    eventManager.setElement(eventCanvasRef.current);
    eventManager.on({
      pointerdown: onPointerDown.bind(thisRef),
      pointermove: onPointerMove.bind(thisRef),
      pointerup: onPointerUp.bind(thisRef),
      pointerleave: onEvent.bind(thisRef, "onMouseOut"),
      click: onPointerClick.bind(thisRef),
      anyclick: onPointerClick.bind(thisRef),
      dblclick: onEvent.bind(thisRef, "onDblClick"),
      wheel: onEvent.bind(thisRef, "onWheel"),
      contextmenu: onEvent.bind(thisRef, "onContextMenu")
    });
    return function() {
      eventManager.destroy();
    };
  }, []);
  use_isomorphic_layout_effect_default(function() {
    if (viewportUpdateRequested) {
      handleViewportChange.apply(void 0, _toConsumableArray(viewportUpdateRequested));
    }
    if (stateUpdateRequested) {
      handleInteractionStateChange(stateUpdateRequested);
    }
  });
  updateControllerOpts();
  var width = props.width, height = props.height, style = props.style, getCursor = props.getCursor;
  var eventCanvasStyle = (0, import_react4.useMemo)(function() {
    return _objectSpread6(_objectSpread6({
      position: "relative"
    }, style), {}, {
      width,
      height,
      cursor: getCursor(thisRef.state)
    });
  }, [style, width, height, getCursor, thisRef.state]);
  if (!viewportUpdateRequested || !thisRef._child) {
    thisRef._child = React3.createElement(MapContextProvider, {
      value: context
    }, React3.createElement("div", {
      key: "event-canvas",
      ref: eventCanvasRef,
      style: eventCanvasStyle
    }, React3.createElement(static_map_default, _extends({}, props, {
      width: "100%",
      height: "100%",
      style: null,
      onResize,
      ref: staticMapRef
    }))));
  }
  inRender = false;
  return thisRef._child;
});
InteractiveMap.supported = static_map_default.supported;
InteractiveMap.propTypes = propTypes3;
InteractiveMap.defaultProps = defaultProps3;
var interactive_map_default = InteractiveMap;

// node_modules/@goongmaps/goong-map-react/dist/esm/components/source.js
var React4 = __toESM(require_react());
var import_react5 = __toESM(require_react());
var import_react6 = __toESM(require_react());
var PropTypes4 = __toESM(require_prop_types());

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/deep-equal.js
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b) || a.length !== b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  } else if (Array.isArray(b)) {
    return false;
  }
  if (_typeof(a) === "object" && _typeof(b) === "object") {
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (var _i = 0, _aKeys = aKeys; _i < _aKeys.length; _i++) {
      var key = _aKeys[_i];
      if (!b.hasOwnProperty(key)) {
        return false;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@goongmaps/goong-map-react/dist/esm/components/source.js
function ownKeys7(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys7(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var propTypes4 = {
  type: PropTypes4.string.isRequired,
  id: PropTypes4.string
};
var sourceCounter = 0;
function createSource(map, id, props) {
  if (map.style && map.style._loaded) {
    var options = _objectSpread7({}, props);
    delete options.id;
    delete options.children;
    map.addSource(id, options);
    return map.getSource(id);
  }
  return null;
}
function updateSource(source, props, prevProps) {
  assert2(props.id === prevProps.id, "source id changed");
  assert2(props.type === prevProps.type, "source type changed");
  var changedKey = "";
  var changedKeyCount = 0;
  for (var key in props) {
    if (key !== "children" && key !== "id" && !deepEqual(prevProps[key], props[key])) {
      changedKey = key;
      changedKeyCount++;
    }
  }
  if (!changedKeyCount) {
    return;
  }
  var type = props.type;
  if (type === "geojson") {
    source.setData(props.data);
  } else if (type === "image") {
    source.updateImage({
      url: props.url,
      coordinates: props.coordinates
    });
  } else if ((type === "canvas" || type === "video") && changedKeyCount === 1 && changedKey === "coordinates") {
    source.setCoordinates(props.coordinates);
  } else if (type === "vector" && source.setUrl) {
    switch (changedKey) {
      case "url":
        source.setUrl(props.url);
        break;
      case "tiles":
        source.setTiles(props.tiles);
        break;
      default:
    }
  } else {
    console.warn("Unable to update <Source> prop: ".concat(changedKey));
  }
}
function Source(props) {
  var context = (0, import_react5.useContext)(map_context_default);
  var propsRef = (0, import_react5.useRef)({
    id: props.id,
    type: props.type
  });
  var _useState = (0, import_react5.useState)(0), _useState2 = _slicedToArray(_useState, 2), setStyleLoaded = _useState2[1];
  var id = (0, import_react5.useMemo)(function() {
    return props.id || "jsx-source-".concat(sourceCounter++);
  }, []);
  var map = context.map;
  (0, import_react5.useEffect)(function() {
    if (map) {
      var forceUpdate = function forceUpdate2() {
        return setStyleLoaded(function(version) {
          return version + 1;
        });
      };
      map.on("styledata", forceUpdate);
      return function() {
        map.off("styledata", forceUpdate);
        requestAnimationFrame(function() {
          if (map.style && map.style._loaded && map.getSource(id)) {
            map.removeSource(id);
          }
        });
      };
    }
    return void 0;
  }, [map, id]);
  var source = map && map.style && map.getSource(id);
  if (source) {
    updateSource(source, props, propsRef.current);
  } else {
    source = createSource(map, id, props);
  }
  propsRef.current = props;
  return source && React4.Children.map(props.children, function(child) {
    return child && (0, import_react6.cloneElement)(child, {
      source: id
    });
  }) || null;
}
Source.propTypes = propTypes4;
var source_default = Source;

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}

// node_modules/@goongmaps/goong-map-react/dist/esm/components/layer.js
var import_react7 = __toESM(require_react());
var PropTypes5 = __toESM(require_prop_types());
var _excluded = ["layout", "paint", "filter", "minzoom", "maxzoom", "beforeId"];
function ownKeys8(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys8(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys8(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var LAYER_TYPES = ["fill", "line", "symbol", "circle", "fill-extrusion", "raster", "background", "heatmap", "hillshade", "sky"];
var propTypes5 = {
  type: PropTypes5.oneOf(LAYER_TYPES).isRequired,
  id: PropTypes5.string,
  source: PropTypes5.string,
  beforeId: PropTypes5.string
};
function diffLayerStyles(map, id, props, prevProps) {
  var _props$layout = props.layout, layout = _props$layout === void 0 ? {} : _props$layout, _props$paint = props.paint, paint = _props$paint === void 0 ? {} : _props$paint, filter = props.filter, minzoom = props.minzoom, maxzoom = props.maxzoom, beforeId = props.beforeId, otherProps = _objectWithoutProperties(props, _excluded);
  if (beforeId !== prevProps.beforeId) {
    map.moveLayer(id, beforeId);
  }
  if (layout !== prevProps.layout) {
    var prevLayout = prevProps.layout || {};
    for (var key in layout) {
      if (!deepEqual(layout[key], prevLayout[key])) {
        map.setLayoutProperty(id, key, layout[key]);
      }
    }
    for (var _key in prevLayout) {
      if (!layout.hasOwnProperty(_key)) {
        map.setLayoutProperty(id, _key, void 0);
      }
    }
  }
  if (paint !== prevProps.paint) {
    var prevPaint = prevProps.paint || {};
    for (var _key2 in paint) {
      if (!deepEqual(paint[_key2], prevPaint[_key2])) {
        map.setPaintProperty(id, _key2, paint[_key2]);
      }
    }
    for (var _key3 in prevPaint) {
      if (!paint.hasOwnProperty(_key3)) {
        map.setPaintProperty(id, _key3, void 0);
      }
    }
  }
  if (!deepEqual(filter, prevProps.filter)) {
    map.setFilter(id, filter);
  }
  if (minzoom !== prevProps.minzoom || maxzoom !== prevProps.maxzoom) {
    map.setLayerZoomRange(id, minzoom, maxzoom);
  }
  for (var _key4 in otherProps) {
    if (!deepEqual(otherProps[_key4], prevProps[_key4])) {
      map.setLayerProperty(id, _key4, otherProps[_key4]);
    }
  }
}
function createLayer(map, id, props) {
  if (map.style && map.style._loaded) {
    var options = _objectSpread8(_objectSpread8({}, props), {}, {
      id
    });
    delete options.beforeId;
    map.addLayer(options, props.beforeId);
  }
}
function updateLayer(map, id, props, prevProps) {
  assert2(props.id === prevProps.id, "layer id changed");
  assert2(props.type === prevProps.type, "layer type changed");
  try {
    diffLayerStyles(map, id, props, prevProps);
  } catch (error) {
    console.warn(error);
  }
}
var layerCounter = 0;
function Layer(props) {
  var context = (0, import_react7.useContext)(map_context_default);
  var propsRef = (0, import_react7.useRef)({
    id: props.id,
    type: props.type
  });
  var _useState = (0, import_react7.useState)(0), _useState2 = _slicedToArray(_useState, 2), setStyleLoaded = _useState2[1];
  var id = (0, import_react7.useMemo)(function() {
    return props.id || "jsx-layer-".concat(layerCounter++);
  }, []);
  var map = context.map;
  (0, import_react7.useEffect)(function() {
    if (map) {
      var forceUpdate = function forceUpdate2() {
        return setStyleLoaded(function(version) {
          return version + 1;
        });
      };
      map.on("styledata", forceUpdate);
      return function() {
        map.off("styledata", forceUpdate);
        if (map.style && map.style._loaded) {
          map.removeLayer(id);
        }
      };
    }
    return void 0;
  }, [map]);
  var layer = map && map.style && map.getLayer(id);
  if (layer) {
    updateLayer(map, id, props, propsRef.current);
  } else {
    createLayer(map, id, props);
  }
  propsRef.current = props;
  return null;
}
Layer.propTypes = propTypes5;
var layer_default = Layer;

// node_modules/@goongmaps/goong-map-react/dist/esm/components/base-control.js
var React5 = __toESM(require_react());
var import_react9 = __toESM(require_react());

// node_modules/@goongmaps/goong-map-react/dist/esm/components/use-map-control.js
var import_react8 = __toESM(require_react());
var PropTypes6 = __toESM(require_prop_types());
var mapControlDefaultProps = {
  captureScroll: false,
  captureDrag: true,
  captureClick: true,
  captureDoubleClick: true,
  capturePointerMove: false
};
var mapControlPropTypes = {
  captureScroll: PropTypes6.bool,
  captureDrag: PropTypes6.bool,
  captureClick: PropTypes6.bool,
  captureDoubleClick: PropTypes6.bool,
  capturePointerMove: PropTypes6.bool
};
function onMount(thisRef) {
  var ref = thisRef.containerRef.current;
  var eventManager = thisRef.context.eventManager;
  if (!ref || !eventManager) {
    return void 0;
  }
  var events = {
    wheel: function wheel(evt) {
      var props = thisRef.props;
      if (props.captureScroll) {
        evt.stopPropagation();
      }
      if (props.onScroll) {
        props.onScroll(evt, thisRef);
      }
    },
    panstart: function panstart(evt) {
      var props = thisRef.props;
      if (props.captureDrag) {
        evt.stopPropagation();
      }
      if (props.onDragStart) {
        props.onDragStart(evt, thisRef);
      }
    },
    anyclick: function anyclick(evt) {
      var props = thisRef.props;
      if (props.captureClick) {
        evt.stopPropagation();
      }
      if (props.onClick) {
        props.onClick(evt, thisRef);
      }
    },
    click: function click(evt) {
      var props = thisRef.props;
      if (props.captureClick) {
        evt.stopPropagation();
      }
      if (props.onClick) {
        props.onClick(evt, thisRef);
      }
    },
    dblclick: function dblclick(evt) {
      var props = thisRef.props;
      if (props.captureDoubleClick) {
        evt.stopPropagation();
      }
      if (props.onDoubleClick) {
        props.onDoubleClick(evt, thisRef);
      }
    },
    pointermove: function pointermove(evt) {
      var props = thisRef.props;
      if (props.capturePointerMove) {
        evt.stopPropagation();
      }
      if (props.onPointerMove) {
        props.onPointerMove(evt, thisRef);
      }
    }
  };
  eventManager.watch(events, ref);
  return function() {
    eventManager.off(events);
  };
}
function useMapControl() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var context = (0, import_react8.useContext)(map_context_default);
  var containerRef = (0, import_react8.useRef)(null);
  var _thisRef = (0, import_react8.useRef)({
    props,
    state: {},
    context,
    containerRef
  });
  var thisRef = _thisRef.current;
  thisRef.props = props;
  thisRef.context = context;
  (0, import_react8.useEffect)(function() {
    return onMount(thisRef);
  }, [context.eventManager]);
  return thisRef;
}

// node_modules/@goongmaps/goong-map-react/dist/esm/components/base-control.js
function _createSuper3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function Control(props) {
  var instance = props.instance;
  var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
  instance._context = context;
  instance._containerRef = containerRef;
  return instance._render();
}
var BaseControl = function(_PureComponent) {
  _inherits(BaseControl2, _PureComponent);
  var _super = _createSuper3(BaseControl2);
  function BaseControl2() {
    var _this;
    _classCallCheck(this, BaseControl2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "_context", {});
    _defineProperty(_assertThisInitialized(_this), "_containerRef", (0, import_react9.createRef)());
    _defineProperty(_assertThisInitialized(_this), "_onScroll", function(evt) {
    });
    _defineProperty(_assertThisInitialized(_this), "_onDragStart", function(evt) {
    });
    _defineProperty(_assertThisInitialized(_this), "_onDblClick", function(evt) {
    });
    _defineProperty(_assertThisInitialized(_this), "_onClick", function(evt) {
    });
    _defineProperty(_assertThisInitialized(_this), "_onPointerMove", function(evt) {
    });
    return _this;
  }
  _createClass(BaseControl2, [{
    key: "_render",
    value: function _render() {
      throw new Error("_render() not implemented");
    }
  }, {
    key: "render",
    value: function render() {
      return React5.createElement(Control, _extends({
        instance: this
      }, this.props, {
        onScroll: this._onScroll,
        onDragStart: this._onDragStart,
        onDblClick: this._onDblClick,
        onClick: this._onClick,
        onPointerMove: this._onPointerMove
      }));
    }
  }]);
  return BaseControl2;
}(import_react9.PureComponent);
_defineProperty(BaseControl, "propTypes", mapControlPropTypes);
_defineProperty(BaseControl, "defaultProps", mapControlDefaultProps);

// node_modules/@goongmaps/goong-map-react/dist/esm/components/marker.js
var React6 = __toESM(require_react());
var import_react11 = __toESM(require_react());
var PropTypes8 = __toESM(require_prop_types());

// node_modules/@goongmaps/goong-map-react/dist/esm/components/draggable-control.js
var PropTypes7 = __toESM(require_prop_types());
var import_react10 = __toESM(require_react());
function ownKeys9(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys9(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var draggableControlPropTypes = Object.assign({}, mapControlPropTypes, {
  draggable: PropTypes7.bool,
  onDrag: PropTypes7.func,
  onDragEnd: PropTypes7.func,
  onDragStart: PropTypes7.func,
  offsetLeft: PropTypes7.number,
  offsetTop: PropTypes7.number
});
var draggableControlDefaultProps = Object.assign({}, mapControlDefaultProps, {
  draggable: false,
  offsetLeft: 0,
  offsetTop: 0
});
function getDragEventPosition(event) {
  var _event$offsetCenter = event.offsetCenter, x = _event$offsetCenter.x, y = _event$offsetCenter.y;
  return [x, y];
}
function getDragEventOffset(event, container) {
  var _event$center = event.center, x = _event$center.x, y = _event$center.y;
  if (container) {
    var rect = container.getBoundingClientRect();
    return [rect.left - x, rect.top - y];
  }
  return null;
}
function getDragLngLat(dragPos, dragOffset, props, context) {
  var x = dragPos[0] + dragOffset[0] - props.offsetLeft;
  var y = dragPos[1] + dragOffset[1] - props.offsetTop;
  return context.viewport.unproject([x, y]);
}
function onDragStart(event, _ref) {
  var props = _ref.props, callbacks = _ref.callbacks, state = _ref.state, context = _ref.context, containerRef = _ref.containerRef;
  var draggable = props.draggable;
  if (!draggable) {
    return;
  }
  event.stopPropagation();
  var dragPos = getDragEventPosition(event);
  var dragOffset = getDragEventOffset(event, containerRef.current);
  state.setDragPos(dragPos);
  state.setDragOffset(dragOffset);
  if (callbacks.onDragStart && dragOffset) {
    var callbackEvent = Object.assign({}, event);
    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);
    callbacks.onDragStart(callbackEvent);
  }
}
function onDrag(event, _ref2) {
  var props = _ref2.props, callbacks = _ref2.callbacks, state = _ref2.state, context = _ref2.context;
  event.stopPropagation();
  var dragPos = getDragEventPosition(event);
  state.setDragPos(dragPos);
  var dragOffset = state.dragOffset;
  if (callbacks.onDrag && dragOffset) {
    var callbackEvent = Object.assign({}, event);
    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);
    callbacks.onDrag(callbackEvent);
  }
}
function onDragEnd(event, _ref3) {
  var props = _ref3.props, callbacks = _ref3.callbacks, state = _ref3.state, context = _ref3.context;
  event.stopPropagation();
  var dragPos = state.dragPos, dragOffset = state.dragOffset;
  state.setDragPos(null);
  state.setDragOffset(null);
  if (callbacks.onDragEnd && dragPos && dragOffset) {
    var callbackEvent = Object.assign({}, event);
    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);
    callbacks.onDragEnd(callbackEvent);
  }
}
function onDragCancel(event, _ref4) {
  var state = _ref4.state;
  event.stopPropagation();
  state.setDragPos(null);
  state.setDragOffset(null);
}
function registerEvents(thisRef) {
  var eventManager = thisRef.context.eventManager;
  if (!eventManager || !thisRef.state.dragPos) {
    return void 0;
  }
  var events = {
    panmove: function panmove(evt) {
      return onDrag(evt, thisRef);
    },
    panend: function panend(evt) {
      return onDragEnd(evt, thisRef);
    },
    pancancel: function pancancel(evt) {
      return onDragCancel(evt, thisRef);
    }
  };
  eventManager.watch(events);
  return function() {
    eventManager.off(events);
  };
}
function useDraggableControl(props) {
  var _useState = (0, import_react10.useState)(null), _useState2 = _slicedToArray(_useState, 2), dragPos = _useState2[0], setDragPos = _useState2[1];
  var _useState3 = (0, import_react10.useState)(null), _useState4 = _slicedToArray(_useState3, 2), dragOffset = _useState4[0], setDragOffset = _useState4[1];
  var thisRef = useMapControl(_objectSpread9(_objectSpread9({}, props), {}, {
    onDragStart
  }));
  thisRef.callbacks = props;
  thisRef.state.dragPos = dragPos;
  thisRef.state.setDragPos = setDragPos;
  thisRef.state.dragOffset = dragOffset;
  thisRef.state.setDragOffset = setDragOffset;
  (0, import_react10.useEffect)(function() {
    return registerEvents(thisRef);
  }, [thisRef.context.eventManager, Boolean(dragPos)]);
  return thisRef;
}

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/crisp-pixel.js
var pixelRatio = typeof window !== "undefined" && window.devicePixelRatio || 1;
var crispPixel = function crispPixel2(size) {
  return Math.round(size * pixelRatio) / pixelRatio;
};
var crispPercentage = function crispPercentage2(el, percentage) {
  var dimension = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "x";
  if (el === null) {
    return percentage;
  }
  var origSize = dimension === "x" ? el.offsetWidth : el.offsetHeight;
  return crispPixel(percentage / 100 * origSize) / origSize * 100;
};

// node_modules/@goongmaps/goong-map-react/dist/esm/components/marker.js
var propTypes6 = Object.assign({}, draggableControlPropTypes, {
  className: PropTypes8.string,
  longitude: PropTypes8.number.isRequired,
  latitude: PropTypes8.number.isRequired
});
var defaultProps4 = Object.assign({}, draggableControlDefaultProps, {
  className: ""
});
function getPosition(_ref) {
  var props = _ref.props, state = _ref.state, context = _ref.context;
  var longitude = props.longitude, latitude = props.latitude, offsetLeft = props.offsetLeft, offsetTop = props.offsetTop;
  var dragPos = state.dragPos, dragOffset = state.dragOffset;
  var viewport = context.viewport, map = context.map;
  if (dragPos && dragOffset) {
    return [dragPos[0] + dragOffset[0], dragPos[1] + dragOffset[1]];
  }
  var altitude = getTerrainElevation(map, {
    longitude,
    latitude
  });
  var _viewport$project = viewport.project([longitude, latitude, altitude]), _viewport$project2 = _slicedToArray(_viewport$project, 2), x = _viewport$project2[0], y = _viewport$project2[1];
  x += offsetLeft;
  y += offsetTop;
  return [x, y];
}
function Marker(props) {
  var thisRef = useDraggableControl(props);
  var state = thisRef.state, containerRef = thisRef.containerRef;
  var children = props.children, className = props.className, draggable = props.draggable;
  var dragPos = state.dragPos;
  var _getPosition = getPosition(thisRef), _getPosition2 = _slicedToArray(_getPosition, 2), x = _getPosition2[0], y = _getPosition2[1];
  var transform = "translate(".concat(crispPixel(x), "px, ").concat(crispPixel(y), "px)");
  var cursor = draggable ? dragPos ? "grabbing" : "grab" : "auto";
  var control = (0, import_react11.useMemo)(function() {
    var containerStyle = {
      position: "absolute",
      left: 0,
      top: 0,
      transform,
      cursor
    };
    return React6.createElement("div", {
      className: "mapboxgl-marker ".concat(className),
      ref: thisRef.containerRef,
      style: containerStyle
    }, children);
  }, [children, className]);
  var container = containerRef.current;
  if (container) {
    container.style.transform = transform;
    container.style.cursor = cursor;
  }
  return control;
}
Marker.defaultProps = defaultProps4;
Marker.propTypes = propTypes6;
var marker_default = React6.memo(Marker);

// node_modules/@goongmaps/goong-map-react/dist/esm/components/popup.js
var React7 = __toESM(require_react());
var import_react12 = __toESM(require_react());
var PropTypes9 = __toESM(require_prop_types());

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/dynamic-position.js
var ANCHOR_POSITION = {
  top: {
    x: 0.5,
    y: 0
  },
  "top-left": {
    x: 0,
    y: 0
  },
  "top-right": {
    x: 1,
    y: 0
  },
  bottom: {
    x: 0.5,
    y: 1
  },
  "bottom-left": {
    x: 0,
    y: 1
  },
  "bottom-right": {
    x: 1,
    y: 1
  },
  left: {
    x: 0,
    y: 0.5
  },
  right: {
    x: 1,
    y: 0.5
  }
};
var ANCHOR_TYPES = Object.keys(ANCHOR_POSITION);
function getDynamicPosition(_ref) {
  var x = _ref.x, y = _ref.y, width = _ref.width, height = _ref.height, selfWidth = _ref.selfWidth, selfHeight = _ref.selfHeight, anchor = _ref.anchor, _ref$padding = _ref.padding, padding = _ref$padding === void 0 ? 0 : _ref$padding;
  var _ANCHOR_POSITION$anch = ANCHOR_POSITION[anchor], anchorX = _ANCHOR_POSITION$anch.x, anchorY = _ANCHOR_POSITION$anch.y;
  var top = y - anchorY * selfHeight;
  var bottom = top + selfHeight;
  var cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);
  if (cutoffY > 0) {
    var bestAnchorY = anchorY;
    var minCutoff = cutoffY;
    for (anchorY = 0; anchorY <= 1; anchorY += 0.5) {
      top = y - anchorY * selfHeight;
      bottom = top + selfHeight;
      cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);
      if (cutoffY < minCutoff) {
        minCutoff = cutoffY;
        bestAnchorY = anchorY;
      }
    }
    anchorY = bestAnchorY;
  }
  var xStep = 0.5;
  if (anchorY === 0.5) {
    anchorX = Math.floor(anchorX);
    xStep = 1;
  }
  var left = x - anchorX * selfWidth;
  var right = left + selfWidth;
  var cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);
  if (cutoffX > 0) {
    var bestAnchorX = anchorX;
    var _minCutoff = cutoffX;
    for (anchorX = 0; anchorX <= 1; anchorX += xStep) {
      left = x - anchorX * selfWidth;
      right = left + selfWidth;
      cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);
      if (cutoffX < _minCutoff) {
        _minCutoff = cutoffX;
        bestAnchorX = anchorX;
      }
    }
    anchorX = bestAnchorX;
  }
  return ANCHOR_TYPES.find(function(positionType) {
    var anchorPosition = ANCHOR_POSITION[positionType];
    return anchorPosition.x === anchorX && anchorPosition.y === anchorY;
  }) || anchor;
}

// node_modules/@goongmaps/goong-map-react/dist/esm/components/popup.js
function ownKeys10(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread10(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys10(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys10(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var propTypes7 = Object.assign({}, mapControlPropTypes, {
  className: PropTypes9.string,
  longitude: PropTypes9.number.isRequired,
  latitude: PropTypes9.number.isRequired,
  altitude: PropTypes9.number,
  offsetLeft: PropTypes9.number,
  offsetTop: PropTypes9.number,
  tipSize: PropTypes9.number,
  closeButton: PropTypes9.bool,
  closeOnClick: PropTypes9.bool,
  anchor: PropTypes9.oneOf(Object.keys(ANCHOR_POSITION)),
  dynamicPosition: PropTypes9.bool,
  sortByDepth: PropTypes9.bool,
  onClose: PropTypes9.func
});
var defaultProps5 = Object.assign({}, mapControlDefaultProps, {
  className: "",
  offsetLeft: 0,
  offsetTop: 0,
  tipSize: 10,
  anchor: "bottom",
  dynamicPosition: true,
  sortByDepth: false,
  closeButton: true,
  closeOnClick: true,
  onClose: function onClose() {
  }
});
function getPosition2(props, viewport, el, _ref) {
  var _ref2 = _slicedToArray(_ref, 2), x = _ref2[0], y = _ref2[1];
  var anchor = props.anchor, dynamicPosition = props.dynamicPosition, tipSize = props.tipSize;
  if (el) {
    return dynamicPosition ? getDynamicPosition({
      x,
      y,
      anchor,
      padding: tipSize,
      width: viewport.width,
      height: viewport.height,
      selfWidth: el.clientWidth,
      selfHeight: el.clientHeight
    }) : anchor;
  }
  return anchor;
}
function getContainerStyle(props, viewport, el, _ref3, positionType) {
  var _ref4 = _slicedToArray(_ref3, 3), x = _ref4[0], y = _ref4[1], z = _ref4[2];
  var offsetLeft = props.offsetLeft, offsetTop = props.offsetTop, sortByDepth = props.sortByDepth;
  var anchorPosition = ANCHOR_POSITION[positionType];
  var left = x + offsetLeft;
  var top = y + offsetTop;
  var xPercentage = crispPercentage(el, -anchorPosition.x * 100);
  var yPercentage = crispPercentage(el, -anchorPosition.y * 100, "y");
  var style = {
    position: "absolute",
    transform: "\n      translate(".concat(xPercentage, "%, ").concat(yPercentage, "%)\n      translate(").concat(crispPixel(left), "px, ").concat(crispPixel(top), "px)\n    "),
    display: void 0,
    zIndex: void 0
  };
  if (!sortByDepth) {
    return style;
  }
  if (z > 1 || z < -1 || x < 0 || x > viewport.width || y < 0 || y > viewport.height) {
    style.display = "none";
  } else {
    style.zIndex = Math.floor((1 - z) / 2 * 1e5);
  }
  return style;
}
function onClick(evt, _ref5) {
  var props = _ref5.props, context = _ref5.context;
  if (props.closeOnClick || evt.target.className === "mapboxgl-popup-close-button") {
    props.onClose();
    if (context.eventManager) {
      context.eventManager.once("click", function(e) {
        return e.stopPropagation();
      }, evt.target);
    }
  }
}
function Popup(props) {
  var contentRef = (0, import_react12.useRef)(null);
  var thisRef = useMapControl(_objectSpread10(_objectSpread10({}, props), {}, {
    onClick
  }));
  var context = thisRef.context, containerRef = thisRef.containerRef;
  var _useState = (0, import_react12.useState)(false), _useState2 = _slicedToArray(_useState, 2), setLoaded = _useState2[1];
  (0, import_react12.useEffect)(function() {
    setLoaded(true);
  }, [contentRef.current]);
  var viewport = context.viewport, map = context.map;
  var className = props.className, longitude = props.longitude, latitude = props.latitude, tipSize = props.tipSize, closeButton = props.closeButton, children = props.children;
  var altitude = props.altitude;
  if (altitude === void 0) {
    altitude = getTerrainElevation(map, {
      longitude,
      latitude
    });
  }
  var position = viewport.project([longitude, latitude, altitude]);
  var positionType = getPosition2(props, viewport, contentRef.current, position);
  var containerStyle = getContainerStyle(props, viewport, containerRef.current, position, positionType);
  var onReactClick = (0, import_react12.useCallback)(function(e) {
    return !context.eventManager && onClick(e, thisRef);
  }, [context.eventManager]);
  return React7.createElement("div", {
    className: "mapboxgl-popup mapboxgl-popup-anchor-".concat(positionType, " ").concat(className),
    style: containerStyle,
    ref: containerRef
  }, React7.createElement("div", {
    key: "tip",
    className: "mapboxgl-popup-tip",
    style: {
      borderWidth: tipSize
    }
  }), React7.createElement("div", {
    key: "content",
    ref: contentRef,
    className: "mapboxgl-popup-content",
    onClick: onReactClick
  }, closeButton && React7.createElement("button", {
    key: "close-button",
    className: "mapboxgl-popup-close-button",
    type: "button"
  }, ""), children));
}
Popup.propTypes = propTypes7;
Popup.defaultProps = defaultProps5;
var popup_default = React7.memo(Popup);

// node_modules/@goongmaps/goong-map-react/dist/esm/components/attribution-control.js
var React8 = __toESM(require_react());
var import_react13 = __toESM(require_react());
var PropTypes10 = __toESM(require_prop_types());
function ownKeys11(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread11(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys11(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys11(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var propTypes8 = Object.assign({}, mapControlPropTypes, {
  toggleLabel: PropTypes10.string,
  className: PropTypes10.string,
  style: PropTypes10.object,
  compact: PropTypes10.bool,
  customAttribution: PropTypes10.oneOfType([PropTypes10.string, PropTypes10.arrayOf(PropTypes10.string)])
});
var defaultProps6 = Object.assign({}, mapControlDefaultProps, {
  className: "",
  toggleLabel: "Toggle Attribution"
});
function setupAttributioncontrol(opts, map, container, attributionContainer) {
  var control = new import_goong_js.default.AttributionControl(opts);
  control._map = map;
  control._container = container;
  control._innerContainer = attributionContainer;
  control._updateAttributions();
  control._updateEditLink();
  map.on("styledata", control._updateData);
  map.on("sourcedata", control._updateData);
  return control;
}
function removeAttributionControl(control) {
  control._map.off("styledata", control._updateData);
  control._map.off("sourcedata", control._updateData);
}
function AttributionControl(props) {
  var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
  var innerContainerRef = (0, import_react13.useRef)(null);
  var _useState = (0, import_react13.useState)(false), _useState2 = _slicedToArray(_useState, 2), showCompact = _useState2[0], setShowCompact = _useState2[1];
  (0, import_react13.useEffect)(function() {
    var control;
    if (context.map) {
      control = setupAttributioncontrol({
        customAttribution: props.customAttribution
      }, context.map, containerRef.current, innerContainerRef.current);
    }
    return function() {
      return control && removeAttributionControl(control);
    };
  }, [context.map]);
  var compact = props.compact === void 0 ? context.viewport.width <= 640 : props.compact;
  (0, import_react13.useEffect)(function() {
    if (!compact && showCompact) {
      setShowCompact(false);
    }
  }, [compact]);
  var toggleAttribution = (0, import_react13.useCallback)(function() {
    return setShowCompact(function(value) {
      return !value;
    });
  }, []);
  var style = (0, import_react13.useMemo)(function() {
    return _objectSpread11({
      position: "absolute"
    }, props.style);
  }, [props.style]);
  return React8.createElement("div", {
    style,
    className: props.className
  }, React8.createElement("div", {
    ref: containerRef,
    "aria-pressed": showCompact,
    className: "mapboxgl-ctrl mapboxgl-ctrl-attrib ".concat(compact ? "mapboxgl-compact" : "", " ").concat(showCompact ? "mapboxgl-compact-show" : "")
  }, React8.createElement("button", {
    type: "button",
    className: "mapboxgl-ctrl-attrib-button",
    title: props.toggleLabel,
    onClick: toggleAttribution
  }), React8.createElement("div", {
    ref: innerContainerRef,
    className: "mapboxgl-ctrl-attrib-inner",
    role: "list"
  })));
}
AttributionControl.propTypes = propTypes8;
AttributionControl.defaultProps = defaultProps6;
var attribution_control_default = React8.memo(AttributionControl);

// node_modules/@goongmaps/goong-map-react/dist/esm/components/fullscreen-control.js
var PropTypes11 = __toESM(require_prop_types());
var React9 = __toESM(require_react());
var import_react14 = __toESM(require_react());
function ownKeys12(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread12(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys12(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys12(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var propTypes9 = Object.assign({}, mapControlPropTypes, {
  className: PropTypes11.string,
  style: PropTypes11.object,
  container: PropTypes11.object,
  label: PropTypes11.string
});
var defaultProps7 = Object.assign({}, mapControlDefaultProps, {
  className: "",
  container: null,
  label: "Toggle fullscreen"
});
function FullscreenControl(props) {
  var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
  var _useState = (0, import_react14.useState)(false), _useState2 = _slicedToArray(_useState, 2), isFullscreen = _useState2[0], setIsFullscreen = _useState2[1];
  var _useState3 = (0, import_react14.useState)(false), _useState4 = _slicedToArray(_useState3, 2), showButton = _useState4[0], setShowButton = _useState4[1];
  var _useState5 = (0, import_react14.useState)(null), _useState6 = _slicedToArray(_useState5, 2), mapboxFullscreenControl = _useState6[0], createMapboxFullscreenControl = _useState6[1];
  (0, import_react14.useEffect)(function() {
    var control = new import_goong_js.default.FullscreenControl();
    createMapboxFullscreenControl(control);
    setShowButton(control._checkFullscreenSupport());
    var onFullscreenChange = function onFullscreenChange2() {
      var nextState = !control._fullscreen;
      control._fullscreen = nextState;
      setIsFullscreen(nextState);
    };
    document_.addEventListener(control._fullscreenchange, onFullscreenChange);
    return function() {
      document_.removeEventListener(control._fullscreenchange, onFullscreenChange);
    };
  }, []);
  var onClickFullscreen = function onClickFullscreen2() {
    if (mapboxFullscreenControl) {
      mapboxFullscreenControl._container = props.container || context.container;
      mapboxFullscreenControl._onClickFullscreen();
    }
  };
  var style = (0, import_react14.useMemo)(function() {
    return _objectSpread12({
      position: "absolute"
    }, props.style);
  }, [props.style]);
  if (!showButton) {
    return null;
  }
  var className = props.className, label = props.label;
  var type = isFullscreen ? "shrink" : "fullscreen";
  return React9.createElement("div", {
    style,
    className
  }, React9.createElement("div", {
    className: "mapboxgl-ctrl mapboxgl-ctrl-group",
    ref: containerRef
  }, React9.createElement("button", {
    key: type,
    className: "mapboxgl-ctrl-icon mapboxgl-ctrl-".concat(type),
    type: "button",
    title: label,
    onClick: onClickFullscreen
  }, React9.createElement("span", {
    className: "mapboxgl-ctrl-icon",
    "aria-hidden": "true"
  }))));
}
FullscreenControl.propTypes = propTypes9;
FullscreenControl.defaultProps = defaultProps7;
var fullscreen_control_default = React9.memo(FullscreenControl);

// node_modules/@goongmaps/goong-map-react/dist/esm/components/geolocate-control.js
var React10 = __toESM(require_react());
var import_react15 = __toESM(require_react());
var PropTypes12 = __toESM(require_prop_types());

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/geolocate-utils.js
var supported;
function isGeolocationSupported() {
  if (supported !== void 0) {
    return Promise.resolve(supported);
  }
  if (window.navigator.permissions !== void 0) {
    return window.navigator.permissions.query({
      name: "geolocation"
    }).then(function(p) {
      supported = p.state !== "denied";
      return supported;
    });
  }
  supported = Boolean(window.navigator.geolocation);
  return Promise.resolve(supported);
}

// node_modules/@goongmaps/goong-map-react/dist/esm/components/geolocate-control.js
function ownKeys13(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread13(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys13(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys13(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var noop5 = function noop6() {
};
var propTypes10 = Object.assign({}, mapControlPropTypes, {
  className: PropTypes12.string,
  style: PropTypes12.object,
  label: PropTypes12.string,
  disabledLabel: PropTypes12.string,
  auto: PropTypes12.bool,
  positionOptions: PropTypes12.object,
  fitBoundsOptions: PropTypes12.object,
  trackUserLocation: PropTypes12.bool,
  showUserLocation: PropTypes12.bool,
  showAccuracyCircle: PropTypes12.bool,
  onViewStateChange: PropTypes12.func,
  onViewportChange: PropTypes12.func,
  onGeolocate: PropTypes12.func
});
var defaultProps8 = Object.assign({}, mapControlDefaultProps, {
  className: "",
  label: "Find My Location",
  disabledLabel: "Location Not Available",
  auto: false,
  positionOptions: {
    enableHighAccuracy: false,
    timeout: 6e3
  },
  fitBoundsOptions: {
    maxZoom: 15
  },
  trackUserLocation: false,
  showUserLocation: true,
  showAccuracyCircle: true,
  onGeolocate: function onGeolocate() {
  }
});
function getBounds2(position) {
  var center = new import_goong_js.default.LngLat(position.coords.longitude, position.coords.latitude);
  var radius = position.coords.accuracy;
  var bounds = center.toBounds(radius);
  return [[bounds._ne.lng, bounds._ne.lat], [bounds._sw.lng, bounds._sw.lat]];
}
function setupMapboxGeolocateControl(context, props, geolocateButton) {
  var control = new import_goong_js.default.GeolocateControl(props);
  control._container = document_.createElement("div");
  control._map = {
    on: function on() {
    },
    _getUIString: function _getUIString() {
      return "";
    }
  };
  control._setupUI(true);
  control._map = context.map;
  control._geolocateButton = geolocateButton;
  var eventManager = context.eventManager;
  if (control.options.trackUserLocation && eventManager) {
    eventManager.on("panstart", function() {
      if (control._watchState === "ACTIVE_LOCK") {
        control._watchState = "BACKGROUND";
        geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
        geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active");
      }
    });
  }
  control.on("geolocate", props.onGeolocate);
  return control;
}
function updateCamera(position, _ref) {
  var context = _ref.context, props = _ref.props;
  var bounds = getBounds2(position);
  var _context$viewport$fit = context.viewport.fitBounds(bounds, props.fitBoundsOptions), longitude = _context$viewport$fit.longitude, latitude = _context$viewport$fit.latitude, zoom = _context$viewport$fit.zoom;
  var newViewState = Object.assign({}, context.viewport, {
    longitude,
    latitude,
    zoom
  });
  var mapState = new MapState(newViewState);
  var viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);
  var onViewportChange = props.onViewportChange || context.onViewportChange || noop5;
  var onViewStateChange = props.onViewStateChange || context.onViewStateChange || noop5;
  onViewStateChange({
    viewState
  });
  onViewportChange(viewState);
}
function GeolocateControl(props) {
  var thisRef = useMapControl(props);
  var context = thisRef.context, containerRef = thisRef.containerRef;
  var geolocateButtonRef = (0, import_react15.useRef)(null);
  var _useState = (0, import_react15.useState)(null), _useState2 = _slicedToArray(_useState, 2), mapboxGeolocateControl = _useState2[0], createMapboxGeolocateControl = _useState2[1];
  var _useState3 = (0, import_react15.useState)(false), _useState4 = _slicedToArray(_useState3, 2), supportsGeolocation = _useState4[0], setSupportsGeolocation = _useState4[1];
  (0, import_react15.useEffect)(function() {
    var control;
    if (context.map) {
      isGeolocationSupported().then(function(result) {
        setSupportsGeolocation(result);
        if (geolocateButtonRef.current) {
          control = setupMapboxGeolocateControl(context, props, geolocateButtonRef.current);
          control._updateCamera = function(position) {
            return updateCamera(position, thisRef);
          };
          createMapboxGeolocateControl(control);
        }
      });
    }
    return function() {
      if (control) {
        control._clearWatch();
      }
    };
  }, [context.map]);
  var triggerGeolocate = (0, import_react15.useCallback)(function() {
    if (mapboxGeolocateControl) {
      mapboxGeolocateControl.options = thisRef.props;
      mapboxGeolocateControl.trigger();
    }
  }, [mapboxGeolocateControl]);
  (0, import_react15.useEffect)(function() {
    if (props.auto) {
      triggerGeolocate();
    }
  }, [mapboxGeolocateControl, props.auto]);
  (0, import_react15.useEffect)(function() {
    if (mapboxGeolocateControl) {
    }
  }, [context.viewport.zoom]);
  var className = props.className, label = props.label, disabledLabel = props.disabledLabel, trackUserLocation = props.trackUserLocation;
  var style = (0, import_react15.useMemo)(function() {
    return _objectSpread13({
      position: "absolute"
    }, props.style);
  }, [props.style]);
  return React10.createElement("div", {
    style,
    className
  }, React10.createElement("div", {
    key: "geolocate-control",
    className: "mapboxgl-ctrl mapboxgl-ctrl-group",
    ref: containerRef
  }, React10.createElement("button", {
    key: "geolocate",
    className: "mapboxgl-ctrl-icon mapboxgl-ctrl-geolocate",
    ref: geolocateButtonRef,
    disabled: !supportsGeolocation,
    "aria-pressed": !trackUserLocation,
    type: "button",
    title: supportsGeolocation ? label : disabledLabel,
    "aria-label": supportsGeolocation ? label : disabledLabel,
    onClick: triggerGeolocate
  }, React10.createElement("span", {
    className: "mapboxgl-ctrl-icon",
    "aria-hidden": "true"
  }))));
}
GeolocateControl.propTypes = propTypes10;
GeolocateControl.defaultProps = defaultProps8;
var geolocate_control_default = React10.memo(GeolocateControl);

// node_modules/@goongmaps/goong-map-react/dist/esm/components/navigation-control.js
var React11 = __toESM(require_react());
var import_react16 = __toESM(require_react());
var PropTypes13 = __toESM(require_prop_types());
function ownKeys14(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread14(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys14(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys14(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var noop7 = function noop8() {
};
var propTypes11 = Object.assign({}, mapControlPropTypes, {
  className: PropTypes13.string,
  style: PropTypes13.object,
  onViewStateChange: PropTypes13.func,
  onViewportChange: PropTypes13.func,
  showCompass: PropTypes13.bool,
  showZoom: PropTypes13.bool,
  zoomInLabel: PropTypes13.string,
  zoomOutLabel: PropTypes13.string,
  compassLabel: PropTypes13.string
});
var defaultProps9 = Object.assign({}, mapControlDefaultProps, {
  className: "",
  showCompass: true,
  showZoom: true,
  zoomInLabel: "Zoom In",
  zoomOutLabel: "Zoom Out",
  compassLabel: "Reset North"
});
function updateViewport(context, props, opts) {
  var viewport = context.viewport;
  var mapState = new MapState(Object.assign({}, viewport, opts));
  var viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);
  var onViewportChange = props.onViewportChange || context.onViewportChange || noop7;
  var onViewStateChange = props.onViewStateChange || context.onViewStateChange || noop7;
  onViewStateChange({
    viewState
  });
  onViewportChange(viewState);
}
function renderButton(type, label, callback, children) {
  return React11.createElement("button", {
    key: type,
    className: "mapboxgl-ctrl-icon mapboxgl-ctrl-".concat(type),
    type: "button",
    title: label,
    onClick: callback
  }, children || React11.createElement("span", {
    className: "mapboxgl-ctrl-icon",
    "aria-hidden": "true"
  }));
}
function renderCompass(context) {
  var bearing = context.viewport.bearing;
  var style = {
    transform: "rotate(".concat(-bearing, "deg)")
  };
  return React11.createElement("span", {
    className: "mapboxgl-ctrl-icon",
    "aria-hidden": "true",
    style
  });
}
function NavigationControl(props) {
  var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
  var onZoomIn = function onZoomIn2() {
    updateViewport(context, props, {
      zoom: context.viewport.zoom + 1
    });
  };
  var onZoomOut = function onZoomOut2() {
    updateViewport(context, props, {
      zoom: context.viewport.zoom - 1
    });
  };
  var onResetNorth = function onResetNorth2() {
    updateViewport(context, props, {
      bearing: 0,
      pitch: 0
    });
  };
  var className = props.className, showCompass = props.showCompass, showZoom = props.showZoom, zoomInLabel = props.zoomInLabel, zoomOutLabel = props.zoomOutLabel, compassLabel = props.compassLabel;
  var style = (0, import_react16.useMemo)(function() {
    return _objectSpread14({
      position: "absolute"
    }, props.style);
  }, [props.style]);
  return React11.createElement("div", {
    style,
    className
  }, React11.createElement("div", {
    className: "mapboxgl-ctrl mapboxgl-ctrl-group",
    ref: containerRef
  }, showZoom && renderButton("zoom-in", zoomInLabel, onZoomIn), showZoom && renderButton("zoom-out", zoomOutLabel, onZoomOut), showCompass && renderButton("compass", compassLabel, onResetNorth, renderCompass(context))));
}
NavigationControl.propTypes = propTypes11;
NavigationControl.defaultProps = defaultProps9;
var navigation_control_default = React11.memo(NavigationControl);

// node_modules/@goongmaps/goong-map-react/dist/esm/components/scale-control.js
var React12 = __toESM(require_react());
var import_react17 = __toESM(require_react());
var PropTypes14 = __toESM(require_prop_types());
function ownKeys15(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread15(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys15(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys15(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var propTypes12 = Object.assign({}, mapControlPropTypes, {
  className: PropTypes14.string,
  style: PropTypes14.object,
  maxWidth: PropTypes14.number,
  unit: PropTypes14.oneOf(["imperial", "metric", "nautical"])
});
var defaultProps10 = Object.assign({}, mapControlDefaultProps, {
  className: "",
  maxWidth: 100,
  unit: "metric"
});
function ScaleControl(props) {
  var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
  var _useState = (0, import_react17.useState)(null), _useState2 = _slicedToArray(_useState, 2), mapboxScaleControl = _useState2[0], createMapboxScaleControl = _useState2[1];
  (0, import_react17.useEffect)(function() {
    if (context.map) {
      var control = new import_goong_js.default.ScaleControl();
      control._map = context.map;
      control._container = containerRef.current;
      createMapboxScaleControl(control);
    }
  }, [context.map]);
  if (mapboxScaleControl) {
    mapboxScaleControl.options = props;
    mapboxScaleControl._onMove();
  }
  var style = (0, import_react17.useMemo)(function() {
    return _objectSpread15({
      position: "absolute"
    }, props.style);
  }, [props.style]);
  return React12.createElement("div", {
    style,
    className: props.className
  }, React12.createElement("div", {
    ref: containerRef,
    className: "mapboxgl-ctrl mapboxgl-ctrl-scale"
  }));
}
ScaleControl.propTypes = propTypes12;
ScaleControl.defaultProps = defaultProps10;
var scale_control_default = React12.memo(ScaleControl);

// node_modules/@goongmaps/goong-map-react/dist/esm/overlays/canvas-overlay.js
var React13 = __toESM(require_react());
var import_react18 = __toESM(require_react());
var PropTypes15 = __toESM(require_prop_types());
var pixelRatio2 = typeof window !== "undefined" && window.devicePixelRatio || 1;
var propTypes13 = Object.assign({}, mapControlPropTypes, {
  redraw: PropTypes15.func.isRequired
});
var defaultProps11 = {
  captureScroll: false,
  captureDrag: false,
  captureClick: false,
  captureDoubleClick: false,
  capturePointerMove: false
};
function CanvasOverlay(props) {
  var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
  var _useState = (0, import_react18.useState)(null), _useState2 = _slicedToArray(_useState, 2), ctx = _useState2[0], setDrawingContext = _useState2[1];
  (0, import_react18.useEffect)(function() {
    setDrawingContext(containerRef.current.getContext("2d"));
  }, []);
  var viewport = context.viewport, isDragging = context.isDragging;
  if (ctx) {
    ctx.save();
    ctx.scale(pixelRatio2, pixelRatio2);
    props.redraw({
      width: viewport.width,
      height: viewport.height,
      ctx,
      isDragging,
      project: viewport.project,
      unproject: viewport.unproject
    });
    ctx.restore();
  }
  return React13.createElement("canvas", {
    ref: containerRef,
    width: viewport.width * pixelRatio2,
    height: viewport.height * pixelRatio2,
    style: {
      width: "".concat(viewport.width, "px"),
      height: "".concat(viewport.height, "px"),
      position: "absolute",
      left: 0,
      top: 0
    }
  });
}
CanvasOverlay.propTypes = propTypes13;
CanvasOverlay.defaultProps = defaultProps11;
var canvas_overlay_default = CanvasOverlay;

// node_modules/@goongmaps/goong-map-react/dist/esm/overlays/html-overlay.js
var React14 = __toESM(require_react());
var PropTypes16 = __toESM(require_prop_types());
function ownKeys16(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread16(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys16(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys16(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var propTypes14 = Object.assign({}, mapControlPropTypes, {
  redraw: PropTypes16.func.isRequired,
  style: PropTypes16.object
});
var defaultProps12 = {
  captureScroll: false,
  captureDrag: false,
  captureClick: false,
  captureDoubleClick: false,
  capturePointerMove: false
};
function HTMLOverlay(props) {
  var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
  var viewport = context.viewport, isDragging = context.isDragging;
  var style = _objectSpread16({
    position: "absolute",
    left: 0,
    top: 0,
    width: viewport.width,
    height: viewport.height
  }, props.style);
  return React14.createElement("div", {
    ref: containerRef,
    style
  }, props.redraw({
    width: viewport.width,
    height: viewport.height,
    isDragging,
    project: viewport.project,
    unproject: viewport.unproject
  }));
}
HTMLOverlay.propTypes = propTypes14;
HTMLOverlay.defaultProps = defaultProps12;
var html_overlay_default = HTMLOverlay;

// node_modules/@goongmaps/goong-map-react/dist/esm/overlays/svg-overlay.js
var React15 = __toESM(require_react());
var PropTypes17 = __toESM(require_prop_types());
function ownKeys17(object11, enumerableOnly) {
  var keys = Object.keys(object11);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object11);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object11, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread17(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys17(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys17(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var propTypes15 = Object.assign({}, mapControlPropTypes, {
  redraw: PropTypes17.func.isRequired,
  style: PropTypes17.object
});
var defaultProps13 = {
  captureScroll: false,
  captureDrag: false,
  captureClick: false,
  captureDoubleClick: false,
  capturePointerMove: false
};
function SVGOverlay(props) {
  var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
  var viewport = context.viewport, isDragging = context.isDragging;
  var style = _objectSpread17({
    position: "absolute",
    left: 0,
    top: 0
  }, props.style);
  return React15.createElement("svg", {
    width: viewport.width,
    height: viewport.height,
    ref: containerRef,
    style
  }, props.redraw({
    width: viewport.width,
    height: viewport.height,
    isDragging,
    project: viewport.project,
    unproject: viewport.unproject
  }));
}
SVGOverlay.propTypes = propTypes15;
SVGOverlay.defaultProps = defaultProps13;
var svg_overlay_default = SVGOverlay;

// node_modules/@goongmaps/goong-map-react/dist/esm/utils/set-rtl-text-plugin.js
var setRTLTextPlugin = import_goong_js.default ? import_goong_js.default.setRTLTextPlugin : function() {
};
var set_rtl_text_plugin_default = setRTLTextPlugin;
export {
  attribution_control_default as AttributionControl,
  BaseControl,
  canvas_overlay_default as CanvasOverlay,
  ViewportFlyToInterpolator as FlyToInterpolator,
  fullscreen_control_default as FullscreenControl,
  geolocate_control_default as GeolocateControl,
  html_overlay_default as HTMLOverlay,
  interactive_map_default as InteractiveMap,
  layer_default as Layer,
  LinearInterpolator,
  map_context_default as MapContext,
  MapController,
  marker_default as Marker,
  navigation_control_default as NavigationControl,
  popup_default as Popup,
  svg_overlay_default as SVGOverlay,
  scale_control_default as ScaleControl,
  source_default as Source,
  static_map_default as StaticMap,
  TRANSITION_EVENTS,
  TransitionInterpolator,
  WebMercatorViewport,
  map_context_default as _MapContext,
  useMapControl as _useMapControl,
  interactive_map_default as default,
  set_rtl_text_plugin_default as setRTLTextPlugin
};
/*! Bundled license information:

hammerjs/hammer.js:
  (*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license *)
*/
//# sourceMappingURL=@goongmaps_goong-map-react.js.map
